\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{Crossover Zahnbehandlungen}
\subtitle{Wurzelziehen Drei}
\date{KW 20}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{3}

\iffull\begin{document}
\titleframe

\TopicOverview{3}
\fi

\iffull{\SummaryFrame
\def\k{\textcolor{gray}{\(\rightarrow\)}}
\def\K{\textcolor{gray}{\(\longrightarrow\)}}
\def\a{\textcolor{codeouthl}{a}}
\def\b{\textcolor{codeouthl}{b}}
\setbeamerfont{description item}{shape=\itshape,series=\mdseries,size=\footnotesize}
\setbeamerfont{description body}{size=\footnotesize}
\setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
\begin{frame}[fragile,c]{Kurzwiederholung}
    \begin{itemize}[<+(1)->]
        \itemsep9.25pt
        \item Algorithmen können wir auf diverse Eigenschaften untersuchen: \begin{description}[Totale Korrektheit:]
            \item[Determiniertheit:] die gleiche Eingabe erzeugt immer die gleiche Ausgabe\hfill\tikz[align-half-base,every path/.append style={line cap=round},gray]{\node[circle,scale=.4,fill] (a) at (0,0) {}; \node[circle,scale=.4,fill] (b) at (.7,0) {}; \pgfonlayer{background}\draw[codeouthl](a) to[bend left=30.5] (b); \draw[codeouthl](a) to[bend right=30.5] (b); \draw[codeouthl](a) to[bend left=10] (b); \draw[codeouthl](a) to[bend right=10] (b); \endpgfonlayer\node[scale=.85,circle,fill=white,opacity=.3,text opacity=1,inner sep=0pt] at(current bounding box.center) {?};}
            \item[Determinismus:] bei gleicher Eingabe folgt stets die gleiche Schrittfolge \info{\textcolor{gray}{~\(\Rightarrow\)~Determiniert}}\hfill\tikz[align-half-base,every path/.append style={line cap=round},gray]{\node[circle,scale=.4,fill] (a) at (0,0) {}; \node[circle,scale=.4,fill] (b) at (.7,0) {}; \pgfonlayer{background}\draw[codeouthl](a) to[bend left=30.5] (b); \draw[codeouthl](a) to[bend right=30.5] (b); \draw[gray](a) to[bend left=10] (b); \draw[codeouthl](a) to[bend right=10] (b);\endpgfonlayer}
            \item[Totale Korrektheit:] Terminiert und partiell korrekt \info{\(\text{Terminiert} \implies \text{gewünschte Ausgabe}\)}
        \end{description}
        \item Manche von Javas primitiven Datentypen können implizit konvertiert werden \begin{itemize}
            \item \bjava{byte}~\k~\bjava{short}~\k~\bjava{int}~\k~\bjava{long}~\k~\bjava{double}~~und~~\bjava{char}~\k~\bjava{int}
        \end{itemize}
        \item Javas Präzedenzregeln geben an, wie Operatoren implizit geklammert werden \begin{itemize}
            \item \textcolor{codeouthl}{(stark)}~~~\T{\a++}~\K~\T{!\a}, \T{++\a}~\K~\T{\a\,/\,\b}, \T{\a\,*\,\b}~\K~\T{\a\,+\,\b}, \T{\a\,-\,\b}~\K~\T{\a\,==\,\b}~\K~\T{\a\,\&\&\,\b}~\K~\T{\a\,|\!|\,\b}~~~\textcolor{codeouthl}{(schwach)}%\smallskip
            \item Bei Ganzzahldivisionen werden Nachkommastelle abgeschnitten \info{\bjava{5/2} ergibt \bjava{2}}
            \item Bei unterschiedlichen Typen (\bjava{5.0/2}) wird der \say{kleinere} implizit \say{angehoben} (\bjava{5.0/2.0})
            \item \bjava{byte} oder \bjava{short} werden dabei immer mindestens zu \bjava{int} \info{\say{promoted}/widening, \link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html\#jls-5.6}{JLS17~5.6}}
        \end{itemize}
        % für Ganzzahlen (\bjava{byte}, \bjava{short}, \bjava{int}, \bjava{long}), Fließkommazahlen (\bjava{float}, \bjava{double}), Zeichen (\bjava{char}) und Wahrheitswerte (\bjava{boolean})
%        \begin{itemize}
% TODO:            \item Variablen dekl, init, zws
%        \end{itemize}
        \item Wenn verschachtelte Schleifen voneinander abhängen, hilft Gauß \info{\raisebox{1.5pt}{\(\scriptstyle\sum_{i = \text{1}}^N i\;{}={} \frac{N \cdot (N + \text{1})}{\text{2}}\)}}% TODO: Schleifen die voneinander abhängen
% \item TODO: Kommandozeilenparameter
    \end{itemize}
    \onslide<1->
\end{frame}

\begin{frame}[c]{Zum Warmwerden}
\colorlet{tskcolor}{btdm@primary!20!black!50!white}%
\colorlet{tskcolorA}{btdm@primary}%
\colorlet{tskcolorB}{btdm@primary}%
\begin{aufgabe}{Ich bin der Klammeraffen Typ}
    \small\onslide<2->{Drücken Sie im Folgenden die Präzedenzregeln \textit{explizit} durch Klammern aus, so dass die unten stehenden Ausdrücke auch ohne Präzedenzregeln in der gleichen Reihenfolge ausgeführt werden.} \onslide<3->{Geben Sie weiter den Typ des gesamten Ausdrucks an (\bjava{int i}, \bjava{short a} und \bjava{float f}).} \onslide<4->{Werten Sie die Ausdrücke \textit{nicht} aus.}
\begin{enumerate}
    \itemsep8pt
    \item<5-> \bjava{i + 3 * s++ + (-2 - 4)}
    \item<6-> \bjava{true && 3 > 4d || 2 - f != 5}
\end{enumerate}
\onslide<1->
\end{aufgabe}
\end{frame}

\def\NOl{}
\def\NOr{}
\newcommand<>\b[2]{{\onslide#3{$\mathtt{\color{gray}\csname #2l\endcsname(}$}}#1{\onslide#3{$\mathtt{\color{gray}\csname #2r\endcsname)}$}}}
% there is somewhat of a problem when nesting braces
% after some tries, this boxout strat seems to cut it
\newcommand<>\Tunderbrace[2]{\setbox0=\hbox{#1}$\only#3{\expandafter\underbrace}{\copy0}_{\onslide#3{#2}}$}
\newcommand<>\u[2]{\Tunderbrace#3{#1}{\smash{\clap{\solGet{keywordB}{\scriptsize\HStrut#2}}}}}
\newcommand<>\Toverbrace[2]{\setbox0=\hbox{#1}$\only#3{\expandafter\overbrace}{\copy0}^{\onslide#3{#2}}$}
\newcommand<>\o[2]{\Toverbrace#3{\text{#1}}{\clap{\text{\solGet{keywordB}{\scriptsize\HStrut#2}}}}}
\begin{frame}[t]{Klammeraffenfreude}
\begin{enumerate}
    \itemsep14pt
    \item<2-> Wir klammern\strut\only<11->{~und erhalten den Typ \bjava{int}}:\smallskip
%{\tracingall
\begin{center}
    \T{\u<7->{i}{int} + \o<10->{\b<3->{\u<9->{\b<4->{\u<7->{\snum{3}}{int} * \b<5->{\o<8->{\u<7->{s}{short}++}{short}}{NO}}{big}}{int} + \u<9->{(\b<6->{\o<8->{-\u<7->{\snum{2}}{int}}{int}}{NO} - \u<7->{\snum{4}}{int})}{int}}{Big}}{int}}
\end{center}
%}
    \item<12-> Wir klammern \strut erneut\only<18->{~und erhalten den Typ \bjava{boolean}}:\smallskip
\begin{center}% spacing around 4d fixing brace font bug
    \T{\u<17->{\b<13->{\u<15->{true}{boolean} \&\& \o<16->{\b<14->{\u<15->{\snum{3}}{int} > \u<15->{\,\snum{4}d\,}{double}}{NO}}{boolean}}{big}}{boolean} || \u<17->{\b<13->{\o<16->{\b<14->{\u<15->{\snum{2}}{int} - \u<15->{f}{float}}{NO}}{float} != \u<15->{\snum{5}}{int}}{big}}{boolean}}
\end{center}
\end{enumerate}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<19->{\node[T,below left,yshift=-1.4cm,text width=8cm,scale=.75] at(current page.north east) {Interaktiv kann dies in der \link{https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm}{JShell} ausprobiert werden. Definiert einfach eine Methode wie \T{void give(Object o) { System.out.println(o.getClass());}}. Dann gibt z.B.~\T{give(3 + 2d);} den Typ des Ausdrucks aus.};}
\end{tikzpicture}
\end{frame}
}\fi

\SetNextSectionText[.55\linewidth]{My volition shrinks from the painful task of recalling my humiliation; yet, like a second Prometheus, I will endure this and worse, if by any means I may arouse in the interiors of Plane and Solid Humanity a spirit of rebellion against the Conceit which would limit our Dimensions to Two or Three or any number short of Infinity.\\---~Edwin A. Abbott~\cite{abbott1987flatland}}
\section{Präsenzaufgabe}
\subsection{The simple solution}
\begin{frame}[c]{Präsenzaufgabe}
\begin{aufgabe}{Von doppelten Methoden}
    \small\onslide<2->{Mehrdimensionale Arrays, also solche Arrays, bei denen die Elemente selbst wiederum Arrays sein können, können wir als Matrizen interpretieren, beispielsweise ist \bjava{array[1][3]} das Element der zweiten Zeile in der vierten Spalte.} \onslide<3->{Legen Sie eine Java Datei namens \T{PositiveEintraege.java} an und implementieren Sie folgende Teilaufgaben innerhalb dieser Datei \info{oder bearbeiten Sie die Aufgabe auf einem Blatt Papier}.}
\begin{enumerate}
    \itemsep-2pt
    \item<4-> Initialisieren Sie ein zweidimensionales Array mit \(3 \times 3\) Elementen vom Typ \bjava{double} mit gültigen Werten in der \bjava{main}-Methode.
    \item<5-> Implementieren Sie eine Methode \bjava{public static int anzahlPositive}\allowbreak\bjava{(double[][] matrix)}, die die Anzahl der positiven Eintrage (\(> 0\)) bestimmt und zurückgibt. Für ungültige Matrizen soll die Methode \bjava{-1.0} zurückgeben.
    \item<6->[\color{gray}3.] \color{gray}Testen Sie die Implementierung aus b) mit ihrem Array aus a).
\end{enumerate}
\onslide<1->
\end{aufgabe}
\end{frame}

\begin{frame}[c,fragile]{An Array a day}
\begin{itemize}
    \item<2-> Wir basteln uns eine Klasse und Initialisieren froh umher.
\end{itemize}
\DoAnimations
\begin{plainjava}
$3->$public class PositiveEintraege {
$4->$    public static void main(String[] args) {
$5->$        double[][] mat = {
$6->$              { -1.0, :ws:21.0, :ws:3.0 }, $7->\text{\tikzmarknode{r1}{\T{\HStrut}}}$
$6->$              $6->\text{\tikzmarknode{@1}{\sbasic{\HStrut\{ \snum{~1.0}, ~\snum{42.0},~-\snum{3.0} \}}}}$, $8->\text{\tikzmarknode{r2}{\T{\HStrut}}}$
$6->$              { :ws:1.0, -84.0, :ws:3.0 }  $9->\text{\tikzmarknode{r3}{\T{\HStrut}}}$
$5->$       };
$4->$     }
$3->$}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<7->{
        \node[T,right,yshift=1pt] at(r1.east) {\T{mat[0]}~\(\to\) \T{\{-1.0, 21.0, 3.0\}}};
    }
    \onslide<8->{
        \hlcode[.5pt]{@1}{@K1}
        \node at(@1) {\sbasic{\HStrut\{ \snum{~1.0}, ~\snum{42.0}, -\snum{3.0} \}}};
        \node[T,right,outer xsep=0pt,inner sep=0pt] (@r) at(r2.east) {\sbasic{\normalsize\HStrut}\T{mat[1]}};
        \node[T,right,outer xsep=0pt,inner sep=0pt] at (@r.east) {\sbasic{\normalsize\HStrut}\T{[2]}~\(\to\) \T{-3.0}};
        \pgfonlayer{background}
            \onslide<8->{\hlcode[.5pt]{@r}{@K2}}
        \endpgfonlayer
    }
\end{tikzpicture}
\end{frame}

{\MakeThePinguExplainIt[text width=5.75cm,yshift=-5mm]{cap=!hide,cup=!hide,construction helmet=btdm@primary!60!btdm@background}{Was heißt \say{ungültig?} Das werden wir voerst zurückstellen!}
\begin{frame}[c,fragile]{Hey guy's, i did some methods}
\task<2->{Implementieren Sie eine Methode \T{anzahlPositive(double[][])}, die die Anzahl der positiven Eintrage (\(> 0\)) bestimmt und zurückgibt. Für \only<3->{\expandafter\textbf}{ungültige} Matrizen soll die Methode \T{-1.0} zurückgeben.}
\DoAnimations\SetupLstHl
\begin{plainjava}
$5->$public class PositiveEintraege {
$5->$    |ihl|public static void main(String[] args) { $6->$:ldots:$5->$ }|ihl|
$7->$    public static int anzahlPositive(double[][] matrix) {
$8->$        int anzahl = 0;
$9->$        for(int row = 0; row < matrix.length; row++) {
$10->$            for(int col = 0; col < matrix[row].length; col++) {
$11->$                if(matrix[row][col] > 0)  anzahl = anzahl + 1;
$10->$            }
$9->$        }
$12->$        return anzahl;
$7->$   }
$5->$}$1->$
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<4->{\node[left=-4mm,xshift=4mm,scale=.8,yshift=\btdmfootheight] at(current page.-29) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
}

\iffull
{\AddonFrame
\begin{frame}{Complex Guardians}
\begin{itemize}[<+(1)->]
    \itemsep11pt
    \item Arrays sind in Java \emph{komplexe} Datentypen \info{vs. Javas primitiver Datentypen}
    % \item Solche sind Referenzdatentypen \info{dazu später mehr!}
    \item Neben einem \say{gültigen} Wert, können diese auch den Wert \bjava{null} haben \begin{itemize}
        \item Mit \bjava{double[][] matrix = null;} liefert \bjava{matrix[1]} eine \bjava{NullPointerException}
        \item Prüfen können wir dies beispielsweise mit \bjava{matrix == null}
    \end{itemize}
    \item Allgemein sollte nie \bjava{null} übergeben oder zurückgegeben werden
    \item Neben \bjava{null}, könnte man auch noch weitere Dinge abprüfen \begin{itemize}
        \item Gibt es überhaupt eine Zeile \bjava{matrix.length == 0}?
        \item Gibt es überhaupt eine Spalte \bjava{matrix[row].length == 0}?
        \item Und viele mehr\ldots\ In jedem Fall sollte man diese mit einem Kommentar absichern
    \end{itemize}
    \item Mit komplexen Datentypen werden wir später noch viel Freude haben!
\end{itemize}
\end{frame}
}\fi

\begin{frame}[c,fragile]{Die Suche nach der positiven Anzahl}
\DoAnimations\lstfs{10}
\begin{plainjava}
$2->$public static int anzahlPositive(double[][] matrix) {
$4->$    if (matrix == null || matrix.length == 0) {
$5->$        System.out.println("Matrix ungültig!");
$6->$        return -1;
$4->$    }

$3->$    int anzahl = 0;
$3->$    for(int row = 0; row < matrix.length; row++) {
$3->$        for(int col = 0; col < matrix[row].length; col++) {
$3->$            if (matrix[row][col] > 0)
$3->$                anzahl = anzahl + 1;
$3->$        }
$3->$    }
$3->$    return anzahl;
$2->$}
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{Testen des Algorithmus}
\DoAnimations\SetupLstHl
\begin{itemize}[<+(1)->]
    \item Wir kehren in die \bjava{main}-Methode zurück:
\begin{plainjava}
$3->$|ihl|public class PositiveEintraege {|ihl|
$5->$    public static void main(String[] args) {
$6->$        double[][] mat = {{-1, 21, 3}, {1, 42, -3}, {1, -84, 3}};
$7->$        int anzahl = anzahlPositive(mat);
$8->$        System.out.println("erwartet: 6, erhalten: " + anzahl);
$5->$    }

$4->$    |ihl|public static int anzahlPositive(double[][] matrix) { :ldots: }|ihl|
$3->$|ihl|}|ihl|$1->$
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \only<9->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath PositiveEintraege.java}{PositiveEintraege.java}\;};}
\end{tikzpicture}
\end{frame}

\iffull{\AddonFrame
\begin{frame}[fragile]{Assertions und Tests}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Natürlich können wir einfach mit \bjava{if} prüfen ob wir das geforderte Ergebnis erhalten.
        \item Von Haus aus liefert Java \bjava{assert :lan:Bedingung:ran:} \begin{itemize}
            \item Dieses liefert einen Fehler, wenn die Bedingung nicht erfüllt ist:
\begin{plainjava}
int i = 0;
assert i > 0;  // :yields: Fehler!
\end{plainjava}
            \item Damit Assertions ausgeführt werden, benötigt java \bbash{-ea} als Argument: \bbash{java -ea Example}\infoblock{Das \T{-ea} steht hier für \say{enable assertions}}
            \item Assertions sollten immer nur zusätzlich zu Bedingungen verwendet werden.
        \end{itemize}
        \item Für \say{richtige} Unit-Tests gibt es Framework wie \link{https://junit.org/junit5/}{JUnit} \info{das obliegt weiteren Veranstaltungen}
        \item Allgemein ist Testen ein aufwändiger und wichtiger Teil der Programmierarbeit! % TODO: eventuelle Vertiefung anschneiden.
    \end{itemize}
\end{frame}
}
\fi

\subsection{The crazy Over-Engineer}
\iffull
{\AddonFrame
\setbox\pinguA=\hbox{\tikz\pingu[wings shock,eyes shock,body=pingu@black];}
\begin{frame}[fragile]{Wait. What was that?}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \itemsep9pt
    \item Wir haben eine eigene Methode erschaffen. \onslide<3->{Oder gar eine \setbox\pinguB=\hbox{Funktioooon}\copy\pinguB?}\onslide<4->{\llap{\smash{$\underset{\textit{\color{gray}pssssst}}{\raisebox{-.25\height}{\resizebox*!{6mm}{\copy\pinguA}}}$}\hskip.5\wd\pinguB\relax}}
    \item<5-> Wir rekapitulieren:\medskip\lstfs{10}
\begin{plainjava}
!*\onslide<5->*!|ihl|public class PositiveEintraege {|ihl|
!*\onslide<6->*!    !*\bnode{vismod}{\bnode{public}{\skA{public}} \bnode{static}{\skA{static}}}*! !*\bnode{int}{\skB{int}}*! !*\bnode{anzahlPositive}{\sbasic{anzahlPositive}}*!(!*\bnode{params}{\bnode{double-arr}{\skB{double}[][]} matrix}*!) { !*\Snode{@s}*!
!*\onslide<7->*!        |ihl|if (...) {|ihl|
!*\onslide<7->*!            |ihl|...|ihl|
!*\onslide<7->*!            !*\tikzmarknode{return1}{\skA{return}}*! |ihl|...;|ihl|
!*\onslide<7->*!        |ihl|}|ihl|
!*\onslide<7->*!
!*\onslide<7->*!        |ihl|...|ihl|
!*\onslide<7->*!        !*\tikzmarknode{return2}{\skA{return}}*! |ihl|...;|ihl|
!*\onslide<6->*!    } !*\Snode{@e}*!
!*\onslide<5->*!|ihl|}|ihl|
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    % \hlbcode[.5pt]{vismod}{@}
    \only<8->{\tfd{vismod}{Modifikatoren}}
    \only<9->{\tfd{int}{Rück-\\gabetyp}}
    \only<10->{\tfd{anzahlPositive}{Name}}
    \only<11->{\tfd{params}{Parameter}}
    \only<12->{
        \draw[decorate,decoration=brace] (@s.north east) to[edge node={node[right] {\scriptsize\itshape Body}}] (@e.south east-|@s.north east);
    }
    \only<13->{
        \path (params.north east) -- (params@.north west) coordinate[pos=.5] (@t);
        \draw[Kite-] ([yshift=1mm]@t) to[out=70,in=250] ++(1,.5) node[above=-1mm] {Eingabedaten};
    }
    \only<14->{
        \path (int.north east) -- (int@.north west) coordinate[pos=.5] (@i);
        \draw[-Kite] ([yshift=1mm]@i) to[out=70,in=250] ++(1,.5) node[above=-1mm] {Ausgabetyp};
    }
    \only<15->{
        \draw[-Kite] ([yshift=-1mm]return1.south) to[out=290,in=182] ++(1,-.25) node[right] (@out) {Ausgabedaten};
    }
    \only<16->{
        \draw[-Kite] ([yshift=1mm]return2.north) to[out=40,in=230] ([yshift=1mm]@out.south);
    }
    \only<17->{
        \node[below right,T,text width=5.65cm,xshift=-1cm,yshift=1.5mm] at (@out.south east) {Wenn an der Stelle des Rückgabetyps \textit{nicht} das Keyword \T{void} steht, \textit{muss} (in Java und abseits Exceptions) jeder Ausführungspfad Ausgabedaten vom angegebenen Typ zurückliefern!};
    }
\end{tikzpicture}
\end{frame}
\begin{frame}[fragile]{Das ist nicht gut, bis ich es nicht fein-Schleif}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \item Werfen wir noch einmal einen Blick auf die Hauptschleife:
\begin{plainjava}
!*\onslide<3->*!for(int row = 0; row < matrix.length; row++) {
!*\onslide<4->*!    for(int col = 0; col < matrix[row].length; col++) {
!*\onslide<5->*!        if (matrix[row][col] > 0) |ihl|...|ihl|
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \item<6-> Über diverse Daten in Java \info{Arrays,~\ldots}, können wir \say{iterieren}
    \item<7-> Dafür bietet java ein wenig \textit{syntactic-sugar} mit \say{for-each}!
\end{itemize}
\end{frame}
\savebox\codebox{\SetupLstHl\begin{minipage}{12.5cm}
\begin{plainjava}^^J
for(int row = 0; row < matrix.length; row++) \{^^J
:ws::ws::ws::ws:for(int col = 0; col < matrix[row].length; col++) \{^^J
:ws::ws::ws::ws::ws::ws::ws::ws:if (matrix[row][col] > 0) |ihl|...|ihl|^^J
:ws::ws::ws::ws:\}^^J
\}^^J
\end{plainjava}
\end{minipage}}

\begin{frame}[fragile]{Zucker und weitere tolle Dinge}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \item \say{for-each} ist kein Keyword, sondern eine Alternative \bjava{for}-Schleife:
\begin{plainjava}
!*\onslide<3->*!for(double[] row : matrix) {
!*\onslide<4->*!    for(double cell : row) {
!*\onslide<5->*!        if (cell > 0) |ihl|...|ihl|
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \item<7-> Ein Nachteil? Wir verlieren die Information, das wie-vielte Element das ist. \onslide<8->{\infoblock{Weiter können wir durch \T{cell} die Matrix nicht mehr verändern. Das kommt später.}}
    \item<9-> Dafür ist es meist (viel) kompakter!
\end{itemize}
\begin{tikzpicture}[remember picture,overlay]
\node[above left,yshift=\btdmfootheight,scale=.7] at(current page.south east) {\copy\codebox};
\end{tikzpicture}
\end{frame}
}
\fi
% \begin{frame}
%     % TODO: System: Format
% \end{frame}

\SetNextSectionText{Kontrollstrukturen\\Abgabe: \DTMDate{2022-05-16}}
\section{Übungsblatt 3}
\subsection{Aufgabe 1}
\begin{frame}[fragile]{Aufgabe 1: Bedingte Anweisungen und Boolesche Ausdrücke}
    \lstfs{10}%
    \task<2->{Betrachten Sie den folgenden Java Code-Ausschnitt. Vereinfachen Sie die verschachtelten \T{if}/\T{else} Blöcke so, dass die korrekte Zuweisung der Variablen \T{z} \emph{ohne} Kontrollstrukturen (\T{if}, \T{else}, \T{switch}, \T{while}, \T{do-while}, \T{for}, ternärer Operator) in einer Zeile verarbeitet wird, d.h. direkt über eine Zuweisung mithilfe eines Booleschen Ausdrucks.
    Gehen Sie davon aus, dass die Variablen \T{x} und \T{y} vom Typ \T{int} und \T{z} vom Typ \T{boolean} sind und alle Variablen
    gültige Werte besitzen.}
\columns[onlytextwidth,c]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<3->*!if(x >= 0){!*\Snode{@a}*!
!*\onslide<3->*!    if(y <= 0) {!*\Snode{@b}*!
!*\onslide<3->*!        !*\tikzmarknode{1}{\sbasic{\HStrut z = \sliteral{true}}}*!;
!*\onslide<3->*!    } else {:ws::ws::ws:!*\Snode{@c}*!
!*\onslide<3->*!        if(y == 1) { !*\tikzmarknode{2}{\sbasic{\HStrut z = \sliteral{true}}}*!; }
!*\onslide<3->*!    }
!*\onslide<3->*!} else {
!*\onslide<3->*!    !*\tikzmarknode{3}{\sbasic{\HStrut z = \sliteral{false}}}*!;
!*\onslide<3->*!}
\end{plainjava}
\column{.5\linewidth}
\onslide<5->{\T{z} ist nur \bjava{true}, wenn}
\updateitemize{\;\textbullet}%
\begin{itemize}
    \item<7->[\textcolor{btdm@primary}{\textbullet}] \bjava{x >= 0 && y <= 0}
\end{itemize}
\onslide<9->{\textit{Oder:}}
\begin{itemize}
    \item<9->[\textcolor{gray}{\textbullet}] \bjava{x >= 0 && !(y <= 0) && y == 1}
\end{itemize}
\onslide<10->{Kombiniert kommen wir auf:}
\begin{plainjava}
!*\onslide<11->*!z = (x >= 0 && y <= 0) || (x >= 0 && !(y <= 0) && y == 1);
!*\onslide<1->*!
\end{plainjava}
% \onslide<12->{\textbf{Done}}~\onslide<13->{\ldots?}
\endcolumns
\begin{tikzpicture}[overlay,remember picture]
\onslide<4->{
    \hlcode{1}{@1}
    \node at (1) {\sbasic{\HStrut z = \sliteral{true}}};
    \hlcode{2}{@2}
    \node at (2) {\sbasic{\HStrut z = \sliteral{true}}};
    \hlcode{3}{@2}
    \node at (3) {\sbasic{\HStrut z = \sliteral{false}}};
}
\onslide<6->{
    \node[right,btdm@primary] at(@a) {\raisebox{1pt}{\textbullet}};
    \node[right,btdm@primary] at(@b) {\raisebox{1pt}{\textbullet}};
}
\onslide<8->{
    \node[right=4mm,gray] at(@b) {\raisebox{1pt}{\textbullet}};
    \node[above=-3mm,gray] at(@c) {\raisebox{1pt}{\textbullet}};
}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Ausdrücke vereinfachen}
\begin{itemize}[<+(1)->]
    \item Wir hatten einen recht langen Ausdruck:
\begin{plainjava}
!*\onslide<3->*!z = (x >= 0 && y <= 0) || (x >= 0 && !(y <= 0) && y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<4-> Zunächst ist \bjava{!(y <= 0)} redundant, wenn \bjava{y == 1} gilt:
\begin{plainjava}
!*\onslide<5->*!z = (x >= 0 && y <= 0) || (x >= 0 && y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<6-> In beiden Fällen muss \bjava{x >= 0} gelten:
\begin{plainjava}
!*\onslide<7->*!z = (x >= 0) && (y <= 0 || y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<8-> Nun ist \bjava{y} ein \bjava{int}, zwischen \bjava{0} und \bjava{1} ist nichts:
\begin{plainjava}
!*\onslide<9->*!z = (x >= 0) && (y <= 1);!*\onslide<1->*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[above left, T,yshift=\btdmfootheight] at(current page.south east) {Welche dieser Klammern sind optional?};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Ein Mini-Kommentar über die Korrektheit}
\begin{itemize}[<+(1)->]
    \item Das hatte quasi jeder und die Mehrheit hat Recht!\medskip
\columns[onlytextwidth,c]
\column{.35\linewidth}
\begin{plainjava}
!*\onslide<3->*!if(x >= 0){
!*\onslide<3->*!    if(y <= 0) {
!*\onslide<3->*!        z = true;
!*\onslide<3->*!    } else {
!*\onslide<3->*!        if(y == 1) {
!*\onslide<3->*!            z = true;
!*\onslide<3->*!        }
!*\onslide<3->*!    }
!*\onslide<3->*!} else {
!*\onslide<3->*!    z = false;
!*\onslide<3->*!}
\end{plainjava}
\column{.65\linewidth}
\onslide<4->{Sei \(\text{\T{x}} \geq 0\) und \(\text{\T{y}} > 1\). Welchen Wert hat \T{z}?}
\begin{itemize}
    \item<5-> Na ja, den Alten!\SetupLstHl
\begin{plainjava}
!*\onslide<6->*!z = |ihl|x >= 0 &&|ihl| (|ihl|y <= 1|ihl| || z);
\end{plainjava}
    \item<7-> Das Problem? Was, wenn \T{z} davor nicht initialisiert wurde?
    \item<8-> Dann ist das ohne Kontrollstrukturen unmöglich
    \item<10-> Korrekt wäre: \textbf{die Aufgabe ist \info{mit EidI-Wissen} unmöglich}
\end{itemize}
\endcolumns
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<9->{\node[above left, T,yshift=\btdmfootheight] at(current page.south east) {Genau genommen kann man für eine spezifische Version und Programmstruktur\ldots};}
\end{tikzpicture}
\end{frame}
\iffull
\begin{frame}[c]{}
\centering\only<2->{\global\dmfootfalse}
\begin{tikzpicture}[overlay,remember picture]
\onslide<2->{
    \fill[pingu@black] (current page.south east) rectangle (current page.north west);
}
\end{tikzpicture}
\scalebox{3}{\begin{tikzpicture}
    \onslide<3->{\pingu[:hide,left eye devil,left eye second color=pingu@black!80!pingu@white]}
\end{tikzpicture}}\\
\smash{\raisebox{1cm}{\onslide<4->{\huge\color{pingu@white}We love that. Don't we.}}}
\end{frame}
\dmfoottrue
\fi

\subsection{Aufgabe 2}
{\taskenum
\begin{frame}{Aufgabe 2: Schleifen}
\task<2->{Erstellen Sie die Java Datei \T{Schleifen.java} und implementieren Sie die folgenden Teilaufgaben innerhalb der \T{main} Methode (sog. Programmeinstiegspunkt) dieser Datei. \begin{enumerate}
    \item Lesen Sie über die Kommandozeilenparameter eine Variable vom Typ \T{int} ein, die wir im Folgenden mit \T{n}
    bezeichnen. Implementieren Sie anschließend die folgenden Schleifen, deren Verhalten von \T{n} abhängen soll.
    \item Implementieren Sie eine \T{for}-Schleife, die alle ganzen Zahlen von \T{n} bis \T{1} durchläuft und diese ausgibt.\\
    \textup{Beispiel:} \T{n = 5} gibt \T{5 4 3 2 1} aus.
    \item Implementieren Sie eine \T{do-while-Schleife}, die alle ungeraden ganzen Zahlen von \T{1} bis einschließlich \T{n} ausgibt.\quad \textup{Beispiel:} \T{n = 14} gibt \T{1 3 5 7 9 11 13} aus und \T{n = 5} gibt \T{1 3 5} aus.
\end{enumerate}}
\end{frame}
}

\SetNextSectionText{Schleifen, Arrays, Methoden\\Abgabe: \DTMDate{2022-05-23}}
\section{Aussicht: Übungsblatt 4}
\begin{frame}{Ein kleiner Schwenk}
\end{frame}

\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep11pt
    % \item TODO: get bib to work here
    \item TODO: nächste Woche
\end{itemize}
\end{frame}
}

\outro{\vskip6mm\centering\begin{tikzpicture}[scale=1.85]
\end{tikzpicture}}


\iffull\end{document}\fi
