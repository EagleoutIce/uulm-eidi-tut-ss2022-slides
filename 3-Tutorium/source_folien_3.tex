\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{Crossover Zahnbehandlungen}
\subtitle{Wurzelziehen Drei}
\date{KW 20}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{3}

\iffull\begin{document}
\titleframe

\TopicOverview{3}
\fi

\iffull{\SummaryFrame
\def\k{\textcolor{gray}{\(\rightarrow\)}}
\def\K{\textcolor{gray}{\(\longrightarrow\)}}
\def\a{\textcolor{codeouthl}{a}}
\def\b{\textcolor{codeouthl}{b}}
\setbeamerfont{description item}{shape=\itshape,series=\mdseries,size=\footnotesize}
\setbeamerfont{description body}{size=\footnotesize}
\setbeamerfont{itemize/enumerate subbody}{size=\footnotesize}
\begin{frame}[fragile,c]{Kurzwiederholung}
    \begin{itemize}[<+(1)->]
        \itemsep9.25pt
        \item Algorithmen können wir auf diverse Eigenschaften untersuchen: \begin{description}[Totale Korrektheit:]
            \item[Determiniertheit:] die gleiche Eingabe erzeugt immer die gleiche Ausgabe\hfill\tikz[align-half-base,every path/.append style={line cap=round},gray]{\node[circle,scale=.4,fill] (a) at (0,0) {}; \node[circle,scale=.4,fill] (b) at (.7,0) {}; \pgfonlayer{background}\draw[codeouthl](a) to[bend left=30.5] (b); \draw[codeouthl](a) to[bend right=30.5] (b); \draw[codeouthl](a) to[bend left=10] (b); \draw[codeouthl](a) to[bend right=10] (b); \endpgfonlayer\node[scale=.85,circle,fill=white,opacity=.3,text opacity=1,inner sep=0pt] at(current bounding box.center) {?};}
            \item[Determinismus:] bei gleicher Eingabe folgt stets die gleiche Schrittfolge \info{\textcolor{gray}{~\(\Rightarrow\)~Determiniert}}\hfill\tikz[align-half-base,every path/.append style={line cap=round},gray]{\node[circle,scale=.4,fill] (a) at (0,0) {}; \node[circle,scale=.4,fill] (b) at (.7,0) {}; \pgfonlayer{background}\draw[codeouthl](a) to[bend left=30.5] (b); \draw[codeouthl](a) to[bend right=30.5] (b); \draw[gray](a) to[bend left=10] (b); \draw[codeouthl](a) to[bend right=10] (b);\endpgfonlayer}
            \item[Totale Korrektheit:] Terminiert und partiell korrekt \info{\(\text{Terminiert} \implies \text{gewünschte Ausgabe}\)}
        \end{description}
        \item Manche von Javas primitiven Datentypen können implizit konvertiert werden \begin{itemize}
            \item \bjava{byte}~\k~\bjava{short}~\k~\bjava{int}~\k~\bjava{long}~\k~\bjava{double}~~und~~\bjava{char}~\k~\bjava{int}
        \end{itemize}
        \item Javas Präzedenzregeln geben an, wie Operatoren implizit geklammert werden \begin{itemize}
            \item \textcolor{codeouthl}{(stark)}~~~\T{\a++}~\K~\T{!\a}, \T{++\a}~\K~\T{\a\,/\,\b}, \T{\a\,*\,\b}~\K~\T{\a\,+\,\b}, \T{\a\,-\,\b}~\K~\T{\a\,==\,\b}~\K~\T{\a\,\&\&\,\b}~\K~\T{\a\,|\!|\,\b}~~~\textcolor{codeouthl}{(schwach)}%\smallskip
            \item Bei Ganzzahldivisionen werden Nachkommastelle abgeschnitten \info{\bjava{5/2} ergibt \bjava{2}}
            \item Bei unterschiedlichen Typen (\bjava{5.0/2}) wird der \say{kleinere} implizit \say{angehoben} (\bjava{5.0/2.0})
            \item \bjava{byte} oder \bjava{short} werden dabei immer mindestens zu \bjava{int} \info{\say{promoted}/widening, \link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html\#jls-5.6}{JLS17~$5.6$}}
        \end{itemize}
        % für Ganzzahlen (\bjava{byte}, \bjava{short}, \bjava{int}, \bjava{long}), Fließkommazahlen (\bjava{float}, \bjava{double}), Zeichen (\bjava{char}) und Wahrheitswerte (\bjava{boolean})
%        \begin{itemize}
% TODO:            \item Variablen dekl, init, zws
%        \end{itemize}
        \item Wenn verschachtelte Schleifen voneinander abhängen, hilft Gauß \info{\raisebox{1.5pt}{\(\scriptstyle\sum_{i = \text{1}}^N i\;{}={} \frac{N \cdot (N + \text{1})}{\text{2}}\)}}% TODO: Schleifen die voneinander abhängen
% \item TODO: Kommandozeilenparameter
    \end{itemize}
    \onslide<1->
\end{frame}

\begin{frame}[c]{Zum Warmwerden}
\colorlet{tskcolor}{btdm@primary!20!black!50!white}%
\colorlet{tskcolorA}{btdm@primary}%
\colorlet{tskcolorB}{btdm@primary}%
\begin{aufgabe}{Ich bin der Klammeraffen Typ}
    \small\onslide<2->{Drücken Sie im Folgenden die Präzedenzregeln \textit{explizit} durch Klammern aus, so dass die unten stehenden Ausdrücke auch ohne Präzedenzregeln in der gleichen Reihenfolge ausgeführt werden.} \onslide<3->{Geben Sie weiter den Typ des gesamten Ausdrucks an (\bjava{int i}, \bjava{short a} und \bjava{float f}).} \onslide<4->{Werten Sie die Ausdrücke \textit{nicht} aus.}
\begin{enumerate}
    \itemsep8pt
    \item<5-> \bjava{i + 3 * s++ + (-2 - 4)}
    \item<6-> \bjava{true && 3 > 4d || 2 - f != 5}
\end{enumerate}
\onslide<1->
\end{aufgabe}
\end{frame}

\def\NOl{}
\def\NOr{}
\newcommand<>\b[2]{{\onslide#3{$\mathtt{\color{gray}\csname #2l\endcsname(}$}}#1{\onslide#3{$\mathtt{\color{gray}\csname #2r\endcsname)}$}}}
% there is somewhat of a problem when nesting braces
% after some tries, this boxout strat seems to cut it
\newcommand<>\Tunderbrace[2]{\setbox0=\hbox{#1}$\only#3{\expandafter\underbrace}{\copy0}_{\onslide#3{#2}}$}
\newcommand<>\u[2]{\Tunderbrace#3{#1}{\smash{\clap{\solGet{keywordB}{\scriptsize\HStrut#2}}}}}
\newcommand<>\Toverbrace[2]{\setbox0=\hbox{#1}$\only#3{\expandafter\overbrace}{\copy0}^{\onslide#3{#2}}$}
\newcommand<>\o[2]{\Toverbrace#3{\text{#1}}{\clap{\text{\solGet{keywordB}{\scriptsize\HStrut#2}}}}}
\begin{frame}[t]{Klammeraffenfreude}
\begin{enumerate}
    \itemsep14pt
    \item<2-> Wir klammern\strut\only<11->{~und erhalten den Typ \bjava{int}}:\smallskip
%{\tracingall
\begin{center}
    \T{\u<7->{i}{int} + \o<10->{\b<3->{\u<9->{\b<4->{\u<7->{\snum{3}}{int} * \b<5->{\o<8->{\u<7->{s}{short}++}{short}}{NO}}{big}}{int} + \u<9->{(\b<6->{\o<8->{-\u<7->{\snum{2}}{int}}{int}}{NO} - \u<7->{\snum{4}}{int})}{int}}{Big}}{int}}
\end{center}
%}
    \item<12-> Wir klammern \strut erneut\only<18->{~und erhalten den Typ \bjava{boolean}}:\smallskip
\begin{center}% spacing around 4d fixing brace font bug
    \T{\u<17->{\b<13->{\u<15->{true}{boolean} \&\& \o<16->{\b<14->{\u<15->{\snum{3}}{int} > \u<15->{\,\snum{4}d\,}{double}}{NO}}{boolean}}{big}}{boolean} || \u<17->{\b<13->{\o<16->{\b<14->{\u<15->{\snum{2}}{int} - \u<15->{f}{float}}{NO}}{float} != \u<15->{\snum{5}}{int}}{big}}{boolean}}
\end{center}
\end{enumerate}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<19->{\node[T,below left,yshift=-1.4cm,text width=8cm,scale=.75] at(current page.north east) {Interaktiv kann dies in der \link{https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm}{JShell} ausprobiert werden. Definiert einfach eine Methode wie \T{void give(Object o) { System.out.println(o.getClass());}}. Dann gibt z.B.~\T{give(3 + 2d);} den Typ des Ausdrucks aus.};}
\end{tikzpicture}
\end{frame}
}\fi

\SetNextSectionText[.55\linewidth]{My volition shrinks from the painful task of recalling my humiliation; yet, like a second Prometheus, I will endure this and worse, if by any means I may arouse in the interiors of Plane and Solid Humanity a spirit of rebellion against the Conceit which would limit our Dimensions to Two or Three or any number short of Infinity.\\---~Edwin A. Abbott~\cite{abbott1987flatland}}
\section{Präsenzaufgabe}
\subsection{The simple solution}
\begin{frame}[c]{Präsenzaufgabe}
\begin{aufgabe}{Von doppelten Methoden}
    \small\onslide<2->{Mehrdimensionale Arrays, also solche Arrays, bei denen die Elemente selbst wiederum Arrays sein können, können wir als Matrizen interpretieren, beispielsweise ist \bjava{array[1][3]} das Element der zweiten Zeile in der vierten Spalte.} \onslide<3->{Legen Sie eine Java Datei namens \T{PositiveEintraege.java} an und implementieren Sie folgende Teilaufgaben innerhalb dieser Datei \info{oder bearbeiten Sie die Aufgabe auf einem Blatt Papier}.}
\begin{enumerate}
    \itemsep-2pt
    \item<4-> Initialisieren Sie ein zweidimensionales Array mit \(3 \times 3\) Elementen vom Typ \bjava{double} mit gültigen Werten in der \bjava{main}-Methode.
    \item<5-> Implementieren Sie eine Methode \bjava{public static int anzahlPositive}\allowbreak\bjava{(double[][] matrix)}, die die Anzahl der positiven Eintrage (\(> 0\)) bestimmt und zurückgibt. Für ungültige Matrizen soll die Methode \bjava{-1.0} zurückgeben.
    \item<6->[\color{gray}3.] \color{gray}Testen Sie die Implementierung aus b) mit ihrem Array aus a).
\end{enumerate}
\onslide<1->
\end{aufgabe}
\end{frame}

\begin{frame}[c,fragile]{An Array a day}
\begin{itemize}
    \item<2-> Wir basteln uns eine Klasse und Initialisieren froh umher.
\end{itemize}
\DoAnimations
\begin{plainjava}
$3->$public class PositiveEintraege {
$4->$    public static void main(String[] args) {
$5->$        double[][] mat = {
$6->$              { -1.0, :ws:21.0, :ws:3.0 }, $7->\text{\tikzmarknode{r1}{\T{\HStrut}}}$
$6->$              $6->\text{\tikzmarknode{@1}{\sbasic{\HStrut\{ \snum{~1.0}, ~\snum{42.0},~-\snum{3.0} \}}}}$, $8->\text{\tikzmarknode{r2}{\T{\HStrut}}}$
$6->$              { :ws:1.0, -84.0, :ws:3.0 }
$5->$       };
$4->$     }
$3->$}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<7->{
        \node[T,right,yshift=1pt] at(r1.east) {\T{mat[0]}~\(\to\) \T{\{-1.0, 21.0, 3.0\}}};
    }
    \onslide<8->{
        \hlcode[.5pt]{@1}{@K1}
        \node at(@1) {\sbasic{\HStrut\{ \snum{~1.0}, ~\snum{42.0}, -\snum{3.0} \}}};
        \node[T,right,outer xsep=0pt,inner sep=0pt] (@r) at(r2.east) {\sbasic{\normalsize\HStrut}\T{mat[1]}};
        \node[T,right,outer xsep=0pt,inner sep=0pt] at (@r.east) {\sbasic{\normalsize\HStrut}\T{[2]}~\(\to\) \T{-3.0}};
        \pgfonlayer{background}
            \onslide<8->{\hlcode[.5pt]{@r}{@K2}}
        \endpgfonlayer
    }
\end{tikzpicture}
\end{frame}

{\MakeThePinguExplainIt[text width=5.75cm,yshift=-5mm]{cap=!hide,cup=!hide,construction helmet=btdm@primary!60!btdm@background}{Was heißt \say{ungültig?} Das werden wir voerst zurückstellen!}
\begin{frame}[c,fragile]{Hey guy's, i did some methods}
\task<2->{Implementieren Sie eine Methode \T{anzahlPositive(double[][])}, die die Anzahl der positiven Eintrage (\(> 0\)) bestimmt und zurückgibt. Für \only<3->{\expandafter\textbf}{ungültige} Matrizen soll die Methode \T{-1.0} zurückgeben.}
\DoAnimations\SetupLstHl
\begin{plainjava}
$5->$public class PositiveEintraege {
$5->$    |ihl|public static void main(String[] args) { $6->$:ldots:$5->$ }|ihl|
$7->$    public static int anzahlPositive(double[][] matrix) {
$8->$        int anzahl = 0;
$9->$        for(int row = 0; row < matrix.length; row++) {
$10->$            for(int col = 0; col < matrix[row].length; col++) {
$11->$                if(matrix[row][col] > 0)  anzahl = anzahl + 1;
$10->$            }
$9->$        }
$12->$        return anzahl;
$7->$   }
$5->$}$1->$
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<4->{\node[left=-4mm,xshift=4mm,scale=.8,yshift=\btdmfootheight] at(current page.-29) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
}

\iffull
{\AddonFrame
\begin{frame}{Complex Guardians}
\begin{itemize}[<+(1)->]
    \itemsep11pt
    \item Arrays sind in Java \emph{komplexe} Datentypen \info{vs. Javas primitiver Datentypen}
    % \item Solche sind Referenzdatentypen \info{dazu später mehr!}
    \item Neben einem \say{gültigen} Wert, können diese auch den Wert \bjava{null} haben \begin{itemize}
        \item Mit \bjava{double[][] matrix = null;} liefert \bjava{matrix[1]} eine \bjava{NullPointerException}
        \item Prüfen können wir dies beispielsweise mit \bjava{matrix == null}
    \end{itemize}
    \item Allgemein sollte nie \bjava{null} übergeben oder zurückgegeben werden
    \item Neben \bjava{null}, könnte man auch noch weitere Dinge abprüfen \begin{itemize}
        \item Gibt es überhaupt eine Zeile \bjava{matrix.length == 0}?
        \item Gibt es überhaupt eine Spalte \bjava{matrix[row].length == 0}?
        \item Und viele mehr\ldots\ In jedem Fall sollte man diese mit einem Kommentar absichern
    \end{itemize}
    \item Mit komplexen Datentypen werden wir später noch viel Freude haben!
\end{itemize}
\end{frame}
}\fi

\begin{frame}[c,fragile]{Die Suche nach der positiven Anzahl}
\DoAnimations\lstfs{10}
\begin{plainjava}
$2->$public static int anzahlPositive(double[][] matrix) {
$4->$    if (matrix == null || matrix.length == 0) {
$5->$        System.out.println("Matrix ungültig!");
$6->$        return -1;
$4->$    }

$3->$    int anzahl = 0;
$3->$    for(int row = 0; row < matrix.length; row++) {
$3->$        for(int col = 0; col < matrix[row].length; col++) {
$3->$            if (matrix[row][col] > 0)
$3->$                anzahl = anzahl + 1;
$3->$        }
$3->$    }
$3->$    return anzahl;
$2->$}
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{Testen des Algorithmus}
\DoAnimations\SetupLstHl
\begin{itemize}[<+(1)->]
    \item Wir kehren in die \bjava{main}-Methode zurück:
\begin{plainjava}
$3->$|ihl|public class PositiveEintraege {|ihl|
$5->$    public static void main(String[] args) {
$6->$        double[][] mat = {{-1, 21, 3}, {1, 42, -3}, {1, -84, 3}};
$7->$        int anzahl = anzahlPositive(mat);
$8->$        System.out.println("erwartet: 6, erhalten: " + anzahl);
$5->$    }

$4->$    |ihl|public static int anzahlPositive(double[][] matrix) { :ldots: }|ihl|
$3->$|ihl|}|ihl|$1->$
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \only<9->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath PositiveEintraege.java}{PositiveEintraege.java}\;};}
\end{tikzpicture}
\end{frame}

\iffull{\AddonFrame
\begin{frame}[fragile]{Assertions und Tests}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Natürlich können wir einfach mit \bjava{if} prüfen ob wir das geforderte Ergebnis erhalten.
        \item Von Haus aus liefert Java \bjava{assert :lan:Bedingung:ran:} \begin{itemize}
            \item Dieses liefert einen Fehler, wenn die Bedingung nicht erfüllt ist:
\begin{plainjava}
int i = 0;
assert i > 0;  // :yields: Fehler!
\end{plainjava}
            \item Damit Assertions ausgeführt werden, benötigt java \bbash{-ea} als Argument: \bbash{java -ea Example}\infoblock{Das \T{-ea} steht hier für \say{enable assertions}}
            \item Assertions sollten immer nur zusätzlich zu Bedingungen verwendet werden.
        \end{itemize}
        \item Für \say{richtige} Unit-Tests gibt es Framework wie \link{https://junit.org/junit5/}{JUnit} \info{das obliegt weiteren Veranstaltungen}
        \item Allgemein ist Testen ein aufwändiger und wichtiger Teil der Programmierarbeit! % TODO: eventuelle Vertiefung anschneiden.
    \end{itemize}
\end{frame}
}
\fi

\subsection{The crazy Over-Engineer}
\iffull
{\AddonFrame
\setbox\pinguA=\hbox{\tikz\pingu[wings shock,eyes shock,body=pingu@black];}
\begin{frame}[fragile]{Wait. What was that?}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \itemsep9pt
    \item Wir haben eine eigene Methode erschaffen. \onslide<3->{Oder gar eine \setbox\pinguB=\hbox{Funktioooon}\copy\pinguB?}\onslide<4->{\llap{\smash{$\underset{\textit{\color{gray}pssssst}}{\raisebox{-.25\height}{\resizebox*!{6mm}{\copy\pinguA}}}$}\hskip.5\wd\pinguB\relax}}
    \item<5-> Wir rekapitulieren:\medskip\lstfs{10}
\begin{plainjava}
!*\onslide<5->*!|ihl|public class PositiveEintraege {|ihl|
!*\onslide<6->*!    !*\bnode{vismod}{\bnode{public}{\skA{public}} \bnode{static}{\skA{static}}}*! !*\bnode{int}{\skB{int}}*! !*\bnode{anzahlPositive}{\sbasic{anzahlPositive}}*!(!*\bnode{params}{\bnode{double-arr}{\skB{double}[][]} matrix}*!) { !*\Snode{@s}*!
!*\onslide<7->*!        |ihl|if (...) {|ihl|
!*\onslide<7->*!            |ihl|...|ihl|
!*\onslide<7->*!            !*\tikzmarknode{return1}{\skA{return}}*! |ihl|...;|ihl|
!*\onslide<7->*!        |ihl|}|ihl|
!*\onslide<7->*!
!*\onslide<7->*!        |ihl|...|ihl|
!*\onslide<7->*!        !*\tikzmarknode{return2}{\skA{return}}*! |ihl|...;|ihl|
!*\onslide<6->*!    } !*\Snode{@e}*!
!*\onslide<5->*!|ihl|}|ihl|
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    % \hlbcode[.5pt]{vismod}{@}
    \only<8->{\tfd{vismod}{Modifikatoren}}
    \only<9->{\tfd{int}{Rück-\\gabetyp}}
    \only<10->{\tfd{anzahlPositive}{Name}}
    \only<11->{\tfd{params}{Parameter}}
    \only<12->{
        \draw[decorate,decoration=brace] (@s.north east) to[edge node={node[right] {\scriptsize\itshape Body}}] (@e.south east-|@s.north east);
    }
    \only<13->{
        \path (params.north east) -- (params@.north west) coordinate[pos=.5] (@t);
        \draw[Kite-] ([yshift=1mm]@t) to[out=70,in=250] ++(1,.5) node[above=-1mm] {Eingabedaten};
    }
    \only<14->{
        \path (int.north east) -- (int@.north west) coordinate[pos=.5] (@i);
        \draw[-Kite] ([yshift=1mm]@i) to[out=70,in=250] ++(1,.5) node[above=-1mm] {Ausgabetyp};
    }
    \only<15->{
        \draw[-Kite] ([yshift=-1mm]return1.south) to[out=290,in=182] ++(1,-.25) node[right] (@out) {Ausgabedaten};
    }
    \only<16->{
        \draw[-Kite] ([yshift=1mm]return2.north) to[out=40,in=230] ([yshift=1mm]@out.south);
    }
    \only<17->{
        \node[below right,T,text width=5.65cm,xshift=-1cm,yshift=1.5mm] at (@out.south east) {Wenn an der Stelle des Rückgabetyps \textit{nicht} das Keyword \T{void} steht, \textit{muss} (in Java und abseits Exceptions) jeder Ausführungspfad Ausgabedaten vom angegebenen Typ zurückliefern!};
    }
\end{tikzpicture}
\end{frame}
\begin{frame}[fragile]{Das ist nicht gut, bis ich es nicht fein-Schleif}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \item Werfen wir noch einmal einen Blick auf die Hauptschleife:
\begin{plainjava}
!*\onslide<3->*!for(int row = 0; row < matrix.length; row++) {
!*\onslide<4->*!    for(int col = 0; col < matrix[row].length; col++) {
!*\onslide<5->*!        if (matrix[row][col] > 0) |ihl|...|ihl|
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \item<6-> Über diverse Daten in Java \info{Arrays,~\ldots}, können wir \say{iterieren}
    \item<7-> Dafür bietet java ein wenig \textit{syntactic-sugar} mit \say{for-each}!
\end{itemize}
\end{frame}
\savebox\codebox{\SetupLstHl\begin{minipage}{12.5cm}
\begin{plainjava}^^J
for(int row = 0; row < matrix.length; row++) \{^^J
:ws::ws::ws::ws:for(int col = 0; col < matrix[row].length; col++) \{^^J
:ws::ws::ws::ws::ws::ws::ws::ws:if (matrix[row][col] > 0) |ihl|...|ihl|^^J
:ws::ws::ws::ws:\}^^J
\}^^J
\end{plainjava}
\end{minipage}}

\begin{frame}[fragile]{Zucker und weitere tolle Dinge}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \item \say{for-each} ist kein Keyword, sondern eine Alternative \bjava{for}-Schleife:
\begin{plainjava}
!*\onslide<3->*!for(double[] row : matrix) {
!*\onslide<4->*!    for(double cell : row) {
!*\onslide<5->*!        if (cell > 0) |ihl|...|ihl|
!*\onslide<4->*!    }
!*\onslide<3->*!}!*\onslide<1->*!
\end{plainjava}
    \item<7-> Ein Nachteil? Wir verlieren die Information, das wie-vielte Element das ist. \onslide<8->{\infoblock{Weiter können wir durch \T{cell} die Matrix nicht mehr verändern. Das kommt später.}}
    \item<9-> Dafür ist es meist (viel) kompakter!
\end{itemize}
\begin{tikzpicture}[remember picture,overlay]
\onslide<6->{\node[above left,yshift=\btdmfootheight,scale=.7] at(current page.south east) {\copy\codebox};}
\end{tikzpicture}
\end{frame}
}
\fi
% \begin{frame}
%     % TODO: System: Format
% \end{frame}

\SetNextSectionText{Kontrollstrukturen\\Abgabe: \DTMDate{2022-05-16}}
\section{Übungsblatt 3}
\subsection{Aufgabe 1}
\begin{frame}[fragile]{Aufgabe 1: Bedingte Anweisungen und Boolesche Ausdrücke}
    \lstfs{10}%
    \task<2->{Betrachten Sie den folgenden Java Code-Ausschnitt. Vereinfachen Sie die verschachtelten \T{if}/\T{else} Blöcke so, dass die korrekte Zuweisung der Variablen \T{z} \emph{ohne} Kontrollstrukturen (\T{if}, \T{else}, \T{switch}, \T{while}, \T{do-while}, \T{for}, ternärer Operator) in einer Zeile verarbeitet wird, d.h. direkt über eine Zuweisung mithilfe eines Booleschen Ausdrucks.
    Gehen Sie davon aus, dass die Variablen \T{x} und \T{y} vom Typ \T{int} und \T{z} vom Typ \T{boolean} sind und alle Variablen
    gültige Werte besitzen.}
\columns[onlytextwidth,c]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<3->*!if(x >= 0){!*\Snode{@a}*!
!*\onslide<3->*!    if(y <= 0) {!*\Snode{@b}*!
!*\onslide<3->*!        !*\tikzmarknode{1}{\sbasic{\HStrut z = \sliteral{true}}}*!;
!*\onslide<3->*!    } else {:ws::ws::ws:!*\Snode{@c}*!
!*\onslide<3->*!        if(y == 1) { !*\tikzmarknode{2}{\sbasic{\HStrut z = \sliteral{true}}}*!; }
!*\onslide<3->*!    }
!*\onslide<3->*!} else {
!*\onslide<3->*!    !*\tikzmarknode{3}{\sbasic{\HStrut z = \sliteral{false}}}*!;
!*\onslide<3->*!}
\end{plainjava}
\column{.5\linewidth}
\onslide<5->{\T{z} ist nur \bjava{true}, wenn}
\updateitemize{\;\textbullet}%
\begin{itemize}
    \item<7->[\textcolor{btdm@primary}{\textbullet}] \bjava{x >= 0 && y <= 0}
\end{itemize}
\onslide<9->{\textit{Oder:}}
\begin{itemize}
    \item<9->[\textcolor{gray}{\textbullet}] \bjava{x >= 0 && !(y <= 0) && y == 1}
\end{itemize}
\onslide<10->{Kombiniert kommen wir auf:}
\begin{plainjava}
!*\onslide<11->*!z = (x >= 0 && y <= 0) || (x >= 0 && !(y <= 0) && y == 1);
!*\onslide<1->*!
\end{plainjava}
% \onslide<12->{\textbf{Done}}~\onslide<13->{\ldots?}
\endcolumns
\begin{tikzpicture}[overlay,remember picture]
\onslide<4->{
    \hlcode{1}{@1}
    \node at (1) {\sbasic{\HStrut z = \sliteral{true}}};
    \hlcode{2}{@2}
    \node at (2) {\sbasic{\HStrut z = \sliteral{true}}};
    \hlcode{3}{@2}
    \node at (3) {\sbasic{\HStrut z = \sliteral{false}}};
}
\onslide<6->{
    \node[right,btdm@primary] at(@a) {\raisebox{1pt}{\textbullet}};
    \node[right,btdm@primary] at(@b) {\raisebox{1pt}{\textbullet}};
}
\onslide<8->{
    \node[right=4mm,gray] at(@b) {\raisebox{1pt}{\textbullet}};
    \node[above=-3mm,gray] at(@c) {\raisebox{1pt}{\textbullet}};
}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Ausdrücke vereinfachen}
\begin{itemize}[<+(1)->]
    \item Wir hatten einen recht langen Ausdruck:
\begin{plainjava}
!*\onslide<3->*!z = (x >= 0 && y <= 0) || (x >= 0 && !(y <= 0) && y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<4-> Zunächst ist \bjava{!(y <= 0)} redundant, wenn \bjava{y == 1} gilt:
\begin{plainjava}
!*\onslide<5->*!z = (x >= 0 && y <= 0) || (x >= 0 && y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<6-> In beiden Fällen muss \bjava{x >= 0} gelten:
\begin{plainjava}
!*\onslide<7->*!z = (x >= 0) && (y <= 0 || y == 1);!*\onslide<1->*!
\end{plainjava}
    \item<8-> Nun ist \bjava{y} ein \bjava{int}, zwischen \bjava{0} und \bjava{1} ist nichts:
\begin{plainjava}
!*\onslide<9->*!z = (x >= 0) && (y <= 1);!*\onslide<1->*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[above left, T,yshift=\btdmfootheight] at(current page.south east) {Welche dieser Klammern sind optional?};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Ein Mini-Kommentar über die Korrektheit}
\begin{itemize}
    \item<2-> Das hatte quasi jeder und die Mehrheit hat Recht!\medskip
\columns[onlytextwidth,c]
\column{.35\linewidth}
\begin{plainjava}
!*\onslide<3->*!if(x >= 0){
!*\onslide<3->*!    if(y <= 0) {
!*\onslide<3->*!        z = true;
!*\onslide<3->*!    } else {
!*\onslide<3->*!        if(y == 1) {
!*\onslide<3->*!            z = true;
!*\onslide<3->*!        }
!*\onslide<3->*!    }
!*\onslide<3->*!} else {
!*\onslide<3->*!    z = false;
!*\onslide<3->*!}
\end{plainjava}
\column{.65\linewidth}
\onslide<4->{Sei \(\text{\T{x}} \geq 0\) und \(\text{\T{y}} > 1\). Welchen Wert hat \T{z}?}
\begin{itemize}
    \item<5-> Na ja, den Alten!\SetupLstHl
\begin{plainjava}
!*\onslide<6->*!z = |ihl|x >= 0 &&|ihl| (|ihl|y <= 1|ihl| || z);
\end{plainjava}
    \item<7-> Das Problem? Was, wenn \T{z} davor nicht initialisiert wurde?
    \item<8-> Dann ist das ohne Kontrollstrukturen unmöglich
    \item<10-> Korrekt wäre: \textbf{die Aufgabe ist \info{mit EidI-Wissen} unmöglich}
\end{itemize}
\endcolumns
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<9->{\node[above left, T,yshift=\btdmfootheight] at(current page.south east) {Genau genommen kann man für eine spezifische Version und Programmstruktur\ldots};}
\end{tikzpicture}
\end{frame}
\iffull
\begin{frame}[c]{}
\centering\only<2->{\global\dmfootfalse}
\begin{tikzpicture}[overlay,remember picture]
\onslide<2->{
    \fill[pingu@black] (current page.south east) rectangle (current page.north west);
}
\end{tikzpicture}
\scalebox{3}{\begin{tikzpicture}
    \only<3->{\pingu[:hide,left eye devil,left eye second color=pingu@black!80!pingu@white]}
\end{tikzpicture}}\\
\smash{\raisebox{1cm}{\onslide<4->{\huge\color{pingu@white}We love that. Don't we.}}}
\end{frame}
\dmfoottrue
\fi

\subsection{Aufgabe 2}
{\taskenum
\begin{frame}{Aufgabe 2: Schleifen}
\task<2->{Erstellen Sie die Java Datei \T{Schleifen.java} und implementieren Sie die folgenden Teilaufgaben innerhalb der \T{main} Methode (sog. Programmeinstiegspunkt) dieser Datei. \begin{enumerate}
    \item Lesen Sie über die Kommandozeilenparameter eine Variable vom Typ \T{int} ein, die wir im Folgenden mit \T{n}
    bezeichnen. Implementieren Sie anschließend die folgenden Schleifen, deren Verhalten von \T{n} abhängen soll.
    \item Implementieren Sie eine \T{for}-Schleife, die alle ganzen Zahlen von \T{n} bis \T{1} durchläuft und diese ausgibt.\\
    \textup{Beispiel:} \T{n = 5} gibt \T{5 4 3 2 1} aus.
    \item Implementieren Sie eine \T{do-while-Schleife}, die alle ungeraden ganzen Zahlen von \T{1} bis einschließlich \T{n} ausgibt.\quad \textup{Beispiel:} \T{n = 14} gibt \T{1 3 5 7 9 11 13} aus und \T{n = 5} gibt \T{1 3 5} aus.
\end{enumerate}}
\end{frame}

\begin{frame}[fragile]{Making Loops}
\begin{itemize}
    \item<2-> Wir haben dies bereits letzte Woche analysiert, deswegen hier ein wenig schneller.\smallskip
\end{itemize}\lstfs{9}
\begin{plainjava}[lineskip=3pt]
!*\onslide<3->*!int n = Integer.parseInt(args[0]);

!*\onslide<4->*!for (int i = n; i >= 1; i--) {
!*\onslide<5->*!    System.out.println(i); // oder System.out.print(...)
!*\onslide<4->*!}

!*\onslide<10->*!if(n >= 1) {
!*\onslide<6->*!    int j = 1;
!*\onslide<7->*!    do {
!*\onslide<9->*!        if (j % 2 == 1) // ungerade
!*\onslide<9->*!            System.out.println(j);
!*\onslide<8->*!        j = j + 1;
!*\onslide<7->*!    } while (j <= n);
!*\onslide<10->*!}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \only<11->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath Schleifen.java}{Schleifen.java}\;};}
\end{tikzpicture}
\end{frame}
}

\subsection{Aufgabe 3}
{\taskenum
% linenumbers leading zero
\def\NlSty#1{{\tiny\ifnum#1<10 0\fi#1:\space}}
\SetKwIF{If}{ElseIf}{Else}{falls}{:\quad}{}{sonst:}{}
\SetKwFor{While}{solange}{:}{}
\DontPrintSemicolon\LinesNotNumbered\SetAlgoNoEnd\SetAlgoNoLine
\begin{frame}[fragile]{Aufgabe 3: Algorithmen in Java implementieren}
\task<2->{In dieser Aufgabe sollen Sie einen vorgegebenen Algorithmus in ein identisches Java Programm umwandeln. Achten Sie insbesondere auf eine passende Auswahl der Datentypen der Variablen und die Art der Schleife. Legen Sie
dazu eine Java Datei namens \T{Quersumme.java} an und implementieren Sie den folgenden Algorithmus in der \T{main} Methode.\medskip\par}
\columns[onlytextwidth,c]
\column{.5\linewidth}
\task{\begin{algorithm}[H]
\PreCode
    \onslide<3->{\KwSty{Eingabe:} Ganze Zahl $\rnode{zahl}{zahl}$}\;
\StartCode
\onslide<4->{\nl\If{$zahl<0$}{
\nl    Gebe \say{Eingabe ungültig!} aus\;
\nl    \KwSty{beende Algorithmus vorzeitig}\;
}}
\onslide<5->{\nl Setze \(\rnode{quersumme}{quersumme} = 0\)\;
\nl Setze \(\rnode{divRest}{divRest} = 0\)\;}
\onslide<6->{\nl\While{$zahl > 0$} {
\nl    $divRest = zahl~\%~10$\;
\nl    $quersumme = quersumme + divRest$\;
\nl    $zahl = \text{\rnode{ganzzahligAbrunden}{ganzzahligAbrunden}}(zahl~/~10)$\;
}}
\onslide<7->{\nl Gebe $quersumme$ aus\;
\nl\KwSty{ende}}
\end{algorithm}}
\column{.5\linewidth}
\begin{itemize}
    \itemsep6.5pt
    \item<8-> Zunächst das Grundgerüst
    \item<10-> Doch welche Datentypen?
    \item<13-> Hier genügt \bjava{int} für alles.
    \item<14-> Abrunden? \onslide<16->{\bjava{int} is 'nuff}\medskip
\end{itemize}\vfill\lstfs{9}
\begin{plainjava}
!*\onslide<9->*!public static void main(String[] args) {
!*\onslide<12->*!    int !*\onslide<9->*!zahl = !*\onslide<12->*!Integer.parseInt!*\onslide<9->*!(args[0]);
!*\onslide<9->*!}
\end{plainjava}
\endcolumns
\begin{tikzpicture}[overlay,remember picture]
    \onslide<11->{\hlbcodeframe[0pt]{zahl}{@z}
    \hlbcodeframe[0pt]{quersumme}{@q}
    \hlbcodeframe[0pt]{divRest}{@d}}
    \onslide<15->{\hlbcodeframe[0pt]{ganzzahligAbrunden}{@a}}
\end{tikzpicture}
\end{frame}
\def\KN#1{\llap{\scriptsize\sffamily\color{gray}\ifnum#1<10 0\fi#1:~}}
\begin{frame}[fragile]{Eine Implementation übernehmen}
\begin{itemize}
    \item<2-> Abseits der Datentypentscheidung ist die Java-Syntax das größte Hindernis:\lstfs{10}
\begin{plainjava}
!*\onslide<4->*!int zahl = Integer.parseInt(args[0]);
!*\onslide<5->*!!*\KN1*!if (zahl < 0) {
!*\onslide<6->*!!*\KN2*!    System.!*\tikzmarknode{out}{out}*!.println("Eingabe ungültig!");
!*\onslide<7->*!!*\KN3*!    return;
!*\onslide<5->*!}

!*\onslide<8->*!!*\KN4*!int quersumme = !*\tikzmarknode{z1}{\snum{0}}*!;
!*\onslide<9->*!!*\KN5*!int divRest = 0;!*\Snode{z2}*!
!*\onslide<10->*!!*\KN6*!while (zahl > 0) {
!*\onslide<11->*!!*\KN7*!    divRest = zahl % 10;
!*\onslide<12->*!!*\KN8*!    quersumme = quersumme + divRest;
!*\onslide<13->*!!*\KN9*!    zahl = zahl / 10;!*\Snode{round}*!
!*\onslide<10->*!}
!*\onslide<14->*!!*\KN{10}*!System.out.println(quersumme);!*\onslide<1->*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
\onslide<3->{\node[above left,yshift=\btdmfootheight+.65cm,text width=7.85cm,scale=.48] at(current page.south east) {\begin{algorithm}[H]
\PreCode
    \KwSty{Eingabe:} Ganze Zahl $\rnode{zahl}{zahl}$\;
\StartCode
\nl\If{$zahl<0$}{
\nl    Gebe \say{Eingabe ungültig!} aus\;
\nl    \KwSty{beende Algorithmus vorzeitig}\;
}
\nl Setze \(\rnode{quersumme}{quersumme} = 0\)\;
\nl Setze \(\rnode{divRest}{divRest} = 0\)\;
\nl\While{$zahl > 0$} {
\nl    $divRest = zahl~\%~10$\;
\nl    $quersumme = quersumme + divRest$\;
\nl    $zahl = \text{\rnode{ganzzahligAbrunden}{ganzzahligAbrunden}}(zahl~/~10)$\;
}
\nl Gebe $quersumme$ aus\;
\nl\KwSty{ende}
\end{algorithm}};}
\onslide<15->{\draw[Kite-,T] (out.300) to[out=300,in=160] ++(1,-.35) node[right,T] {Alternativ auch \T{System.err.println}};}
\onslide<16->{\draw[Kite-,T] ([above right=.5mm]z1.40) to[out=40,in=190] ++(1,.35) node[right,T] {Initialisierung notwendig? Ja, wegen \say{08}};}
\onslide<17->{\node[right,T] at(z2) {Initialisierung notwendig? Nein, da \say{07} überschreibt};}
\onslide<18->{\node[right,T] at(round) {Ganzzahldivision schneidet Nachkommastellen ab};}
\only<19->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath Quersumme.java}{Quersumme.java}\;};}
\end{tikzpicture}
\end{frame}
}
\iffull{\AddonFrame
\begin{frame}{Ein paar Kommentare}
\begin{itemize}[<+(1)->]
    \itemsep10pt
    \item Je nach Pseudocode-\say{Stil} und Problem ist die Implementation in Java problematisch. \begin{itemize}
        \itemsep8pt
        \item Manchmal hat eine unsaubere Übernahme von Algorithmen katastrophale Folgen\infoblock{mal was sehr Java-aktuelles: \link{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21449}{CVE}, \link{https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/}{blog}, \link{https://www.youtube.com/watch?v=502iGDxuiRk}{{\faYoutubePlay} Computerphile}. Auch wenn hier von C++ portiert wurde.}
        \item Ein formale Analyse bringt wenig, bei einer problematischen Implementation
    \end{itemize}
    \item Mit weiteren Konzepte werden wir Java weiter erkunden.\bigskip

    \item Funktioniert Javas \say{\bjava{\%}} wie das mathematische Modulo?\par
    \onslide<+(1)->{Nicht ganz, einfach mal mit negativen, sowie Fließkommazahlen spielen (\link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html\#jls-15.17.3}{JLS17~$15.17.3$})}
\end{itemize}
\end{frame}
}\fi

\subsection{Aufgabe 4}
\begin{frame}{Aufgabe 4: Iterative Wurzelberechnung}
\task<2->{In dieser Aufgabe sollen Sie einen Algorithmus der als Berechnungsvorschrift gegeben ist implementieren. Im Gegensatz zu Aufgabe~3 ist der Algorithmus also nicht vollständig entwickelt sondern nur in der einfachsten Form angegeben. Das Heron-Verfahren ist ein numerisches Verfahren zur Approximation der \(k\)-ten (\(k \in \N\), \(k > 1\)) Wurzel einer Zahl \(\sqrt{x} \in \R\), \(x > 0\), d.h. wir suchen \(y = \sqrt[k]{x}\).} \task<3->{Wir beginnen mit dem Startwert \begin{equation*}
    y_0 = x
\end{equation*}
und fahren für \(n \geq 1\) nach der folgenden Iterationsvorschrift fort: \begin{equation*}
    y_{n + 1} = \frac{(k - 1)y_n^k + x}{k \cdot y_n^{k - 1}}
\end{equation*}
wobei \(y_n\) die Approximation nach \(n\) Berechnungsschritten sei. Da einige Wurzelzahlen (z.B.~\(\sqrt{2}\)) nur näherungsweise
dargestellt werden können, brechen wir ab, wenn \(\abs{y_{n+1} - y_n} < 10^{-8}\) erfüllt ist.}\par
\task<4->{Erstellen Sie eine Java Datei namens \T{Heron.java} und implementieren Sie dieses Verfahren wie oben beschrieben. Lesen Sie die Werte für \(k\) und \(x\) über die Kommandozeilenparameter ein.}
\end{frame}

\begin{frame}[fragile]{Iterative Berechnung}
\SetupLstHl
\begin{plainjava}[lineskip=1.5pt]
!*\onslide<2->*!public static void main(String[] args) {
!*\onslide<4->*!    double x = Double.parseDouble(args[0]);
!*\onslide<4->*!    int k = Integer.parseInt(args[1]);

!*\onslide<5->*!    if (x <= 0 || k <= 1) {
!*\onslide<6->*!        System.err.println("Eingaben ungültig!");
!*\onslide<7->*!        return;
!*\onslide<5->*!    }

!*\onslide<9->*!    double y = x;
!*\onslide<13->*!    |ihl|...|ihl|
!*\onslide<2->*!}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<3->{\node[below left,yshift=-1.5cm,T] (@) at(current page.north east) {Eingabe: \(k \in \N\), \(k > 1\) und \(x \in \R\), \(x > 0\)~~~};}
    % \node[below right,yshift=1mm,T] (@) at(@.south west) {Ausgabe: \(y =\sqrt[k]{x}\)};
    \onslide<8->{\node[below right,T] (@) at(@.south west) {Mit \(y_0 = x\)\only<10->{, \(y_{n + 1} = \frac{(k - 1) y_n^k + x}{k \cdot y_n^{k - 1}}\)}};}
    \onslide<11->{\node[below right,yshift=2mm,T] (@) at(@.south west) {Abbruch wenn \(\abs{y_{n + 1} - y_n} < 10^{-8}\)};}
    \onslide<12->{\node[below right,yshift=1mm,align=left,T] (@) at(@.south west) {Da wir für die Abbruchbedingung ein\\\(y_{n + 1}\) benötigen, eignet sich \T{do}-\T{while}};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{Iterative Berechnung}
\SetupLstHl
\begin{plainjava}[lineskip=2pt]
!*\onslide<1->*!public static void main(String[] args) {
!*\onslide<2->*!    |ihl|double x; int k; ...|ihl|
!*\onslide<2->*!    double y = x;

!*\onslide<3->*!    double oldy;
!*\onslide<4->*!    do {
!*\onslide<5->*!        oldY = y;
!*\onslide<6->*!        y = ((k-1) * Math.pow(y, k) + x) / (k * Math.pow(y, k-1));
!*\onslide<4->*!    } while (Math.abs(oldY - y) > 1!*\snum{E-}*!8);

!*\onslide<7->*!    System.out.println(y);
!*\onslide<1->*!}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \node[below left,yshift=-1.5cm,T] (@) at(current page.north east) {Eingabe: \(k \in \N\), \(k > 1\) und \(x \in \R\), \(x > 0\)~~~};
    % \node[below right,yshift=1mm,T] (@) at(@.south west) {Ausgabe: \(y =\sqrt[k]{x}\)};
    \node[below right,T] (@) at(@.south west) {Mit \(y_0 = x\), \(y_{n + 1} = \frac{(k - 1) y_n^k + x}{k \cdot y_n^{k - 1}}\)};
    \node[below right,yshift=2mm,T] (@) at(@.south west) {Abbruch wenn \(\abs{y_{n + 1} - y_n} < 10^{-8}\)};
    \node[below right,yshift=1mm,align=left,T] (@) at(@.south west) {Da wir für die Abbruchbedingung ein\\\(y_{n + 1}\) benötigen, eignet sich \T{do}-\T{while}};
\end{tikzpicture}
\end{frame}

\iffull
{\AddonFrame
\begin{frame}[fragile]{Vorbedingungen, Nachbedingungen und Ausgaben}
    \begin{itemize}[<+(1)->]
        \itemsep14pt
        \item Jeder (Unter-)Algorithmus wird Vor- und Nachbedingungen haben \begin{itemize}
            \item Große Teile werden bereits vom Typsystem abgedeckt
            \item Dennoch lohnt es sich \textit{immer}, über die Bedingungen nachzudenken
            \item Oftmals gibt es eine Menge abzuwägen
            \item Ein (cooles) dies verinnerlichendes Konzept ist Design by contract~\cite{meyer1986dbc,meyer1992applying}
        \end{itemize}
        \item Ausgaben können in Java auch mit \T{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/PrintStream.html\#printf(java.lang.String,java.lang.Object...)}{printf}}/\T{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/PrintStream.html\#format(java.lang.String,java.lang.Object...)}{format}} formatiert werden \begin{itemize}
            \item Hier gibt es eine eigene \link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Formatter.html\#syntax}{Formatter-Syntax}
            \item Formatierungshilfen natürlich auch in vielen anderen Sprachen (auch in komfortabler)
            \item Beispielsweise:
\begin{plainjava}
!*\onslide<+(1)->*!System.out.printf("Die %d-te Wurzel von !*\sliteral{\skB{\%.3f}}*! ist !*\sliteral{\skB{\%.3f}}*!\n", k, x, y);
\end{plainjava}
            \item Hier besteht auch Unterstützung für Zeiten! \info{\link{https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/StringSubstitutor.html}{String-Interpolation} kann aber mehr}
        \end{itemize}
    \end{itemize}
\end{frame}
}\fi

\SetNextSectionText{Schleifen, Arrays, Methoden\\Abgabe: \DTMDate{2022-05-23}}
\section{Aussicht: Übungsblatt 4}
\subsection{Aufgabe 1}
% \begin{frame}{Heap und Stack}
% Heap und Stack
% \end{frame}
{
\makeatletter
\newcommand*\md{\@ifstar{\@md}{\@md{0}}}% with star we can set handout state
\def\@md#1#2{\only<#2|handout:#1>{\llap{\color{btdm@primary}\faAngleRight~}}}
\newcommand*\mb[2][0]{\only<#2|handout:#1>{\rlap{\smash{\raisebox{-.66\baselineskip}{\color{btdm@primary}\faAngleUp}}}}}
\newcommand*\mh[2][0]{\only<#2|handout:#1>{\;\color{btdm@primary}\faAngleLeft}}
\newcommand*\mdl[2][0]{\only<#2|handout:#1>{\llap{\smash{\raisebox{-.5\baselineskip}{\tikz{\fill[btdm@primary,rounded corners=1pt] (0,-.65mm) rectangle ++(2.15\p@,\baselineskip+.65mm);}}~}}}}
% config takeover :D
\lstfs{10}\lstset{lineskip=5.5pt}
\colorlet{lgray}{lightgray!48!white}
\tikzset{ldesc/.style={gray,font=\sffamily\sbseries},lrel/.style={fill=white,rounded corners,minimum width=28mm,minimum height=7.5mm,align=center},lrel2/.style={fill=white,rounded corners,minimum width=28mm,minimum height=7.5mm*2,align=center},lsf/.style={fill=white,rounded corners,minimum width=28mm,minimum height=7.5mm*2,align=center, rectangle split, rectangle split parts=2}}
\begin{frame}[fragile,c]{Javas' Speicherverwaltung}
\centering\pause%
\begin{columns}[c,onlytextwidth]%
\begin{column}{.5\linewidth}%
\begin{plainjava}
!*\md4*!int x = 0;
!*\md5*!byte y = 12;
!*\md6*!String f = "Hallo Welt";
!*\md7*!char[] c = {2, 3, 4};
\end{plainjava}
\end{column} \begin{column}{.45\linewidth}
\centering\resizebox{.925\linewidth}!{\begin{tikzpicture}
    \onslide<3->{\fill[lgray,rounded corners] (0,0) rectangle ++(3,5.5);
    \fill[lgray,rounded corners] (3.5,0) rectangle ++(3,5.5);
    \node[ldesc,below] at (1.5,0) {Stack};
    \node[ldesc,below] at (5,0) {Heap};
    \node[lrel] at (1.5,5) {\ldots};
    \node[lrel] at (5,5) {\ldots};
    }
    \onslide<4->{\node[lrel] at (1.5,5-.85) {\bjava{int x = 0}};}
    \onslide<5->{\node[lrel] at (1.5,5-.85*2) {\bjava{byte y = 12}};}
    \onslide<6->{
        \node[lrel] (fg) at (1.5,5-.85*3) {\bjava{String f =\ }\raisebox{-1pt}\faGenderless};
        \node[lrel] (ft) at (5,5-.85-.425) {\bjava{\"Hallo Welt\"}};
        \draw[lightgray,very thick,-Kite]  (fg.east) to[out=0,in=180] (ft.west);
    }
    \onslide<7->{
        \node[lrel] (cg) at (1.5,5-.85*4) {\bjava{char[] c =\ }\raisebox{-1pt}\faGenderless};
        \node[lrel] (ct) at (5,5-.85*4) {\bjava{\{2, 3, 4\}}};
        \draw[lightgray,very thick,-Kite]  (cg.east) -- (ct.west);
    }
\end{tikzpicture}}
\end{column}
\end{columns}
\end{frame}

\savebox\pinguA{\tikz{\pingu[wings hug,eyes wink,hairs=paletteA!80!white,hair 3=paletteA]}}%
\savebox\pinguB{\tikz{\pingu[glasses round, left wing shock, eyes shock, right wing grab,tie=paletteB]}}%
\savebox\pinguC{\tikz{\pingu[wings wave,right eye wink,halo,small]}}%
\begin{frame}[fragile,c]{Stack-Frames}
\centering\pause
\begin{columns}[c,onlytextwidth]%
\begin{column}{.5\linewidth}%
\begin{plainjava}[escapeinside={!}{!}]
!\md{11}!void f(char c) {
!\md{12}!  int x = 4;
!\md*{5}{17}!  System.out.print(!\mb{13}!b(c+x)!\mh{16}!);!\mh{18}!
}
!\md*{2,4}{5,14}!String b(int n) {
!\md{6-7,15}!  return "" + (n % 9);
}

!\md{10}!f(!\mb4!b(42)!\rlap{\!\mb{8}}!.!\rlap{~~\thinspace\mb[3]{9}}!charAt(0));!\mh[6]{19}!
\end{plainjava}
\end{column} \begin{column}{.45\linewidth}
\centering\resizebox{.925\linewidth}!{\begin{tikzpicture}
    \onslide<3->{\fill[lgray,rounded corners] (0,0) rectangle ++(3,5.5);
    \node[ldesc,below] at (1.5,0) {Stack};
    \node[lrel] (d) at (1.5,5) {\ldots};
    \fill[lgray,rounded corners] (3.5,0) rectangle ++(3,5.5);
    \node[ldesc,below] at (5,0) {Heap};
    \node[lrel] (d2) at (5,5) {\ldots};}
    \onslide<5-7|handout:2>{\node[lsf,below=1mm] (s) at(d.south) {%
        \T{b}
        \nodepart{second}
        \bjava{int n = 42}%
    };
    \draw[ultra thick,lgray] (s.text split west) -- (s.text split east);
    }
    \onslide<8-9|handout:3>{%
        \node[lrel,below=1mm] (br) at (d.south) {\bjava{<ret-b> =\ }\raisebox{-1pt}\faGenderless};
        \node[lrel,below=8mm] (br2) at (d2.south) {\bjava{\"6\"}};
        \draw[lightgray,very thick,-Kite]  (br.east) to[out=0,in=180] (br2.west);
    }
    \onslide<10-|handout:4->{
        \node[lrel,below=8mm] (br2) at (d2.south) {\bjava[stringstyle={\color{gray}}]{\"6\"}};
    }
    \onslide<9|handout:3>{%
        \node[lsf,below=1mm] (ca) at (br.south) {\resizebox{25.4mm}!{\textit{\color{gray}\bjava{String::charAt}}}\nodepart{second} \scriptsize\textit{omitted}};
        \draw[ultra thick,lgray] (ca.text split west) -- (ca.text split east);
        \draw[lightgray,very thick,-Kite]  ([yshift=-3.5mm]ca.east) to[out=0,in=180] (br2.west);
    }
    \onslide<10|handout:0>{%
        \node[lrel,below=1mm] (rca) at (d.south) {\resizebox{25.4mm}!{\bjava{<ret-cA> = '6'}}};
    }
    \onslide<11|handout:0>{%
        \node[lsf,below=1mm] (fs) at (d.south) {%
            \T{f}
            \nodepart{second}
            \bjava{char c = '6'}%
        };
        \draw[ultra thick,lgray] (fs.text split west) -- (fs.text split east);
    }
    \onslide<12-18|handout:4-5>{%
        \node[lsf,below=1mm] (fs) at (d.south) {%
            \T{f}
            \nodepart{second}
            \bjava{char c = '6'}\\
            \bjava{int x = 4}%
        };
        \draw[ultra thick,lgray] (fs.text split west) -- (fs.text split east);
    }
    \onslide<14-15|handout:4>{%
        \node[lsf,below=1mm] (bs) at (fs.south) {%
            \T{b}
            \nodepart{second}
            \bjava{char n = 58}
        };
        \draw[ultra thick,lgray] (bs.text split west) -- (bs.text split east);
        \node[above=1mm,scale=.65] (pingu2) at (5,0) {\usebox\pinguA};
        \node[above=2mm,lrel,draw=gray,minimum width=0mm,minimum height=0mm] at(pingu2.south) {\bjava{'6' = 54}};
    }
    \onslide<16|handout:0>{%
        \node[lrel,below=1mm] (rbs) at (fs.south) {\resizebox{25.4mm}!{\bjava{<ret-b> =\ }\raisebox{-1pt}\faGenderless}};
        \node[lrel,below=11mm] (br3) at (br2.south) {\bjava{\"4\"}};
        \draw[lightgray,very thick,-Kite]  (rbs.east) to[out=-15,in=165] (br3.west);
    }
    \onslide<17|handout:5>{\node[lrel,below=11mm] (br3) at (br2.south) {\bjava{\"4\"}};}
    \onslide<18-|handout:6->{%
        \node[lrel,below=11mm] (br3) at (br2.south) {\bjava[stringstyle={\color{gray}}]{\"4\"}};
    }
    \onslide<17|handout:5>{%
        \node[lsf,below=1mm] (print) at (fs.south) {\resizebox{25.4mm}!{\textit{\color{gray}\bjava{PrintStream::print}}}\nodepart{second} \scriptsize\textit{omitted}};
        \draw[ultra thick,lgray] (print.text split west) -- (print.text split east);
        \draw[lightgray,very thick,-Kite]  ([yshift=-2.5mm]print.east) to[out=-15,in=165] (br3.west);
    }
    \onslide<19-|handout:6->{%
        \node[above=1mm,scale=.65] (pingu3) at (1.5,0) {\usebox\pinguC};
        % tiny is still too fat :C
        \node[above=1mm,lrel,draw=gray,text width=1/.6*25.3mm,minimum height=0mm,font=\sffamily\small,scale=.6] at(pingu3.north) {Die grauen Zeichenketten auf dem Heap können bereits vom Garbage-Collector entfernt worden sein!};
    }
\end{tikzpicture}}%
\vspace*{-1.25em}%
\end{column}
\end{columns}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<7-|handout:2->{%
        \node[below left=.25cm,yshift=.7cm,scale=.6] (pingu) at (current page.north east) {\rotatebox[origin=c]{180}{\usebox\pinguB}};
        \node[left,scale=.6,text width=6.75cm,align=center,yshift=-.33cm,pingu@white] at (pingu.west) {Wir werden Rückgabemechanismen sträflich vereinfachen!};
    }
\end{tikzpicture}%
\end{frame}
% TODO: Epsiode Links
}

\begin{frame}{Ein paar Kommentare}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Referenzdatentypen werden wir noch einige Male begegnen
        \item Die Animationen hier entstammen meiner Präsentation über \link{https://github.com/EagleoutIce/Episode-Recursion}{Rekursion}.
        \item Allgemein gibt es aber ein paar Dinge festzuhalten: \begin{itemize}
            \itemsep1.5pt
            \item Heap und Stack haben erstmal nichts mit den gleichnamigen Datenstrukturen zu tun
            \item Dies Speichermodell hilft bei Lebenszyklen, \bjava{final}, \bjava{==},~\ldots
            \item Ich werde öfters auf Heap und Stack zurückgreifen
        \end{itemize}
        \item Referenzdaten sind \bjava{null}, wenn sie auf dem Stack liegen, aber auf kein Element \say{zeigen}.
        \item Wir sprechen bei Java von Referenzen, nicht von Zeigern!
    \end{itemize}
\end{frame}

\subsection{Aufgaben 2 \& 3}
\begin{frame}{Höhere Dimensionen und Methoden}
    \begin{itemize}[<+(1)->]
        \itemsep12pt
        \item Arrays von Arrays sind nichts besonderes~--- wenn man das versteht, sind sie zahm
        \item Hier hilft ein Blick auf die Präsenzaufgabe
        \item Wo wir eben noch keine Methoden hatten, kommen nun unzählige\begin{itemize}
            \item Unteralgorithmen sind omnipräsent
            \item Wir versuchen alle sinnvoll auslagerbaren Schritte auszulagern
            \item Dies verbessert auch die Lesbarkeit (\bjava{a + b} vs. \bjava{addVisualPadding(a, b)})
            \item Weiter erlaubt es dies, Unteralgorithmen wiederzuverwenden!
        \end{itemize}
        \item Probiert euch gerne aus und formuliert eure Annahmen!
    \end{itemize}
\end{frame}


\SetNextSectionText{There is no real ending. It's just the place where you stop the story.\\--- Frank Herbert~\IfBtdmDarkmode{}{\def\fancyulbackground{btdm@primary}}\link{http://www.sinanvural.com/seksek/inien/tvd/tvd2.htm}{online}}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep6.5pt
    % \item TODO: get bib to work here
    \item \textbf{Der nächste Donnerstag ist ein Feiertag!}
    \item Arrays sind komplexe Datentypen, die auf dem Heap verwaltet werden. \begin{itemize}
        \item Damit können sie \bjava{null} sein (keine Referenz auf den Heap)
        \item Übergeben wir ein Array einer Methode, wird die Referenz \info{Stack} kopiert \info{$\to$~selbes Array}
    \end{itemize}
    % \item Algorithmen verstehen und implementieren ist ein Grundpfeiler der praktischen Informatik
    \item Es gibt viele kleine Tricks und Kniffe, die man primär durch \info{selbst} ausprobieren lernt
    \item Eure Lösungen und Ansätze werden sich wahrscheinlich immer mehr unterscheiden\begin{itemize}
        \item Je mehr Mühe ihr euch gebt, desto ausführlicher das individuelle Feedback
        \item Formuliert gerne auch Fragen\textor Ideen\textor \ldots\quad und kommentiert fleißig
    \end{itemize}
\end{itemize}
\end{frame}
}

\outro{\vskip6mm\centering\only<2->{\global\dmfootfalse}\begin{tikzpicture}[overlay,remember picture]
    \onslide<2-4|handout:0>{
        \fill[pingu@black] (current page.south east) rectangle (current page.north west);
    }
    \onslide<5->{
        \fill[pingu@black!50!btdm@background] (current page.south east) rectangle (current page.north west);
    }
\end{tikzpicture}\begin{tikzpicture}[scale=1.85]
    \only<3|handout:0>{\pingu[:hide,left eye devil,left eye second color=pingu@black!80!pingu@white]}
    \only<4->{\pingu[devil-horns,left eye devil, right eye angry, devil wings,wings wave,feet simple]}
\end{tikzpicture}}


\iffull\end{document}\fi
