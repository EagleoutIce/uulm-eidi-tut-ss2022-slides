\makeatletter
\def\DoCustomTheme{\def\btdmtheme{%
\usetheme[libs,nofootfade,centerfoot]{dividing-lines}%
\RequirePackage{xcolor}\colorlet{codeouthl}{gray!45!white}\colorlet{btdm@primary}{green}\colorlet{btdm@background}{white}\colorlet{btdm@border@down}{codeouthl}\colorlet{btdm@text}{btdl@color@text}%
\let\highlight\hl
\let\hl\relax% work with soul
\def\IfBtdmDarkmode####1####2{####2}\relax
\def\setfootmarker####1{\relax}%
% overwrite nodefaultfont used by main style
\AtEndPreamble{\RequirePackage{AnonymousPro}}%
\def\ttdefault{AnonymousPro}%
}}
\@ifundefined{iffull}{\DoCustomTheme}{\iffull\DoCustomTheme\fi}
\InputIfFileExists{../data/global.src}\relax\relax
\iffull
\DefinePalette{Recap}{Hellblau,hellbläulich: RGB(21, 110, 130)}
{Hellblau,hellbläulich: RGB(21, 110, 130)}{Blau,bläulich: RGB(51, 93, 126)}{Grün,grünlich: RGB(21, 150, 90)}
\UsePalette{Recap}
\fancyulcolor{paletteA}
\let\sbseries\sbfamily
\SetColorProfile*{paletteA}{paletteC}{paletteD}
\def\PostTitlepage{\begin{tikzpicture}[@O]
   \node[above right,xshift=7.5mm,yshift=1.25cm,scale=.8] at(current page.south west) {\LoadOverview{1}{}{2}~~\LoadOverview{2}{}{3\,\&\,4}~~\LoadOverview{3}{}{5}~~\LoadOverview{4}{}{6}~~\LoadOverview{5}{}{7}};
\end{tikzpicture}}

\def\defaultitemizeblock{\faAngleRight}
\updateitemize{\paletteA{\defaultitemizeblock}}
\updateitemizesub{\textcolor{gray}{\faAngleRight}}

\newcounter{slidetasks}
\setcounter{slidetasks}{0}
\def\SidebarTask#1{\refstepcounter{slidetasks}\SidebarRaw{\Large\rotatebox{90}{\def\rmdefault{AlphaSlabOne-TLF}\color{paletteA!62!pingu@black!36!pingu@white}\rmfamily\selectfont Aufgabe \theslidetasks}\hfill\null}\pdfbookmark[4]{A\theslidetasks)~#1}{lecture@task@@id@\thepage}
\only<1>{\hypertarget{@#1}{\label{#1}}}}
\def\TaskRef#1{\hyperlink{@#1}{Aufgabe~\ref*{#1}}}
\def\SidebarSolution{\SidebarRaw{\Large\rotatebox{90}{\def\rmdefault{AlphaSlabOne-TLF}\color{paletteA!62!pingu@black!36!pingu@white}\rmfamily\selectfont Auflösung \theslidetasks}\hfill\null}}
\def\textsb#1{{\sbseries#1}}
\def\LargeSide{\begin{tikzpicture}[@O]
  \fill[paletteA] (current page.north west) rectangle ([xshift=4.2mm]current page.south west);
\end{tikzpicture}}
\def\ShortSide{\begin{tikzpicture}[@O]
  \fill[paletteA!62!pingu@black!36!pingu@white] (current page.north west) rectangle ([xshift=2.75mm]current page.south west);
\end{tikzpicture}}
\lstset{lineskip=2.25pt}% hack them one level
\def\rhead#1{\hfill\textcolor{shadeA}{\sbseries#1}}
\solsetmintedstyle{plain}
\makeatletter
\AtEndPreamble{\def\sol@lang@java@kwstyle{\color{gray}}}%
\newenvironment{lillyHighlight}[1][]
{\begingroup\tikzset{lilly@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\lilly@lsthighlight@box[lilly@Highlight@par]{\@tempboxa}\endgroup}

\newcommand*\@lillyLstHL[1][]{%
  \begin{lillyHighlight}[#1]\bgroup\aftergroup\lilly@lsthighlight@endenv%
}
\def\lilly@lsthighlight@endenv{\end{lillyHighlight}\egroup}

\newcommand*\lilly@lsthighlight@box[2][]{%
  \tikz[#1]{%
    \pgfpathrectangle{\pgfpoint\p@\z@}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west, outer sep=\z@,inner xsep=\p@, inner ysep=-1.105\p@, rounded corners=1.65\p@, minimum height=\ht\strutbox+\p@,#1]{\raisebox\p@{\strut}\strut\usebox{#2}};
  }%
}
\def\lstHLZWS{\@lillyLstHL[fill=gray!31,draw=gray!31]}
\lstdefinelanguage{xJava}{language=lJava, moredelim=**[is][{\lstHLZWS}]{|zws|}{|zws|}}
\fi

\iffull
% guard against makeuppercase
\def\titlecolorset{\color{lightgray!15!white}}
\title{\texorpdfstring{\setbox0=\hbox{Zwischen}\hskip\wd0\clap{\smash{\protect\titlecolorset\raisebox{-3.5pt}{\scalebox{1.33}{\faRepeat}}}}\llap{\box0}}{Zwischen}wiederholung}
\subtitle{Ein kleiner Blick zurück}
\date{KW 23}
\addbibresource{references.bib}
\else
\SetTutoriumNumber{Wdh}
\fi

\iffull\begin{document}
\fi

\iffull
{\btfootfalse
{\setbeamercolor{background canvas}{bg=paletteA}
\def\ImpT#1{\textit{\color{pingu@white}#1}}
\begin{frame}[c,plain]{~}
\vspace*{-1.5mm}\begin{layout-full}
\begin{center}
   \bfseries\color{paletteA!68!white}
      Dieses \ImpT{Recap} liefert \ImpT{keine Garantie auf Vollständigkeit}. Ich konzentriere mich bewusst auf einige wenige aber wichtige \ImpT{Kernthemen}, die in der Hinsicht~--- zumindest auf den Folien~--- auch leicht simplifiziert dargestellt sind.\bigskip\par
      \ImpT{Penguins will be happy!}\\Flo
\end{center}
\end{layout-full}
\end{frame}
}

\begin{frame}[c]{}
\def\g{\only<4->{\color{gray}}}%
\only<5-|handout:0>{\global\btfoottrue}%
\only<2|handout:0>{\vspace*{2.25em}\footnotesize%
I. Einführung\\
II. Aspekte der Algorithmenkonstruktion\\
III. Programmierung im Kleinen --- Namen und Dinge\\
IV. Programmierung im Kleinen --- Steuerung des Programmablaufs\\
V. Zeigervariable, Arrays und Iterationen\\
VI. Programmieren im Großen --- Strukturierter Entwurf und Unterprogramme\\
VII. Einführung in die objektorientierte Programmierung (OOP)\\
VIII. Rekursive Algorithmen\\
IX. Weiterführende Konzepte der objektorientierten Programmierung\\
X. Dynamische Datenstrukturen\\
XI. Algorithmen und Zeitkomplexität\\
XII. Suchen und Sortieren}%
\updateitemize{10.}%
\only<3->{\vspace*{2.25em}\begin{enumerate}

   \item<3-> \hyperlink{btdl@section.1}{Algorithmenkonstruktion}
   \item<3-> \hyperlink{btdl@section.2}{Programmkonstrukte (Namen \& Programmfluss)}
   \item<3-> \hyperlink{btdl@section.3}{Arrays und Iterationen}
   \item<3-> \hyperlink{btdl@section.4}{Unterprogramme}
   \item<3-> \hyperlink{btdl@section.5}{Objektorientierte Programmierung}\bigskip
   \item<3->[\g 6.] \g Rekursion
   \item<3->[\g 7.] \g Suchen und Sortieren
   \item<3->[\g 8.] \g Weiterführende Konzepte der OOP
   \item<3->[\g 9.] \g Dynamische Datenstrukturen
   \item<3->[\g 10.] \g Laufzeitkomplexität
\end{enumerate}}%
\end{frame}
}
\fi

\section{Algorithmen}

\subsection{Definition}
\begin{frame}[c]{Was \textit{ist} ein Algorithmus?}
   \begin{center}
      \onslide<2->{Eine eindeutige Handlungsvorschrift zur Lösung eines Problems}
   \end{center}\vfill
\begin{itemize}
      \itemsep8pt
      \item<3-> Schrittweise ausführ- und reproduzierbar.
      \item<4-> Endlich viele, wohldefinierte Elementaroperationen.
      \item<5-> Stoppt für jede Eingabe in endlich vielen Schritten.\bigskip
      \item<6->[\color{gray}\defaultitemizeblock] {\color{gray}\itshape Fordert gemeinsames Sprachverständnis.}
\end{itemize}
\end{frame}

{\def\>{~\hskip1em}
\SidebarTask{Terminate the Algorithm}
\begin{frame}[c]{Terminate the Algorithm}
\onslide<2->{Antworten Sie jeweils für A, B und C mit \say{Ja}, wenn die Verfahren Terminieren oder Widerlegen Sie kurz.}\vspace*{2.5em}
{\small\columns[t,onlytextwidth]
\column{.26\linewidth}
\onslide<3->{Given \(i \in \Z\) \\
   Set \(j \gets 0\) \\
   \textbf{while} \(i \neq 0\) \textbf{do}\\
   \> \(i \gets i - 1\)\\
   \> \(j \gets j + i\)\\
   \textbf{stop}\\
}
\column{.34\linewidth}
\onslide<4->{Given \(p = (x, y) \in \R^2\) \\
   \textbf{if} \(x > y\) \textbf{then}\\
   \> \(p = (y,x)\)\\
   \textbf{stop} \\
}
\column{.4\linewidth}
\onslide<5->{Given \(z = (z_1,\ldots, z_n)\), \(z_i \in \N\) \\
   Set \(j \gets 0\) \\
   \textbf{while} not (\(z_1 \leq \ldots \leq z_n\)) \textbf{do}\\
   \> shuffle \(z\) randomly\\
   \textbf{stop} \\
}
\endcolumns\medskip}
% flo, you can do that better :c
\columns[c,onlytextwidth]
\column{.26\linewidth}
\onslide<3->{\centerline{A}}
\column{.34\linewidth}
\onslide<4->{\centerline{B}}
\column{.4\linewidth}
\onslide<5->{\centerline{C}}
\endcolumns
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset

\SidebarSolution
\begin{frame}[c]{Yeah, Terminate the Algorithm!}
\onslide<2->{\columns[c,onlytextwidth]
\column{.06\linewidth}
A
\column{.35\linewidth}
\scriptsize
Given \(i \in \Z\) \\
      Set \(j \gets 0\) \\
      \textbf{while} \(i \neq 0\) \textbf{do}\\
      \> \(i \gets i - 1\)\\
      \> \(j \gets j + i\)\\
      \textbf{stop}\\
\column{.59\linewidth}
\onslide<3->{Terminiert nicht.} \onslide<4->{Betrachte \(i < 0\), Dekrement sorgt dafür, dass nie \(i = 0\).}
\endcolumns}\bigskip
\onslide<5->{\columns[c,onlytextwidth]
\column{.06\linewidth}
B
\column{.35\linewidth}
\scriptsize
Given \(p = (x, y) \in \R^2\) \\
   \textbf{if} \(x > y\) \textbf{then}\\
   \> \(p = (y,x)\)\\
   \textbf{stop} \\
\column{.59\linewidth}
\onslide<6->{Ja, terminiert.}
\endcolumns}\bigskip
\onslide<7->{\columns[c,onlytextwidth]
\column{.06\linewidth}
C
\column{.35\linewidth}
\scriptsize
Given \(z = (z_1,\ldots, z_n)\), \(z_i \in \N\) \\
   Set \(j \gets 0\) \\
   \textbf{while} not (\(z_1 \leq \ldots \leq z_n\)) \textbf{do}\\
   \> shuffle \(z\) randomly\\
   \textbf{stop} \\
\column{.59\linewidth}
\onslide<8->{Terminiert Nicht.} \onslide<9->{Betrachte \(z = (3, 1)\), \say{shuffle} kann stets \((3,1)\) liefern.}
\endcolumns}
\end{frame}
\SidebarReset
}

\subsection{Eigenschaften}
\begin{frame}{What can we say about an Algorithm?}
   \vfill
   \centerline{\onslide<2->{\Large\bfseries\only<3->{\color{gray}\sbseries Totale Korrektheit} }}
   \vfill
   \updateitemize{1.}% faker
   \begin{enumerate}
      \itemsep10pt
      \item<3-> {\sbseries Termination}\\
         Der Algorithmus endet nach endlich vielen Schritten für jede Eingabe.
      \item<4-> {\sbseries Partielle Korrektheit}\\
         Wenn der Algorithmus terminiert, ist er korrekt.
   \end{enumerate}
\end{frame}

\SidebarTask{Algorithmusanalyse}
\begin{frame}[fragile,c]{Algorithmusanalyse}
   \onslide<2->{Analysieren Sie den Algorithmus hinsichtlich seiner totalen Korrektheit im Bezug auf die Berechnung der Leonardo-\allowbreak Zahlen.
   Weisen Sie dafür alle notwendigen Eigenschaften nach oder liefern Sie geeignete Gegenbeispiele.}
   \lstfs{10}\vfill
\columns[c,onlytextwidth]
\column{.605\linewidth}
\begin{plainjava}
!*\onslide<4->*!public static long L(int n) {
!*\onslide<5->*!   if(n == 0 || n == 1) return 1;
!*\onslide<6->*!   int l1 = 1, l2 = 1;
!*\onslide<7->*!   for(int i = 0; i < n - 1; i++) {
!*\onslide<8->*!      int tmp = l1;
!*\onslide<9->*!      l1 = l2;
!*\onslide<10->*!      l2 = tmp + l2 + 1;
!*\onslide<7->*!   }
!*\onslide<11->*!   return l2;
!*\onslide<4->*!}!*\onslide<1->*!
\end{plainjava}
\column{.395\linewidth}
\onslide<3->{Die Leonardo-Zahlen sind für \(n \geq 0\) definiert:\smallskip\\
\(L(0) = 1,~L(1) = 1\)\\
\(L(n) = L(n - 1) + L(n - 2) + 1\)}
\endcolumns
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset


\SidebarSolution
\begin{frame}[fragile,c]{Algorithmusanalyse}
\begin{enumerate}
   \itemsep11pt
   \item<2-> Terminiertheit \begin{itemize}
      \item<4-> \T{n} ist konstant.
      \item<5-> Für \(n = 0\), bzw. \(n = 1\) trivial.
      \item<6-> Für \(n > 1\) wächst \(i\) streng monoton an und wird irgendwann \(i < n - 1\) verletzen.
   \end{itemize}
   \item<3-> Partielle Korrektheit
\end{enumerate}
\begin{tikzpicture}[overlay,remember picture]
   \node[below left,text width=7cm,scale=.675] at(current page.north east) {%
\begin{plainjava}
public static long L(int n) {
   if(n == 0 || n == 1) return 1;
   int l1 = 1, l2 = 1;
   for(int i = 0; i < n - 1; i++) {
      int tmp = l1; l1 = l2;
      l2 = tmp + l2 + 1;
   }
   return l2;
}
\end{plainjava}
};
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{Algorithmusanalyse}
\begin{enumerate}
   \itemsep11pt
   \item<1-> Terminiertheit
   \item<1-> Partielle Korrektheit \begin{itemize}
      \item<2-> Für \(n = 0\), bzw. \(n = 1\) per Definition.
      \item<3-> Für \(n > 1\) per vollständiger Induktion. \begin{description}[IH]
         \itemsep5pt
         \item<4->[IA] Für \(n = 2\). \onslide<5->{Mit \(i < 1\) haben wir einen Zyklus. Das Ergebnis:
            \(\T{l2} = 1 + 1 + 1 = 3 = L(2)\) und \(\T{l1} = 1 = L(1)\).\quad\textcolor{lightgray}{\faCheck}}
         \item<6->[IH] Für \(n \geq 0\) ist \(\T{l2}\) die \(n\)-te und \(\T{l1}\) die \(n-1\)-te Leonardo-Zahl.
         \item<7->[IS] Mit \(n \to n + 1\) wird durch \bjava{l1 = l2} nämlich nach der IH \onslide<8->{\(\T{l1} = L(n) = L(n + 1 - 1)\) und mit \bjava{l2 = tmp + l2 + 1} wird \(L(n + 1) = L(n + 1 - 1) + L(n + 2 - 1) + 1\).}
      \end{description}
   \end{itemize}
\end{enumerate}
\begin{tikzpicture}[overlay,remember picture]
   \node[below left,text width=7cm,scale=.675] at(current page.north east) {%
\begin{plainjava}
public static long L(int n) {
   if(n == 0 || n == 1) return 1;
   int l1 = 1, l2 = 1;
   for(int i = 0; i < n - 1; i++) {
      int tmp = l1; l1 = l2;
      l2 = tmp + l2 + 1;
   }
   return l2;
}
\end{plainjava}
};
\end{tikzpicture}
\end{frame}
\SidebarReset

\setbox\pinguA=\hbox{\tikz{\pingu[blush,eyes wink,bow tie,cane right,left wing wave]}}
\begin{frame}[c]{What can we say about an Algorithm?\rhead{II}}
\begin{layout-full}
\begin{center}
   \begin{tikzpicture}[align-half-base]
      \onslide<3->{\node[circle,fill=gray,scale=.8] (a) at(0,0) {};
         \node[left,gray] at(a.west) {in}; % label stuff
         \node[circle,fill=gray,scale=.8] (b) at(2,0) {};
         \node[right,gray] at(b.east) {out};
      }
      \onslide<4->{
         \foreach\ang in {25,15,5} {
            \draw[gray,-{Kite[scale=.65]},line cap=round] (a) to[bend left=\ang] (b);
            \draw[gray,-{Kite[scale=.65]},line cap=round] (a) to[bend right=\ang] (b);
         }
      }
      \onslide<2->{\node[below=6mm] (@) at(current bounding box.south) {Determiniertheit};}
      \pgfinterruptboundingbox
      \onslide<8->{\node[T,below] at(@.south) {Gleiche Eingabe~\(\to\) Gleiche Ausgabe};}
      \endpgfinterruptboundingbox
   \end{tikzpicture}\hskip1.5cm\clap{\onslide<10->{\smash{\raisebox{17.75pt}{$\Longleftarrow$}}}}\hskip1.5cm
   \begin{tikzpicture}[align-half-base]
      \onslide<6->{\node[circle,fill=gray,scale=.8] (a) at(0,0) {};
         \node[left,gray] at(a.west) {in}; % label stuff
         \node[circle,fill=gray,scale=.8] (b) at(2,0) {};
         \node[right,gray] at(b.east) {out};
      }
      \onslide<7->{
         \draw[gray,-{Kite[scale=.65]},line cap=round,] (a) to[bend left=15] (b);
         \foreach\ang in {25,15,5} {
            \path[gray,-{Kite[scale=.65]},line cap=round] (a) to[bend left=\ang] (b);
            \path[gray,-{Kite[scale=.65]},line cap=round] (a) to[bend right=\ang] (b);
         }
      }
      \onslide<5->{\node[below=6mm] (@) at(current bounding box.south) {Determinismus};}
      \pgfinterruptboundingbox
      \onslide<9->{\node[T,below] at(@.south) {Gleiche Eingabe~\(\to\) Gleiche Zustandsfolge};}
      \endpgfinterruptboundingbox
   \end{tikzpicture}
\end{center}
\end{layout-full}
\begin{tikzpicture}[@O]
   \node[above right,scale=.65] (@) at(current page.south west) {\copy\pinguA};
   \node[T,right,yshift=-6mm,xshift=2mm,align=left] at(@.north east) {Wer determiniert ist, möchte sein Ziel um jeden Preis erreichen\\auf \say{egal welcher Weg}.};
\end{tikzpicture}
\end{frame}


\SidebarTask{Ein Algorithmenentwurf}
\begin{frame}[c]{Ein Algorithmenentwurf}
\onslide<2->{Entwerfen Sie einen Algorithmus als Pseudocode, der einen Binärstring $b$ in die entsprechende Dezimalzahl $d$ umwandelt. Diese finden Sie folgendermaßen: \begin{equation*}
   d = \sum_{i = 1}^N b_i2^{N - i}
\end{equation*}
Dabei ist \(b_i\) der \(i\)-te Eintrag des Strings. Für \(b = \text{\T{1001}}\) gilt damit: \begin{equation*}
   \tikzmarknode{@1}{1 \cdot {\color{gray}2^{4 - 1}}} + \tikzmarknode{@2}{0 \cdot {\color{gray}2^{4 - 2}}} + \tikzmarknode{@3}{0 \cdot {\color{gray}2^{4 - 3}}} + \tikzmarknode{@4}{1 \cdot {\color{gray}2^{4 - 4}}} = 9
\end{equation*}\vspace*{-1mm}\par
Wobei hier \(N = 4\).}
\begin{tikzpicture}[@O]
   % macro? pffffh
   \onslide<2->{\draw[decoration=brace,decorate] ([yshift=-1mm]@1.south east) to[edge node={node[below=1mm] {8}}] ([yshift=-1mm]@1.south west);
   \draw[decoration=brace,decorate] ([yshift=-1mm]@2.south east) to[edge node={node[below=1mm] {0}}] ([yshift=-1mm]@2.south west);
   \draw[decoration=brace,decorate] ([yshift=-1mm]@3.south east) to[edge node={node[below=1mm] {0}}] ([yshift=-1mm]@3.south west);
   \draw[decoration=brace,decorate] ([yshift=-1mm]@4.south east) to[edge node={node[below=1mm] {1}}] ([yshift=-1mm]@4.south west);}
\end{tikzpicture}%
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset
\SidebarSolution
\setbox\pinguA=\hbox{\tikz{\pingu[headband=paletteA,headband upper angle=20,head band angle=20,head band knot,head band bands=false,right wing wave,body type=legacy,heart=codeouthl]}}
\begin{frame}[c]{Algorithmenübernahme}
\begin{tikzpicture}[@O]
   \onslide<2->{\node[below left=4mm] at(current page.north east) {\(\displaystyle d= \sum_{i = 1}^N b_i 2^{N - i}\)};}
\end{tikzpicture}
\SetKw{KwStep}{waddle size}
\begin{algorithm}[H]
\PreCode
    \onslide<3->{\KwIn{binary string \(b\)}}\medskip
\StartCode
    \onslide<4->{\(N \gets \text{length of }b\)\;}
    \onslide<5->{\(d \gets 0\)\;}
    \onslide<6->{\For{\(i \gets 1\) \KwTo~\KwSty{inclusive} \(N\) \tikzmarknode{@-main}{\KwStep} 1} {
       \onslide<8->{\(d \gets d + \tikzmarknode{@-b}{b_i} \cdot 2^{N - i}\)\;}
    }}
    \onslide<10->{\KwRet \(d\)\;}
\end{algorithm}
\begin{tikzpicture}[@O]
   % macro? pffffh
   \onslide<7->{\draw[decoration=brace,decorate,T] ([yshift=1mm]@-main.north west) to[edge node={node[above=1mm] {Schrittgröße!}}] ([yshift=1mm]@-main.north east);}
   \onslide<9->{\draw[T,-Kite] (@-b.south) to[bend right] ++(.2,-.4) node[below right,yshift=.7\baselineskip,align=left] {Ist hier schon durch\\die Aufgabe gegeben.};}
   \onslide<11->{\node[left=-5mm,scale=.7] (@) at(current page.east) {\copy\pinguA};
      \node[above left,yshift=-.75cm,xshift=.66cm,T]  at(@.north west) {\say{for all \(i \in \{1, \ldots, N\}\)\ldots}};
   }
\end{tikzpicture}
\end{frame}
\SidebarReset


\subsection{Algorithmus-Diskussion}
{\def\comm#1{\hfill\textcolor{gray}{\footnotesize#1}}
\begin{frame}[c]{Discussing an Algorithm}
\centering\begin{tikzpicture}
   \onslide<2->{\node (p) at (0,0) {\strut Problem};}
   \onslide<3->{\node (l) at (7,0) {\strut Lösung};}
   \onslide<4->{\draw[-Kite] (p) -- (l) node[pos=.5,fill=white] {\null~?~\null};}
\end{tikzpicture}
\vfill
\begin{itemize}
   \itemsep7.5pt
   \item<5-> Problemspezifikation\comm{Was meinen Sie mit \say{schnell}?}
   \item<6-> Problemabstraktion\comm{Was ist gegeben, was ist gesucht?}
   \item<7-> Algorithmenentwurf\comm{Wie kommen wir von gegeben zu gesucht?}
   \item<8-> Korrektheitsnachweis\comm{Löst unser Ansatz das Problem?}
   \item<9-> Aufwandsanalyse\comm{Wie verhält er sich?}
\end{itemize}
\end{frame}}


\SidebarTask{Eine Aufwandsanalyse}
\begin{frame}[c]{Eine Aufwandsanalyse}
\onslide<2->{Bestimmen Sie den worst-case Laufzeitaufwand des folgenden Verfahrens\textsuperscript{\,$\to$ \TaskRef{Ein Algorithmenentwurf}} in Elementaroperationen:}
\bigskip\par
\onslide<3->{\begin{algorithm}[H]
\PreCode
    \KwIn{binary string \(b\)}\medskip
\StartCode
    \(N \gets \text{length of }b\)\;
    \(d \gets 0\)\;
    \For{\(i \gets 1\) \KwTo~\KwSty{inclusive} \(N\) \tikzmarknode{@-main}{\KwStep} \(1\)} {
       \(d \gets d + \tikzmarknode{@-b}{b_i} \cdot 2^{N - i}\)\;
    }
    \KwRet \(d\)\;
\end{algorithm}}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset

\SidebarSolution
{\newcommand<>\ComplexityMarker[1]{\only#2{\rlap{\qquad\compl{#1}}}}
\def\compl#1{\text{\sbseries\itshape\paletteA{#1}}}
\begin{frame}[c]{Gimme this Aufwand-Thing}
\onslide<2->{\begin{algorithm}[H]
\PreCode
    {\only<3->{\color{codeouthl}}\KwIn{binary string \(b\)}}\medskip
\StartCode
    \(N \gets \text{length of }b\)\ComplexityMarker<4->{1}\;
    \(d \gets 0\)\ComplexityMarker<5->{1}\;
    \For(\ComplexityMarker<6->{\paletteD{n}}){\(i \gets 1\) \KwTo~\KwSty{inclusive} \(N\) \tikzmarknode{@-main}{\KwStep} \(1\)} {
       \(d \tikzmarknode{assign}{{}\gets{}} d \tikzmarknode{+}{{}+{}} b_i \tikzmarknode{dot}{{}\cdot{}} \tikzmarknode{exp-left}{\HStrut}2^{N \tikzmarknode{-}{\,-\,} i}\tikzmarknode{exp-right}{\HStrut}\)\ComplexityMarker<12->{5}\;
    }
    \KwRet \(d\)\ComplexityMarker<13->{1}\;
\end{algorithm}}
\bigskip
\onslide<14->{\(\compl{1}\,E + \compl{1}\,E + \compl{\paletteD{n}} \cdot (\compl{5}\,E) + \compl{1}\,E \onslide<15->{= (3 + 5 \cdot n)\,E\)}}
\begin{tikzpicture}[@O]
   \onslide<7->{\draw[T,-Kite] (-.south) to[bend right] ++(.5,-.2) node[right=-1mm,align=left] {\compl{\color{lightgray}1}};}
   \path(exp-left.south)--(exp-right.south) coordinate[pos=.5] (exp);
   \onslide<8->{
   \draw[decoration={brace,mirror},decorate] ([yshift=-.25mm]exp-left.south) -- ([yshift=-.25mm]exp-right.south);
   \draw[T,-Kite] ([yshift=-.75mm]exp.south) to[bend right] ++(.2,-.4) node[right=-.6mm,align=left] {\compl{\color{lightgray}1}};
   }
   \onslide<9->{\draw[T,-Kite] (dot.south) to[bend right] ++(.075,-.4) node[right=-.6mm,align=left] {\compl{\color{lightgray}1}};}
   \onslide<10->{\draw[T,-Kite] (+.south) to[bend right] ++(.2,-.4) node[right=-.6mm,align=left] {\compl{\color{lightgray}1}};}
   \onslide<11->{\draw[T,-Kite] (assign.south) to[bend right] ++(.2,-.4) node[right=-.6mm,align=left] {\compl{\color{lightgray}1}};}
\end{tikzpicture}
\end{frame}
\SidebarReset

\subsection{Recap}
\begin{frame}[c]{\paletteA{\sbfamily Kurzgesagt}\hfill Algorithmen}
\begin{itemize}[<+(1)->]
   \itemsep14pt
   \item Totale Korrektheit \begin{itemize}
      \item \textit{Terminiertheit:}\hfill Endliche Schritte für jede Eingabe
      \item \textit{Partielle Korrektheit:}\hfill Wenn terminiert, dann korrekt
   \end{itemize}
   \item Weitere Eigenschaften \begin{itemize}
      \item \textit{Determiniertheit:}\hfill Gleiche Eingabe~\(\to\) Gleiche Ausgabe
      \item \textit{Determinismus:}\hfill Gleiche Eingabe~\(\to\) Gleiche Zustandsfolge
   \end{itemize}
   \item Der Abstraktionsprozess kommt durch Übung
\end{itemize}
\LargeSide
\end{frame}


\section{Konstrukte}
\subsection{Datentypen}
\def\dt#1{{\large\bfseries\textcolor{paletteA!58!white}{\strut#1}}}
\begin{frame}[c]{Primitive Datentypen}
\centering\begin{layout-imageonly}
\begin{tikzpicture}[scale=2.65]
   \onslide<2->{\node[right] (boolean) at(0,0)             {\dt{boolean}};}
   \onslide<3->{\node[right] (byte) at(0,-1.66*1/2.65)     {\dt{byte}};}
   \onslide<3->{\node[right=6.5mm] (short) at(byte.east)   {\dt{short}};}
   \onslide<4->{\node[below=1.35cm] (char) at(short.south) {\dt{char}};}
   \onslide<3->{\node[right=6.5mm] (int) at(short.east)    {\dt{int}};}
   \onslide<3->{\node[right=6.5mm] (long) at(int.east)     {\dt{long}};}
   \onslide<3->{\node[right=6.5mm] (float) at(long.east)   {\dt{float}};}
   \onslide<3->{\node[right=6.5mm] (double) at(float.east) {\dt{double}};}

\begin{scope}[every path/.append style={draw,-Kite}]
\onslide<5->{\path (byte) -- (short);
\path (short) -- (int);
\path (int) -- (long);
\path (long) -- (float);
\path (float) -- (double);}
\onslide<6->{\path[rounded corners=2pt] (char) -| (int) coordinate[pos=.3] (join);
\node[below right,xshift=5mm,yshift=-1mm] (join-d) at (join) {UTF-16};
\path[gray] (join.east) to[bend right] (join-d.west);}
\onslide<7->{
   \node[gray,above] at (byte.north) {8};
   \node[gray,above] at (short.north) {16};
   \node[gray,above] at (int.north) {32};
   \node[gray,above] at (long.north) {64};
   \node[gray,above] at (float.north) {32};
   \node[gray,above] at (double.north) {64};
   \node[gray,above] at (char.north) {16};
}
\onslide<8->{\draw[decoration={brace,mirror,amplitude=3pt},decorate,-] ([yshift=1pt]float.south west) -- ([yshift=1pt]double.south east) node[pos=.5,below=4.5pt] {\sbfamily Rundungsproblem!};}
\onslide<9->{\draw[decoration={brace,mirror,amplitude=3pt},decorate,-] ([yshift=1pt]byte.south west) -- ([yshift=1pt]short.south east) node[pos=.5,below=4.5pt] {\sbfamily \(+\),~~\(/\),~~\ldots~~\(\longrightarrow\)~~\bjava{int}};}
\end{scope}
\end{tikzpicture}
\end{layout-imageonly}
\end{frame}

\def\ms#1{{\relax{#1}}}
\def\a{\color{codeouthl}a}
\def\b{\color{codeouthl}b}
\def\K#1{\text{\textbf{\color{paletteA}#1}}}
\begin{frame}[c]{Präzedenzregeln}
\def\to{\raisebox{1pt}{\;\tikz\draw[pingu@black!80!pingu@white,-{Kite[scale=1.05]},line cap=round,line width=.925pt] (0,0) -- (6mm,0);}}%
\begin{itemize}
   \item<2-> Eine Auswahl:
   \begin{alignat*}{4}
      \onslide<3->{\ms{\a\K{++},~~\a\K{-\,-}}}&\onslide<4->{\to~\ms{\K{!}\a,~~ \K{-}\a,~~ \K{++}\a,~~\K{-\,-}\a}}&&\onslide<5->{\to~\ms{\a~\K*~\b,~~\a~\K/~\b,~~\a~\K\%~\b}} \\
      &\onslide<6->{\to~\ms{\a~\K+~\b,~~\a~\K-~\b}}&& \onslide<7->{\to~\ms{\a~\K{==}~\b,~~\a~\K<~\b,~~\ldots}}\\
      & \onslide<8->{\to~\ms{\a~\K{\textasciicircum}~\b}}&&\onslide<9->{\to~\ms{\a~\K{\&\&}~\b}}\\
      & \onslide<10->{\to~\ms{\a~\K{||}~\b}}
      \onslide<1->
   \end{alignat*}
\end{itemize}
\end{frame}

\SidebarTask{Typbestimmung}
\begin{frame}{Typbestimmung}
\onslide<2->{\flushleft Bestimmen Sie für jeden der folgenden Java-Ausdrücke den Typ \textit{jedes Teilausdrucks}, sowie das Gesamtergebnis. Sie dürfen Rundungsprobleme der Sprache ignorieren:\vfill
\begin{itemize}
   \itemsep10pt
   \item \bjava{14 - 3D * 2 / 12}
   \item \bjava{(char) ((byte) 'a' + 3) + " Sonne"}
   \item \bjava{14 - 2 + (3 > 9 || true ^ false ? "Hallo" : "Welt")}
   \item \bjava{7/2 - 3 * (float) 2.5 + 2f}
\end{itemize}}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset

\SidebarSolution
\def\mj#1{\text{\bjava{#1}}}
\def\ob<#1>#2#3{\only<-\the\numexpr#1-1\relax|handout:0>{\mj{#2}}\only<#1->{\overbracket[.33pt]{\mj{#2}}^{\makebox[0pt]{\scriptsize\mj{#3}}}}}
\def\gub<#1>#2#3{\only<-\the\numexpr#1-1\relax|handout:0>{#2}\only<#1->{\underbracket[.33pt]{#2}_{\makebox[0pt]{\scriptsize\mj{#3}}}}}
\def\gob<#1>#2#3{\only<-\the\numexpr#1-1\relax|handout:0>{#2}\only<#1->{\overbracket[.33pt]{#2}^{\makebox[0pt]{\scriptsize\mj{#3}}}}}
\begin{frame}[c]{Typbestimmung\rhead{II}}
   \begin{itemize}
      \itemsep14pt
      \item<2-> \(\ob<3>{14}{int} \mj{-} \gub<5>{\gob<4>{\ob<3>{3D}{double} \mj{*} \ob<3>{2}{int}}{double} \mj{/} \ob<3>{12}{int}}{double} \only<6->{{}= \ob<6>{13.5}{double}}\)
      \item<7-> \(\gob<11>{(\mj{char})~\gub<10>{(\gub<9>{(\mj{byte}) \ob<8>{'a'}{char}}{byte} + \ob<8>{3}{int})}{int}}{char} + \ob<8>{\" Sonne\"}{String} \only<12->{{}=\ob<12>{\"d Sonne\"}{String}}\)
   \end{itemize}
\end{frame}

\begin{frame}[c]{Typbestimmung\rhead{III}}
   \begin{itemize}
      \itemsep14pt
      \item<2-> \(\gob<7>{\ob<3>{14}{int} \mj{-} \ob<3>{2}{int}}{int} \mj{+} \gob<6>{(\gub<5>{\gub<4>{\ob<3>{3}{int} \mj{>} \ob<3>{9}{int}}{boolean} \mj{||} \gub<4>{\ob<3>{true}{boolean} \mj{^} \ob<3>{false}{boolean}}{boolean}}{boolean} \mj{?} \ob<3>{\"Hallo\"}{String} \mj{:} \ob<3>{\"Welt\"}{String})}{String}\) \\[-6pt]
      \onslide<8->{\({}= \ob<8>{\"12Hallo\"}{String}\)}
      \item<9-> \(\gob<12>{\gub<11>{\ob<10>{7}{int}\mj{/}\ob<10>{2}{int}}{int} \mj{-} \gub<11>{\ob<10>{3}{int} \mj{*} \ob<10>{(float) 2.5}{float}}{float}}{float} \mj{+} \ob<10>{2f}{float} \only<13->{{}= \ob<13>{-2.5}{float}}\)
   \end{itemize}
\end{frame}
\SidebarReset

\subsection{Definitionen und Blöcke}
\begin{frame}[c]{Variablendefinition}
   \begin{description}[Initialisierung]
      \itemsep=12pt
      \item<2->[Deklaration] Es gibt etwas mit diesem Namen (und Typ):\\
         \onslide<3->{\bjava{int x;}\quad \bjava{char w;}}
      \item<4->[Zuweisung] Wertzuweisung, bzw. Ersetzung des Wertes:\\
         \onslide<5->{\bjava{x = 12; x = 9;}\quad \bjava{w = 'k';}}
      \item<6->[Initialisierung] \textit{Erste} Wertzuweisung zu einer Variable:\\
         \onslide<7->{\bjava{int x = 12;}\quad \bjava{char w; w = 'x';}}
   \end{description}\medskip
   \begin{center}
      \onslide<8->{\bjava{final} erzwingt, dass eine Variable nur Initialisiert und dann nicht erneut zugewiesen werden darf.}
   \end{center}
\end{frame}

\newsavebox\holdi
\savebox\holdi{\tikz\pingu[right wing grab, left wing wave,eyes angry,santa beard];}
\begin{frame}[c]{Standardwerte}
   \begin{itemize}[<+(1)->]
      \itemsep10pt
      \item Standardwerte für: \begin{itemize}
         \itemsep3pt
         \item Klassen-Variablen (\bjava{static})
         \item Instanz-Variablen
         \item Array-Komponenten (wie bei \bjava{new int[]})
      \end{itemize}
      \item Der Standardwert ist \say{Null}: \begin{itemize}
         \itemsep3pt
         \item \bjava{byte}, \bjava{short}, \bjava{int}, \bjava{long} $\longrightarrow$ \bjava{0}
         \item \bjava{float}, \bjava{double} $\longrightarrow$ \bjava{0.0}
         \item \bjava{char} $\longrightarrow$ \T{'}\!\!\bjava{\\u0000}\T{'} (\say{Unicodesymbol mit Wert \(0\)})
         \item \bjava{boolean} $\longrightarrow$ \bjava{false}
         \item Komplexe Datentypen $\longrightarrow$ \bjava{null}
      \end{itemize}
   \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<12->{\node[below left,yshift=.33cm,scale=.65] (d) at(current page.north east) {\rotatebox{180}{\usebox\holdi}};
   \node[left] at(d.west) {Explicit is betta!};}
\end{tikzpicture}
\end{frame}

\newcommand<>\lm[1][]{\only#2{#1\llap{\textcolor{paletteA!68!white}{\faCaretRight}~}}}
\makeatletter
\lhns@elemwidth3cm
\lhns@minborderheight3.25cm
\makeatother
\begin{frame}[c,fragile]{Blöcke}
   \begin{itemize}[<+(1)->]
      \itemsep10pt
      \item Methodenaufrufe erzeugen \say{Stack-Frames}
      \item Code-Blöcke arbeiten vergleichbar
      \item Beim Verlassen wird alles davon vom Stack geschmissen
   \end{itemize}
\begin{columns}[onlytextwidth,c]
\column{.5\linewidth}
\onslide<5->
\begin{plainjava}
!*\lm<6|handout:0>*!int x = 5;
{
!*\lm<7|handout:0>*!   double b = 12.5;
!*\lm<8>*!   x = x + (int) b;
}
!*\lm<9-|handout:0>*!int y = x;
\end{plainjava}
\column{.5\linewidth}
\onslide<5->{\downsize{.45\linewidth}{\begin{tikzpicture}[lhns@basestyle/.append style={execute at begin node=\strut,font=\ttfamily},lhns@blockstyle/.append style={draw=gray,thick}]
\begin{heap-n-stack}{}
\only<6->{\stack{x = \only<-7|handout:0>{5}\only<8-|handout:1>{17}}}
\only<7-8>{\stack{- Block -}
\stack{b = 12.5}}
\only<9-|handout:0>{\stack{y = 17}}
\renderstack
\end{heap-n-stack}
\end{tikzpicture}}}
\end{columns}
\end{frame}

\subsection{Überschatten}
\newsavebox\pingushadow
\savebox\pingushadow{\pingudefaults{wings grab}\begin{tikzpicture}
   \scope[xshift=2.95cm,yshift=.21cm,canvas is xz plane at y=-1,rotate=180,scale=1.165]
      \pingudefaultsappend{body=pingu@black,body front=pingu@black,feet color=pingu@black,bill color=pingu@black,eyes=none,wings=none}
      \pingu[@block/.style={fill=pingu@black!38!white}];% no feet part problems on shadow
      \pingu[:ghost glow,feet=none];
   \endscope
   \pingu[cup=pingu@green!76!paletteA,eyes wink];
   \scope[xshift=1.95cm,yshift=-.44cm,scale=.25]
      \pingu[:hide,feet=normal,feet color=pingu@yellow!66!pingu@black,feet front];
      \pingu[wings wave,eyes shiny,@block/.append style={fill=#1!66!pingu@black},heart=paletteA!68!white,hat=paletteA];% get feet behind but still above shadow
   \endscope
\end{tikzpicture}}
\begin{frame}[c,fragile]{Überschatten}
\vspace*{.885\baselineskip}\begin{itemize}[<+(1)->]
   \itemsep9pt
   \item<3-> Instanz-/Klassenvariable mit gleichem Be-\\
   zeichner wie lokale Variable.
   \item<4-> Der lokale Bezeichner überschattet den \say{globalen}.
   \item<5-> So kann auch der Typ verändert werden.
\end{itemize}\vspace*{-3.65\baselineskip}
\begin{layout-imageonly}
\begin{columns}[onlytextwidth,c]
\column{.65\linewidth}
\lstfs{9}\lstset{lineskip=3.25pt}\begin{uncoverenv}<6->\begin{plainjava}
class LetThereBeDarkness {
  static int happiness = 7;
  public static void main(String[] args) {
    System.out.println(happiness);
    String happiness = "Maunz";
    System.out.println(happiness);
  }
}
\end{plainjava}
\end{uncoverenv}
\column{.35\linewidth}
\begin{uncoverenv}<7-> Ausgabe:%
\begin{void*}
7
Maunz!*\onslide<1->*!
\end{void*}
\end{uncoverenv}
\end{columns}\vspace*{-2\baselineskip}
\end{layout-imageonly}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<2->{\node[below left=.33cm,scale=1] at(current page.north east) {\usebox\pingushadow};}
\end{tikzpicture}
\end{frame}

\SidebarTask{Was gibt das Programm aus?}
\begin{frame}[c,fragile]{Programmausgaben}
Geben Sie für die Zeilen \T{i}--\T{iv} je die erzeugte Ausgabe an und erklären Sie die Werte der beteiligten Variablen.
\lstfs{9}\begin{plainjava}
!*\onslide<2->*!public class Example {
!*\onslide<2->*!   public static int main;
!*\onslide<2->*!   public static String a = "Hallo";
!*\onslide<2->*!   public static void main(String[] args) {
!*\onslide<2->*!      int a = 7,  b = 15;
!*\onslide<2->*!      System.out.println(a + "; " + main); // i)
!*\onslide<2->*!      {
!*\onslide<2->*!         float main = 3 * b++;
!*\onslide<2->*!         Example.a += b;
!*\onslide<2->*!         System.out.println(b + "; " + main); // ii)
!*\onslide<2->*!      }
!*\onslide<2->*!      System.out.println(a + "; " + b + "; " + main); // iii)
!*\onslide<2->*!      System.out.println(Example.a + "; " + Example.main); // iv)
!*\onslide<2->*!   }
!*\onslide<2->*!}!*\onslide<1->*!
\end{plainjava}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset
\SidebarSolution
\def\Show<#1>#2;{\onslide<#1->{{\only<#1|handout:1>{\colorlet{@}{gray}}\path[@]#2;}}}
\def\ShowFull<#1>#2;{\onslide<#1-|handout:2>{{\only<#1>{\colorlet{@}{gray}}\path[@]#2;}}}
\tikzset{every tikzmarknode/.append style={outer sep=2.25pt}}
\begin{frame}[c,fragile]{Programmausgaben\rhead{II}}
\lstfs{9}\begin{plainjava}
public class !*\rlap{\tikzmarknode{Example}{\phantom{Example}}}*!Example {
   public static int !*\rlap{\!\tikzmarknode{main}{\phantom{main}}}*!main;
   public static String a!*\llap{\tikzmarknode{a}{\phantom{a}}}*! = "Hallo";
   public static void main(String[] args) {
      int !*\rlap{\tikzmarknode{a2}{\phantom{a}}}*!a = 7;
      int !*\rlap{\tikzmarknode{b}{\phantom{b}}}*!b = 15;
      System.out.println(!*\rlap{\tikzmarknode{ua}{\phantom{a}}}*!a + "; " + !*\rlap{\tikzmarknode{umain}{\phantom{main}}}*!main); // i)
      {
         float !*\rlap{\tikzmarknode{main2}{\phantom{main}}}*!main = 3 * !*\rlap{\tikzmarknode{ub}{\phantom{b}}}*!b++;
         !*\rlap{\tikzmarknode{uExample}{\phantom{Example}}}*!Example.!*\rlap{\tikzmarknode{ua2}{\phantom{a}}}*!a += !*\rlap{\tikzmarknode{ub2}{\phantom{b}}}*!b;
         System.out.println(!*\rlap{\tikzmarknode{ub3}{\phantom{b}}}*!b + "; " + !*\rlap{\tikzmarknode{umain2}{\phantom{main}}}*!main); // ii)
      }
      System.out.println(!*\rlap{\tikzmarknode{ua3}{\phantom{a}}}*!a + "; " + !*\rlap{\tikzmarknode{ub4}{\phantom{b}}}*!b + "; " + !*\rlap{\tikzmarknode{umain3}{\phantom{main}}}*!main); // iii)
      System.out.println(!*\rlap{\tikzmarknode{uExample2}{\phantom{Example}}}*!Example.!*\rlap{\tikzmarknode{ua4}{\phantom{a}}}*!a + "; " + !*\rlap{\tikzmarknode{uExample3}{\phantom{Example}}}*!Example.!*\rlap{\tikzmarknode{umain4}{\phantom{main}}}*!main); // iv)
   }
}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture,every path/.append style={draw,gray,-Kite}]
\colorlet{@}{lightgray!70!white}%
\Show<2> (ua.west) to[out=165,in=-60] (pic cs:a2);
\Show<3> (umain.north) to[bend right] (main.east);
\Show<4> (ub.north) to[out=140,in=290] (b.south);
\Show<5> (ua2.north) to[out=100,in=260] (a.south);
\Show<6> (ub2.north west) to[out=140,in=290] (b.south);
\Show<7> (ub3.north west) to[out=140,in=290] (b.south);
\Show<8> (umain2.north) to[out=170,in=-30] ([xshift=-2pt]main2.south east);

\ShowFull<9> (ua3.north) to[out=100,in=-30] ([xshift=-2pt]a2.east);
\ShowFull<9> (ub4.north) to[out=100,in=-30] ([xshift=-2pt]b.east);
\ShowFull<9> (umain3.north) to[out=100,in=-30] ([xshift=-2pt]main.east);

\ShowFull<10> (ua4.north) to[out=100,in=-30] ([xshift=-2pt]a.east);
\ShowFull<10> (umain4.north) to[out=100,in=-30] ([xshift=-2pt]main.east);
\end{tikzpicture}%
\end{frame}


\begin{frame}[c,fragile]{Programmausgaben\rhead{III}}
\vspace*{-\baselineskip}\begin{columns}[onlytextwidth,c]
\column{.6\linewidth}
\lstfs{4}\begin{plainjava}
public class Example {
   public static int main;
   public static String a = "Hallo";
   public static void main(String[] args) {
      int a = 7;
      int b = 15;
      !*\tikzmark{li}*!System.out.println(a + "; " + main);!*\tikzmark{ri}*! // i)
      {
         float main = 3 * b++;
         Example.a += b;
         !*\tikzmark{lii}*!System.out.println(b + "; " + main);!*\tikzmark{rii}*! // ii)
      }
      !*\tikzmark{liii}*!System.out.println(a + "; " + b + "; " + main);!*\tikzmark{riii}*! // iii)
      !*\tikzmark{liv}*!System.out.println(Example.a + "; " + Example.main);!*\tikzmark{riv}*! // iv)
   }
}
\end{plainjava}
\column{.4\linewidth}
\small\updateitemize{iii)}%
\begin{enumerate}
   \itemsep4.5pt
   \item<3->[i)] \bjava{7; 0}
   \item<5->[ii)] \bjava{16; 45.0}
   \item<7->[iii)] \bjava{7; 16; 0}
   \item<9->[iv)] \bjava{Hallo16; 0}
\end{enumerate}
\end{columns}
\vspace*{4mm}
{\scriptsize\begin{enumerate}
   \itemsep7pt
   \item<4->[i)] \textit{\bjava{a = 7}, da lokales \bjava{a} das globale \bjava{Example.a} überschattet. \bjava{main = 0} durch \bjava{Example.main}, da Deklaration mit default \say{\bjava{0}} initialisierte.}
   \item<6->[ii)] \textit{\bjava{b = 16}}, da lokal überschattet und durch \bjava{b++} in Initialisierung von lokalem \bjava{main}. \bjava{main = 45.0}, da \bjava{float} und Initialisierung \bjava{3 * 15} (Postinkrement).
   \item<8->[iii)] \textit{\bjava{a = 7} mit lokalem \bjava{a}, \bjava{b = 16} durch Postinkrement, \bjava{main = 0} da Scope von lokalem \bjava{main} zuende, globales \bjava{Example.main} nicht mehr überschattet.}
   \item<10->[iv)] \textit{\bjava{Example.a = "Hallo16"} durch Konkatenation \bjava{Example.a += 16}, \bjava{Example.main = 0} wie zuvor.}
\end{enumerate}}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<2->{\fill[paletteA,opacity=.13,rounded corners=1pt] ([yshift=-1pt,xshift=-1pt]pic cs:li) rectangle ([yshift=3.5pt,xshift=1pt]pic cs:ri);}
   \onslide<5->{\fill[paletteA,opacity=.13,rounded corners=1pt] ([yshift=-1pt,xshift=-1pt]pic cs:lii) rectangle ([yshift=3.5pt,xshift=1pt]pic cs:rii);}
   \onslide<7->{\fill[paletteA,opacity=.13,rounded corners=1pt] ([yshift=-1pt,xshift=-1pt]pic cs:liii) rectangle ([yshift=3.5pt,xshift=1pt]pic cs:riii);}
   \onslide<9->{\fill[paletteA,opacity=.13,rounded corners=1pt] ([yshift=-1pt,xshift=-1pt]pic cs:liv) rectangle ([yshift=3.5pt,xshift=1pt]pic cs:riv);}
\end{tikzpicture}%
\end{frame}
\SidebarReset

\subsection{Fallunterscheidungen}
\begin{frame}[c]{Fallunterscheidungen}
\begin{itemize}[<+(1)->]
   \itemsep12pt
   \item Wenn \say{X} dann \say{Y} sonst \say{Z}
\begin{center}
   \bjava{if(X) Y else Z}
\end{center}
   \item Der Sonst-Fall (\bjava{ else Z}) ist optional.
   \item Wir können \bjava{Y} und \bjava{Z} durch einen Code-Block aus mehreren Zeilen bestehen lassen.
   \item Wir können die Ausdrücke verschachteln.
\end{itemize}
\end{frame}

\begin{frame}[c]{Fallunterscheidungen\rhead{II}}
\begin{itemize}[<+(1)->]
   \itemsep12pt
   \item Es gibt eine ternäre Kurzform:
\begin{center}
   \bjava{X ? Y : Z}
\end{center}
   \item Der Sonst-Fall (\bjava{: Z}) ist \textsb{nicht} optional.
   \item \bjava{Y} und \bjava{Z} müssen zu einem Wert evaluieren.
   \item Wir können die Ausdrücke verschachteln.
   \item Anders als \bjava{if}-\bjava{else} ist der Ternäre-Operator kein Statement! Wir müssen ihn also eingebettet verwenden.
\end{itemize}
\end{frame}

\subsection{Recap}
{\def\mto{\ensuremath{\to}}
\def\dt#1{{\textcolor{paletteA!58!white}{\sbseries\strut#1}}}
\begin{frame}[c]{\paletteA{\sbfamily Kurzgesagt}\hfill Konstrukte}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item \textit{Implizit}:\hfill \dt{byte}~\mto~\dt{short}~\mto~\dt{int}~\mto~\dt{long}~\mto~\dt{float}~\mto~\dt{double}\\
   Zahlen von klein zu groß, sowie: \dt{char}~\mto~\dt{int}.
   \item \textit{Präzedenzregeln}:\\
   Post vor Prä, sonst wie Arithmetik \& Logik.
   \item \textit{Default-Werte}:\\
   Zahlen und Zeichen \bjava{0}, Boolean \bjava{false}, Rest \bjava{null}.
   \item \textit{Überschatten}:\quad Lokal über Global.
\end{itemize}
\LargeSide
\end{frame}
}

\section{Arrays \& Iteration}
\subsection{Arrays}
\begin{frame}{Arrays}
\begin{itemize}[<+(1)->]
   \itemsep16pt
   \item Sind komplexe Datentypen (\(\to\) Heap).
   \item Jeder Datentyp kann ein (eindimensionales) Array werden:
   \begin{center}
      \bjava{int[] = new int[12];}
   \end{center}
   \item Mehrdimensionale Arrays, sind Arrays von Arrays von\ldots
   \item Zugriff: \bjava{:lan:array:ran:[:lan:index:ran:]}\smallskip \begin{itemize}
   \itemsep2.5pt
   \item Liefert \bjava{:lan:index:ran:}-Element in \bjava{:lan:array:ran:}.
   \item Wenn Array von Array, ist \bjava{:lan:array:ran:[:lan:index:ran:]} wieder ein Array.
   \end{itemize}
\end{itemize}
\end{frame}

\subsection{Schleiflies}
\begin{frame}[fragile]{Schleifen}
   \vspace*{-.75\baselineskip}\begin{itemize}[<+(1)->]
      \itemsep5pt
      \item Drei Schleifenarten: \bjava{for}, \bjava{while}, \bjava{do}-\bjava{while}
      \item Sie sind alle gleichmächtig\vspace*{-7.125\baselineskip}
   \end{itemize}\lstfs{10}
\begin{layout-imageonly}
\columns[onlytextwidth,t]
\column{.43\linewidth}
\begin{uncoverenv}<4->
\begin{plainjava}
for(int i = 3; i < 8; i++) {
   // Miau
}
\end{plainjava}
\end{uncoverenv}
\column{.25\linewidth}
\begin{uncoverenv}<5->
\begin{plainjava}
int i = 3;
while(i < 8) {
   // Miau
   i += 1;
}
\end{plainjava}
\end{uncoverenv}
\column{.245\linewidth}
\begin{uncoverenv}<6->
\begin{plainjava}
int i = 3;
do {
   // Miau
   i += 1;
} while(i < 8);
\end{plainjava}
\end{uncoverenv}
\endcolumns
\columns[onlytextwidth,c]
   \column{.43\linewidth}
\onslide<7->{\itshape Anzahl bekannt}
\column{.25\linewidth}
\onslide<8->{\itshape Kein Maximum}
\column{.245\linewidth}
\onslide<9->{\itshape Mindestens 1}
\endcolumns
\vspace*{-6.4\baselineskip}
\end{layout-imageonly}
\begin{itemize}
   \itemsep5pt
   \item<10-> Bei \bjava{for} sind alle drei Blöcke optional.
   \item<11-> Bei \bjava{do}-\bjava{while} aufpassen: \begin{itemize}
      \item<12-> Semikolon!
      \item<13-> Wird es wirklich mindestens ein mal durchlaufen?
   \end{itemize}
\end{itemize}
\end{frame}


\SidebarTask{Schleifen umwandeln}
\begin{frame}[fragile,c]{Schleifen umwandeln}
\begin{uncoverenv}<2->
\flushleft Im Folgenden finden Sie zwei Code-Ausschnitte. Schreiben Sie diese so um, dass sie nur noch Schleifen der angegebenen Art verwenden, ohne dass sich das Verhalten des Codes verändert. Dabei repräsentiert \bjava{k} eine natürliche Zahl (exklusive \(0\)), welche Sie nicht kennen.
\lstfs{8}\begin{columns}[onlytextwidth,T]
\column{.65\linewidth}
\begin{plainjava}
// In eine do-while-Schleife
int[] x = new int[]{17, 22, 13, 0};
for(int i = 0; i < x.length - k; i += 1) {
    System.out.println(x[i]);
}
\end{plainjava}
\column{.35\linewidth}
\begin{plainjava}
// In eine for-Schleife
int i = 1;
do {
    i *= k;
    k -= i;
} while(k >= 5);
System.out.println(i);
\end{plainjava}
\end{columns}
\end{uncoverenv}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset

\SidebarSolution
\begin{frame}[fragile,c]{Schleifen umwandeln\rhead{II}}
\begin{itemize}[<+(1)->]
   \itemsep3pt
   \item Aus \bjava{for} machen wir \bjava{do}-\bjava{while}
   \item Wird es überhaupt einmal ausgeführt?
\end{itemize}
\lstfs{9}
\begin{plainjava}
!*\onslide<4->*!int[] x = new int[]{17, 22, 13, 0};
!*\onslide<4->*!for(int i = 0; i < x.length - k; i += 1)
!*\onslide<4->*!    System.out.println(x[i]);
\end{plainjava}
\vspace*{-1.4\baselineskip}\par\null\qquad{\color{lightgray}\faCaretDown}
\begin{plainjava}
!*\onslide<5->*!int[] x = new int[]{17, 22, 13, 0};
!*\onslide<6->*!if(x.length - k <= 0) // Sonst keine Ausführung
!*\onslide<6->*!   return;
!*\onslide<7->*!int i = 0; // Initialisierung
!*\onslide<8->*!do { // normale Schleife
!*\onslide<9->*!   System.out.println(x[i]);
!*\onslide<9->*!   i++;
!*\onslide<8->*!} while(i < x.length - k);
\end{plainjava}
\end{frame}

\begin{frame}[fragile,c]{Schleifen umwandeln\rhead{III}}
\begin{itemize}[<+(1)->]
   \itemsep3pt
   \item Aus \bjava{do}-\bjava{while} machen wir \bjava{for}
   \item Wird es doch mindestens ein mal ausgeführt?
   \item Brauchen wir die Variablen danach noch?
\end{itemize}
\lstfs{9}
\begin{uncoverenv}<5->
\begin{columns}[onlytextwidth,c]
\column{.4\linewidth}
\begin{plainjava}
int i = 1;
do {
  i *= k;
  k -= i;
} while(k >= 5);
System.out.println(i);
\end{plainjava}
\vspace*{-1.15\baselineskip}\par\null\qquad{\color{lightgray}\faCaretRight}
\column{.6\linewidth}
\begin{plainjava}
!*\onslide<6->*!int i = 1; // Bedarf nach Schleife
!*\onslide<7->*!if(k < 5) { // Trotzdem ausführen?
!*\onslide<8->*!   i *= k;
!*\onslide<9->*!   // Wie Lebenserfahrung:
!*\onslide<9->*!   k -= i; // theoretisch unnötig
!*\onslide<7->*!} else {
!*\onslide<10->*!   for(; k >= 5; k -= i)
!*\onslide<11->*!      i *= k; // oder hier k -= i
!*\onslide<7->*!}
System.out.println(i);
\end{plainjava}
\end{columns}
\end{uncoverenv}
\end{frame}
\SidebarReset

\subsection{Recap}
\def\mto{\ensuremath{\to}}
\begin{frame}[c]{\paletteA{\sbfamily Kurzgesagt}\hfill Arrays \& Iteration}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Arrays sind komplexe Datentypen.
   \item Mehrdimensionale Arrays sind eindimensionale Arrays von eindimensionalen Arrays von\ldots
   \item Die drei Schleifenarten sind gleichmächtig. \begin{itemize}
      \item Maximum bekannt: \bjava{for}
      \item Mindestens ein mal: \bjava{do}-\bjava{while}
      \item Sonst: \bjava{while}
   \end{itemize}
\end{itemize}
\LargeSide
\end{frame}

\section{Unterprogramme}
\subsection{Übersicht}
\begin{frame}[fragile,c]{Unterprogramme}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item Ein Unterprogramm lagert einen Teil des Programms aus.
      \item In Java: \textsb{Methoden}\vspace*{-8\baselineskip}
   \end{itemize}
\begin{layout-imageonly}
\begin{plainjava}
!*\onslide<4->*!:lan:Modifikatoren:ran: :lan:Rückgabetyp:ran: :lan:Name:ran:(:lan:Parameterliste:ran:) {
!*\onslide<4->*!   :lan:Inhalt:ran:
!*\onslide<4->*!}
\end{plainjava}\vspace*{-9\baselineskip}
\end{layout-imageonly}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item<5-> Modifikatoren beeinflussen beispielsweise die Sichtbarkeit.
   \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Ein Beispiel}
\lstfs{10}\SetupLstHl\begin{layout-imageonly}
\begin{plainjava}
!*\onslide<2->*!|ihl|:lan:Modifikatoren:ran: :lan:Rückgabetyp:ran: :lan:Name:ran:(:lan:Parameterliste:ran:) {|ihl|
!*\onslide<2->*!|ihl|   :lan:Inhalt:ran:|ihl|
!*\onslide<2->*!|ihl|}|ihl|




!*\onslide<3->*!!*\tikzmark{mod-l}*!public static!*\tikzmark{mod-r}*! !*\tikzmark{String-l}*!String!*\tikzmark{String-r}*! !*\tikzmark{name-l}*!giveMeTheMiau!*\tikzmark{name-r}*!(!*\tikzmark{params-l}*!int times, double cuteness!*\tikzmark{params-r}*!) {
!*\onslide<4->*!   !*\tikzmark{start}*!String out = "";
!*\onslide<4->*!   for(int i = 0; i < times * cuteness; i++) {
!*\onslide<4->*!      out += "Miau ";
!*\onslide<4->*!   }
!*\onslide<4->*!   !*\tikzmark{end}*!return out;
!*\onslide<3->*!}
\end{plainjava}
\end{layout-imageonly}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<5->{\draw[decoration=brace,decorate] ([yshift=8pt]pic cs:mod-l) -- ([yshift=8pt]pic cs:mod-r) node[pos=.5,above=2pt] {\strut Modifikatoren};}
   \onslide<6->{\draw[decoration=brace,decorate] ([yshift=8pt]pic cs:String-l) -- ([yshift=8pt]pic cs:String-r) node[pos=.5,above=2pt] {\strut R-Typ};}
   \onslide<7->{\draw[decoration=brace,decorate] ([yshift=8pt]pic cs:name-l) -- ([yshift=8pt]pic cs:name-r) node[pos=.5,above=2pt] {\strut Name};}
   \onslide<8->{\draw[decoration=brace,decorate] ([yshift=8pt]pic cs:params-l) -- ([yshift=8pt]pic cs:params-r) node[pos=.5,above=2pt] {\strut Parameterliste};}
   \onslide<9->{\draw[decoration={brace,mirror},decorate] ([yshift=8pt,xshift=-1.5pt]pic cs:start) -- ([yshift=-2pt,xshift=-1.5pt]pic cs:end) node[pos=.5,left=3pt] {\strut\rotatebox{90}{Inhalt}};}
   \onslide<10->{
      \node[above left=.5cm,draw=gray,very thick,inner sep=5pt,rounded corners=1.75pt,xshift=-.25cm,yshift=.65cm,align=left] at(current page.south east) {\textsb{Signatur}: Name \& Parametertypen\\\lstfs{11}\bjava{giveMeTheMiau(int, double)}};
   }
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{Rückgabewert}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item \bjava{void} kennzeichnet, dass die Methode nichts zurückgibt.
      \item Sonst: jeder Ausführungspfad muss einen Wert vom angegebenen Typ liefern.
   \end{itemize}
\begin{plainjava}
!*\onslide<4->*!public static int iHaveCatPics(String where) {
!*\onslide<5->*!   if(where.equals("MIAFF"))
!*\onslide<5->*!      return 42;
!*\onslide<4->*!}
\end{plainjava}
   \begin{itemize}
      \item<6-> \textsb{Verboten}, da nicht jeder Ausführungspfad \bjava{int} liefert
   \end{itemize}
\end{frame}

\subsection{Methodenaufruf}
\begin{frame}[c]{Methodenaufruf}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item Methoden mit \bjava{static} gehören der Klasse. \begin{itemize}
         \item Wir benötigen kein Objekt.
         \item In ihnen \say{gibt} es \textit{kein} \bjava{this}.
      \end{itemize}
      \item Java sucht beim Aufruf eine (sichtbare \& gültige) Methode mit entsprechender Signatur. \begin{itemize}
         \item Implizite Typkonvertierung!
      \end{itemize}
      \item \textsb{Überladung}: Gleicher Name, unterschiedliche Signatur.
   \end{itemize}
\end{frame}

\newsavebox\agentpingu
\savebox\agentpingu{\tikz\pingu[cloak=pingu@black,sunglasses,tie=pingu@black,eyes angry,glasses opacity=.876];}
\begin{frame}[c]{Call-By \& Seiteneffekte}
   \vspace*{.75\baselineskip}\begin{itemize}
      \itemsep11pt
      \item<3-> Aufruf: \say{Stack-Einträge} der Parameter werden \textit{kopiert}.
      \begin{itemize}
         \item<4-> Primitive Datentypen:\hfill call-by-\textit{value}
         \item<5-> Komplexe Datentypen:\hfill \say{call-by-\textit{reference}}
      \end{itemize}
      \item<6-> Genau genommen hat Java nur \say{call-by-value}\infoblock{Aber wir folgen mal der Terminologie der Vorlesung.}
      \item<7-> \textsb{Seiteneffekt}: Wenn nach dem Aufruf Zustandsänderungen neben dem Rückgabewert verbleiben.\smallskip \begin{itemize}
         \item<8-> Instanzvariable verändert sich.
         \item<9-> Durch Referenzen wird ein Array modifiziert.
         \item<10-> Eine Nachricht fliegt durchs Internet.
         \item<11-> \ldots
      \end{itemize}
   \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<2->{\node[below left=.33cm,scale=.6] (agent) at(current page.north east) {\usebox\agentpingu};
   \node[left,align=right,font=\footnotesize] at(agent.west) {You can call me pingu.\\Cute pingu!};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Varargs}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item Der letzte Parameter darf in Java ein \say{Vararg} sein.
      \item Drei Punkte: erlaubt beliebig viele Argumente des Typs.
      \item Kann in der Methode als Array verwendet werden.\vspace*{-2\baselineskip}
   \end{itemize}
\begin{layout-imageonly}
\begin{plainjava}
!*\onslide<5->*!static double[] funFunFun(int factor, double... arguments) {
!*\onslide<6->*!   for(int i = 0; i < arguments.length; i++) {
!*\onslide<6->*!      arguments[i] *= factor;
!*\onslide<6->*!   }
!*\onslide<7->*!   return arguments;
!*\onslide<5->*!}
\end{plainjava}
\end{layout-imageonly}
\end{frame}


\SidebarTask{Reverse}
\begin{frame}[c]{Reverse}
\flushleft\onslide<2->{Schreiben Sie eine Methode \bjava{static void reverse(int[]} \bjava{arr)}, welche das übergebene Array umdreht, sodass das erste Elemente nun an letzter Stelle steht, das zweite an vorletzter Stelle,~\ldots\ und das letzte Element nun an erster Stelle steht.\par}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset

\SidebarSolution
\begin{frame}[fragile,c]{Reverse\rhead{II}}
\begin{plainjava}
!*\onslide<5->*!static void swap(int[] arr, int i, int j) {
!*\onslide<6->*!   int tmp = arr[i];
!*\onslide<6->*!   arr[i] = arr[j];
!*\onslide<6->*!   arr[j] = tmp;
!*\onslide<5->*!}
!*\onslide<2->*!
!*\onslide<2->*!static void reverse(int[] arr) {
!*\onslide<3->*!   for(int i = 0; i < arr.length / 2; i++) {
!*\onslide<4->*!      swap(arr, i, arr.length - i - 1);
!*\onslide<3->*!   }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}
\SidebarReset

\subsection{Recap}
\begin{frame}[c]{\paletteA{\sbfamily Kurzgesagt}\hfill Unterprogramme}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item \textit{Überladung:}\hfill Gleicher Name, andere Signatur. \begin{itemize}
      \item \textit{Signatur:} Name \& Parametertypliste
      \item Müssen zudem in selber Klasse sein (später: Vererbung)
   \end{itemize}
   \item Beim Aufruf macht Java call-by-value: \begin{itemize}
      \item Alle Parameter werden kopiert (Stack)
   \end{itemize}
\end{itemize}
\LargeSide
\end{frame}


\section{OOP}
\subsection{Allgemein}
\SidebarRaw{\downsize{15em}{\begin{tikzpicture}
   \draw[paletteA,fill=shadeB] (0,0) circle[radius=15mm];
   \draw (0,0) circle[radius=30mm];
   \foreach \a in {0,30,...,359} {
      \draw (\a:15mm) -- (\a:30mm);
   }
\end{tikzpicture}}}
\begin{frame}{Allgemein}
   \begin{itemize}[<+(1)->]
      \itemsep14pt
      \item Objekte abstrahieren Daten und Verhalten
      \item Ermöglicht Wiederverwendung von Komponenten
      \item Klassen definieren eine Blaupause: \begin{itemize}
         \item Welche Eigenschaften haben die Daten? \hfill \textsb{Attribute}
         \item Was kann mit den Daten gemacht werden? \hfill \textsb{Methoden}
      \end{itemize}
      \item Die Attribute definieren den Zustand
      \item Die Methoden definieren das Verhalten
   \end{itemize}
\end{frame}
\SidebarReset

\def\Card#1#2{\begin{tikzpicture}
   \node (udbert) at(0,0) {\bjava{Penguin #1}};
   \node[below right,inner sep=0pt,xshift=4pt,align=left,draw,rounded corners=1pt] at (udbert.south west) {\begin{tabular}{l|p{4em}}
      #2
   \end{tabular}};
\end{tikzpicture}}

\newsavebox\pingunote
\savebox\pingunote{\tikz\pingu[left wing wave,cloak=paletteA!80!pingu@white,eyes wink];}
\begin{frame}[fragile,c]{Klasse vs. Objekt}
   \begin{itemize}[<+(1)->]
      \itemsep7pt
      \item Klasse ist eine Blaupause
      \item Objekte weisen Attribute konkrete Werte zu
   \end{itemize}\vspace*{-1\baselineskip}
\begin{layout-imageonly}
\begin{columns}[onlytextwidth,c]
\column{.475\linewidth}\SetupLstHl\lstfs{10}
\begin{plainjava}
!*\onslide<4->*!class Penguin {
!*\onslide<4->*!   double cute;
!*\onslide<4->*!   int age;
!*\onslide<4->*!   String name;
!*\onslide<4->*!
!*\onslide<4->*!   |ihl|void walk(int snow) { ... }|ihl|
!*\onslide<4->*!   |ihl|void peep() { ... }|ihl|
!*\onslide<4->*!   |ihl|...|ihl|
!*\onslide<4->*!}
\end{plainjava}
\column{.525\linewidth}
\def\arraystretch{1.125}%
\resizebox\linewidth!{\onslide<5->{\Card{udbert}{cute & \(5.7\)\\\hline
age & \(12\)\\\hline
name & \say{Udi}}}~~\onslide<6->{\Card{josie}{cute & \(6.1\)\\\hline
age & \(10\)\\\hline
name & \say{Josie}}~}}\\[5pt]\resizebox\linewidth!{\onslide<8->{\Card{peter}{cute & \(6\)\\\hline
age & \(10\)\\\hline
name & \say{Petaa}}}~~\onslide<7->{\Card{saphira}{cute & \(8\)\\\hline
age & \(11\)\\\hline
name & \say{Saph}}}~}
\end{columns}
\end{layout-imageonly}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<9->{\node[below left=-2cm] (pingu) at(current page.north east) {\rotatebox{140}{\usebox\pingunote}};
   \node[below left,yshift=.2cm,xshift=.75cm,font=\footnotesize,align=right] at(pingu.west) {Jedes Objekt erzeugt\\alle Instanzvariablen \say{für sich}\\allein.};}
\end{tikzpicture}
\end{frame}

\subsection{Klasseneigenschaften}
\begin{frame}{Der Konstruktor}
\begin{itemize}[<+(1)->]
   \itemsep6pt
   \item Erlaubt für Werte beim Erzeugen (\say{initialer Zustand})
   \item Ein Konstruktor ist \textit{keine} Methode\vspace*{-\topsep}
\end{itemize}
\begin{multicols}{2}
\begin{itemize}[<+(1)->]
   \item Unterschiede: \begin{itemize}
      \item Muss heißen wie die Klasse
      \item Hat keinen Rückgabetyp
      \item Kann nichts zurückgeben
      \item Benötigt \bjava{new} für Aufruf
      \item \ldots
   \end{itemize}
   \item Gemeinsamkeiten:
   \begin{itemize}
      \item Hat Parameter
      \item Kann überladen werden
      \item Kann Methoden aufrufen
      \item Kann Objekte erzeugen
      \item \ldots
   \end{itemize}
\end{itemize}
\end{multicols}
\begin{itemize}[<+(1)->]
   \item Java erzeugt \textit{genau dann} einen leeren Konstruktor, wenn kein expliziter Konstruktor existiert.
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<17->{\node[below left=.5cm,align=right] at(current page.north east) {\textsb{Instanziierung:} Erzeugen\\eines neuen Objektes.};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{Der Standardkonstruktor}
\begin{layout-imageonly}
\begin{columns}[onlytextwidth,c]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<2->*!public class Supa {
!*\onslide<2->*!   int x;
!*\onslide<2->*!}
\end{plainjava}
\column{.5\linewidth}
\begin{itemize}
   \item<3-> \cjava{Supa s = new Supa();}\smallskip\\
   \onslide<4->{Erlaubt, durch den leeren Standardkonstruktor.
   \bjava{s.x} hat den Standardwert \bjava{0}.}
\end{itemize}
\end{columns}
\begin{columns}[onlytextwidth,c]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<5->*!public class Mega {
!*\onslide<5->*!   String name;
!*\onslide<5->*!   public Mega(String name) {
!*\onslide<5->*!     this.name = name;
!*\onslide<5->*!  }
!*\onslide<5->*!}
\end{plainjava}
\column{.5\linewidth}
\begin{itemize}
   \item<6-> \cjava{Mega m = new Mega();}\smallskip\\
   \onslide<7->{Nicht erlaubt. Existiert ein expliziter Konstruktor, erstellt Java keinen \say{leeren} mehr!}
   \item<8-> \cjava{Mega x = new Mega(\"Huhu\");}\smallskip\\
   \onslide<9->{Erlaubt. \bjava{x.name} ist \bjava{\"Huhu\"}.}
\end{itemize}
\end{columns}
\end{layout-imageonly}
\end{frame}

\begin{frame}[fragile,c]{Einen Konstruktor überladen}
\begin{itemize}[<+(1)->]
   \itemsep3.5pt
   \item Konstruktoren können einander mit \bjava{this} aufrufen. Dies muss dann das \emph{erste} Statement sein. Keine Rekursion.
\end{itemize}\vspace*{-.85\baselineskip}
\begin{layout-imageonly}
\begingroup\lstfs{9}\begin{multicols}{2}
\begin{plainjava}
!*\onslide<3->*!public class Car {
!*\onslide<3->*!   int topSpeed;
!*\onslide<3->*!   final boolean pengu;
!*\onslide<4->*!   public !*\tikzmark{Car-2l}*!Car(int top, boolean p)!*\tikzmark{Car-2r}*! {
!*\onslide<4->*!      this.topSpeed = top;
!*\onslide<4->*!      this.pengu = p;
!*\onslide<4->*!   }
!*\onslide<3->*!
!*\onslide<5->*!   public !*\tikzmark{Car-1l}*!Car!*\tikzmark{Car-1r}*!(int top) {
!*\onslide<5->*!      !*\tikzmark{this-2l}*!this(top, true);!*\tikzmark{this-2r}*!
!*\onslide<5->*!      System.out.println("Piep");
!*\onslide<5->*!   }
!*\onslide<3->*!
!*\onslide<6->*!   public !*\tikzmark{Car-l}*!Car()!*\tikzmark{Car-r}*! { !*\tikzmark{this-1l}*!this(20);!*\tikzmark{this-1r}*! }
!*\onslide<3->*!}
\end{plainjava}
\end{multicols}\endgroup
\begin{itemize}
\itemsep3.5pt
\item<9-> \cjava{new Car()}\,: \onslide<10->{\bjava{topSpeed} ist \bjava{20}, \bjava{pengu} ist \bjava{true}. Mit Piep!}
\item<11-> \cjava{new Car(14)}\,: \onslide<12->{\bjava{topSpeed} ist \bjava{14}, \bjava{pengu} ist \bjava{true}. Mit Piep!}
\item<13-> \cjava{new Car(2, false)}\,: \onslide<14->{\bjava{topSpeed} ist \bjava{2}, \bjava{pengu} ist \bjava{false}. Kein Piep!}
\end{itemize}
\end{layout-imageonly}
\begin{tikzpicture}[overlay,remember picture]
   \onslide<7->{\draw[decoration=brace,decorate] ([yshift=8pt]pic cs:this-1l) -- ([yshift=8pt]pic cs:this-1r) node[pos=.5,above=3pt] {\footnotesize\bjava{Car(int)}};}
   \onslide<8->{\draw[gray,-Kite] ([yshift=3pt]pic cs:this-2l) to[out=180,in=20] ([yshift=10pt,xshift=-18pt]pic cs:Car-2r);}
\end{tikzpicture}
\end{frame}


\SidebarTask{Die Algorithmenklasse}
\begin{frame}[c]{Die Algorithmenklasse}
\onslide<2->{%
\updateitemize{1.}\begin{enumerate}[<+(1)->]
   \item Erzeugen Sie eine Klasse \T{BinaerUmwandler}, welche private Instanzvariablen für einen Binärstring und eine Dezimalzahl besitzt.
   \item Erstellen Sie Getter und Setter für die Instanzvariablen.
   \item Implementieren Sie den Standardkonstruktor explizit und erzeugen Sie eine überladene Version, die den übergebenen Binärstring initialisiert.
\end{enumerate}}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset
\SidebarSolution
\begin{frame}[fragile,c]{Mein kleiner Algorithmus}
\only<2-9|handout:1> {1.~Klasse \T{BinaerUmwandler} mit privaten Instanzvariablen}\smallskip\\
\only<5-9|handout:1> {2.~Getter und Setter}\medskip
\begin{minted}[escapeinside={/*}{*/}]{java}
/*\onslide<3->*/public class BinaerUmwandler {
/*\onslide<4->*/   private String binary;
/*\onslide<4->*/   private long decimal;
/*\onslide<6->*/   public String getBinary() { return this.binary; }
/*\onslide<7->*/   public void setBinary(String binary) {
/*\onslide<9->*/      this.binary = binary;
/*\onslide<7->*/   }

/*\onslide<10->*/   public long getDecimal() { return this.decimal; }
/*\onslide<11->*/   public void setDecimal(long decimal) {
/*\onslide<12->*/      this.decimal = decimal;
/*\onslide<11->*/   }
/*\onslide<3->*/}
\end{minted}
\end{frame}
\SidebarReset


% TODO: we build this up block by block


\begin{frame}[c]{Static vs. Non-Static}
   \begin{itemize}[<+(1)->]
      \itemsep11pt
      \item Statische Variablen \& Methoden sind an die Klasse gebunden. \begin{itemize}
         \item Kein Objekt notwendig um Sie aufzurufen/abzugreifen.
         \item Keine Instanz- sondern Klassenvariablen.
      \end{itemize}
      \item Die Frage~--- ob man etwas static machen soll~--- lautet:\\Ist diese Eigenschaft allen Objekten gemein?
   \end{itemize}
\end{frame}


\SidebarTask{Kameraszenario}
\begin{frame}[c]{Kameraszenario}
\onslide<2->{\footnotesize\flushleft Sie sehen das Grundgerüst einer Kameraklasse. Sie dürfen für die Aufgabe \textit{keine} (Java-)Ausnahmen verwenden.
\begin{enumerate}
    \item Schreiben Sie einen leeren Konstruktor, welcher die von Java zugewiesenen Standardwerte explizit initialisiert. Dieser Konstruktor soll nicht von Code abseits der \bjava{Camera}-Klasse aufrufbar sein und so verhindern, dass weitere Kamera-Objekte erstellt werden können.
    \item Erweitern Sie die Klasse nun in sofern, dass es immer maximal fünf Kamera-Objekte gibt, welche durch \bjava{get(int)} durch eine Zahl \(x \in \{0, 1, 2, 3, 4\}\) abgefragt werden können. Dabei soll ein Kamera-Objekt erst (mit Ihrem vorher erzeugten Konstruktor) erzeugt werden, wenn es durch die Zahl angefragt wird. Weiter sollen Folgeanfragen mit der Zahl dasselbe Objekt zurückliefern. Geben Sie für \(x < 0\) und \(x \geq 5\) den Wert \bjava{null} zurück.
\end{enumerate}}
\onslide<1->{\ShortSide}%
\end{frame}
\begin{frame}[fragile,c]{Kameraszenario\rhead{II}}
\columns[c,onlytextwidth]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<2->*!public final class Camera {
!*\onslide<3->*!   private float x;
!*\onslide<3->*!   private float y;
!*\onslide<3->*!   private int z;
!*\onslide<3->*!   private boolean recording;
!*\onslide<3->*!   // :ldots:
!*\onslide<2->*!}
\end{plainjava}
\column{.5\linewidth}
\updateitemize{1.}%
\begin{enumerate}
   \item<4-> Leerer Konstruktor, der Standardwerte explizit zuweist und nicht von außerhalb aufrufbar ist.
\end{enumerate}
\endcolumns
\medskip
\updateitemize{1.}%
\begin{enumerate}
   \setcounter{enumi}{1}
   \item<5-> Maximal fünf Kamera-Objekte (\(i \in \{0, \ldots, 4\}\)) durch \bjava{Camera get(int i)}. Sollen erst erzeugt werden, wenn angefordert, illegale Werte sollen \bjava{null} liefern.
\end{enumerate}
\onslide<1->{\ShortSide}%
\end{frame}
\SidebarReset


\SidebarSolution
\begin{frame}[fragile,c]{Der Kamera-Konstruktor}
\begin{plainjava}
!*\onslide<2->*!private Camera() {
!*\onslide<3->*!   x = y = 0.0f;
!*\onslide<4->*!   z = 0;
!*\onslide<5->*!   recording = false;
!*\onslide<2->*!}
\end{plainjava}\medskip
\begin{itemize}
   \item<6-> \bjava{private}: Damit von außen nicht zugreifbar
   \item<7-> \bjava{x = y = 0.0f} als Kurzform für \bjava{x = 0.0f}, \bjava{y = 0.0f} \onslide<8->{\infoblock{Hier spielen Präzedenzregeln, Assoziativität und die Tatsache zusammen, dass \T{$\alpha$ = $\beta$} selbst wieder zu $\beta$ evaluiert: \T{$\gamma$ = ($\alpha$ = $\beta$)}.}}
   \item<9-> \bjava{0.0f}, weil es sich hierbei ja um floats handelt. \bjava{0} würde eine implizite Typkonvertierung benötigen!
\end{itemize}
\begin{tikzpicture}[remember picture,overlay]
   % TODO: improve that
   \only<6->{\node[below left=.5cm] at(current page.north east) {\footnotesize\faFileO~\textattachfile{\curpath Camera.java}{Camera.java}};}
\end{tikzpicture}%
\end{frame}

\begin{frame}[fragile,c]{Nur fünf Kameras}
\begin{plainjava}
!*\onslide<2->*!private static Camera[] cameras = new Camera[5];
!*\onslide<2->*!
!*\onslide<3->*!public static Camera get(int n) {
!*\onslide<4->*!   if(n < 0 || n >= 5) return null;
!*\onslide<5->*!   if(cameras[n] == null)
!*\onslide<5->*!      cameras[n] = new Camera();
!*\onslide<6->*!   return cameras[n];
!*\onslide<3->*!}
\end{plainjava}
\bigskip
\begin{itemize}
   \itemsep6pt
   \item<7-> Das Array kontrolliert den Pool verfügbarer Kameras
   \item<8-> Statische Erzeuger-Methoden erlauben mehr Kontrolle
\end{itemize}
\end{frame}
\SidebarReset

\subsection{Sichtbarkeiten \& Gültigkeiten}
\begin{frame}{Sichtbarkeit \& Gültigkeit}
   \begin{itemize}[<+(1)->]
      \itemsep14pt
      \item Klassen, Methoden \& Attribute haben \textsb{Sichtbarkeiten}. \begin{itemize}
         \item Sie können nur verwendet werden, wo sie sichtbar sind
         \item Diese Sichtbarkeit wird durch \bjava{public}, \bjava{private},~\ldots\ kontrolliert
      \end{itemize}
      \item Variablen,~\ldots\ haben einen \textsb{Gültigkeitsbereich} (Scope). \begin{itemize}
         \item So gibt es den Gültigkeitsbereich der Klasse und
         \item Den lokalen Gültigkeitsbereich in Methoden, Blöcken,~\ldots
      \end{itemize}
      \item Eine Variable kann z.B. sichtbar, aber gerade durch Überschattung nicht gültig sein
   \end{itemize}
\end{frame}

\begin{frame}[c]{Gruppierung}
   \begin{itemize}[<+(1)->]
      \itemsep14pt
      \item Java nutzt \textsb{Packages} als Namensräume \begin{itemize}
         \item Ordner der dann alle zugehörigen Java-Dateien enthält
         \item Können über \bjava{import <pack:c:age>;} sichtbar gemacht werden
         \item Dabei wird \bjava{java.lang} immer importiert
      \end{itemize}
      % \item Sichtbarkeiten interagieren auch mit Vererbung.
   \end{itemize}
\end{frame}


\begin{frame}[c]{Scopes}
   \begin{itemize}[<+(1)->]
      \itemsep13pt
      \item Java erlaubt vier verschiedene Sichtbarkeitsmodifikatoren: \begin{itemize}
         \item \textit{private:} Nur innerhalb der Klasse
         \item \textit{protected:} Im gesamten Paket sowie allen Unterklassen
         \item \textit{public:} Überall sichtbar wo Paket sichtbar
         \item \textit{\say{default}:} Überall im Paket
     \end{itemize}
     \item \textit{Hinweis:} Objekte einer Klasse können auf private Elemente anderer Objekte der gleichen Klasse zugreifen.
   \end{itemize}
\end{frame}


\begin{frame}[fragile,c]{Ein Scope Beispiel}
   \small\begin{itemize}[<+(1)->]
      \itemsep6pt
   \item Es gibt vier Sichtbarkeitsbereiche für Klassen, Attribute,~\ldots.\vspace*{-8\baselineskip}
\begin{layout-imageonly}\lstfs{10}
\begin{plainjava}[language=xJava]
!*\onslide<3->*!|zws|public|zws| class Person { // !*\solGet{comments}{\textbf{1.}}*! global
!*\onslide<4->*!    !**!|zws|private|zws| int alter; // !*\solGet{comments}{\textbf{2.}}*! Klasse
!*\onslide<5->*!    !**!|zws|protected|zws| int gewicht; // !*\solGet{comments}{\textbf{3.}}*! geschützt
!*\onslide<6->*!    !**!|zws|public|zws| void schlafe() { /* ... */ } // !*\solGet{comments}{\textbf{4.}}*! (erneut: global)
!*\onslide<7->*!    void esse() { /* ... */ } // !*\solGet{comments}{\textbf{5.}}*! Standard: Paket
!*\onslide<3->*!}
\end{plainjava}\vspace*{-8.66\baselineskip}
\end{layout-imageonly}
\item<8-> Die Klasse \bjava{Tier} sei im selben, \bjava{Haus} sei in einem anderen Paket: \medskip\par
\onslide<9->{\def\y{\faCheckSquareO}\def\n{\hspace*{-1pt}\faSquareO}\scriptsize\begin{minipage}{.5\linewidth}
\begin{tabular}{p{6em}ccccc}
   \toprule
                  & 1 & 2 & 3 & 4 & 5 \\
\midrule
      \T{Person} & \y & \y & \y & \y & \y \\
      \T{Tier}   & \y & \n & \y & \y & \y \\
      \T{Hause}  & \y & \n & \n & \y & \n \\
\bottomrule
\end{tabular}
\end{minipage}}
\end{itemize}
\end{frame}

\subsection{Ausnahmen}
{\def\t#1{\hfill\textcolor{gray}{\itshape#1}}
\begin{frame}{Fehlerbehandlung}
   \begin{itemize}[<+(1)->]
      \itemsep8pt
      \item Wenn irgendetwas schief geht, wirft Java eine Ausnahme
      \item Wir unterscheiden drei Arten: \begin{itemize}
         \item \textsb{Error:} Katastrophe, zum Beispiel kein Speicher. Kaum behandelbar.
         \item \textsb{RuntimeException:} Vorhersehbar, aber nun schwer behandelbar (wie ein negativer Array-Index,~\ldots).\t{unchecked}
         \item \textsb{Exception:} Schwer vorhersehbare Ausnahme (wie Datei nicht gefunden,~\ldots).\t{checked}
      \end{itemize}
      \item Normale \say{Exceptions} \emph{müssen} in Java: \begin{itemize}
         \item Behandelt werden (\bjava{try-catch}), oder
         \item weitergeleitet werden (\bjava{throws}).
      \end{itemize}
   \end{itemize}
\end{frame}

\begin{frame}[c]{Klassische Fehler}
   \begin{itemize}
      \itemsep10pt
      \item<2-> \solGet{keywordC}{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ArithmeticException.html}{ArithmeticException}}\onslide<3->{\t{unchecked}
      \infoblock{Verbotene Rechenoperation wie Teilen einer Ganzzahl durch \(0\).}}
      \item<4-> \solGet{keywordC}{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ArrayIndexOutOfBoundsException.html}{ArrayIndexOutOfBoundsException}}\onslide<5->{\t{unchecked}\infoblock{Negativer Index oder zu großer Index für Array!}}
      \item<6-> \solGet{keywordC}{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/FileNotFoundException.html}{FileNotFoundException}}\onslide<7->{\t{checked}\infoblock{Der gegebene Pfad liefert keine Datei!}}
      \item<8-> \solGet{keywordC}{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/IllegalArgumentException.html}{IllegalArgumentException}}\onslide<9->{\t{unchecked}\infoblock{Eine Methode hat ein unpassendes Argument erhalten!}}
      \item<10-> \solGet{keywordC}{\link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/NullPointerException.html}{NullPointerException}}\onslide<11->{\t{unchecked}
      \infoblock{Wir verwenden \T{null} wo ein Objekt gebraucht wird.}}
   \end{itemize}
\end{frame}
}

\begin{frame}[c]{Eskalationsfreude}
   \begin{itemize}[<+(1)->]
      \itemsep10pt
      \item Eine Ausnahme unterbricht den Programmfluss
      \item Wird sie nicht direkt behandelt, eskaliert die Ausnahme den \say{Call-Stack} hinauf
      \item Was über die \bjava{main}-Methode eskaliert wird von der JVM abgefangen und beendet das Programm.
      \item Ausnahmen sollten in Java aber nicht zur Werterückgabe verwendet werden.
   \end{itemize}
\end{frame}


\SidebarTask{Fehler finden}
\begin{frame}[c]{Fehler finden}
\onslide<2->{\footnotesize\flushleft Im Code finden sich \textsb{10 Fehler}, welche vom Java-Compiler erkannt werden.
Identifizieren Sie \textsb{acht} dieser Fehler durch \smallskip\updateitemize{1.}\begin{enumerate}
    \item die Angabe der Code-Zeilennummer und
    \item eine kurze Erklärung, was den Fehler verursacht.
\end{enumerate}
\flushleft
Wenn Sie mehrere Fehler in einer Code-Zeile finden, tragen sie diese separat ein.
Folgefehler zählen dabei nicht als separate Fehler. Wird also beispielsweise ein Bezeichner inkorrekt initialisiert, so zählt nicht jede Verwendung als zusätzlicher Fehler sondern nur die inkorrekte Initialisierung.\par}
\onslide<1->{\ShortSide}%
\end{frame}
{\makeatletter
\begin{frame}[fragile,c]{Fehler finden\rhead{II}}
\lstfs{8}\vspace*{-4mm}%
\lstset{lineskip=0.5pt}\lstcolorlet{linenumbers}{darkgray}\columnsep9mm\soldisablenumhl
\begin{plainvoid}[numbers=left,numbersep=6pt,multicols=2,numberstyle=\@declaredcolor{darkgray}\fontsize{6pt}{6pt}\selectfont\sffamily\sbseries\sol@lst@num@consume, numbersep=2pt]
public class iDoGood {
  final void i = 0x7;
  private final String omega = "Sunshine";

  static int iMultiply(final char x, double y) {
    return x * y;
  }

  public IDoGood(String eda) {
    this.omega = eda;
  }

  static int double(byte i) {
    return 2 * ++i;
  }

  private iDoGood() {
    this(andromeda);
  }

  private boolean iDoGood() {
    if(this.omega.equals("i"));
    int i = 0 // /** // **/ /*;
    for(;i < 2_00;i++, i += 2)
     System.Err.println(i);
    return false /** // */ ;
  }

  static class iDoBetta {
    global doBetta() {
      iDoGood gud = iDoGood();
      System.out.println(gud.omega);
    }
  }
}
\end{plainvoid}
\onslide<1->{\ShortSide}%
\end{frame}
}
\SidebarReset

\SidebarSolution
\begin{frame}[c]{Fehlersuche}
   \updateitemize{15.}%
   \begin{enumerate}[<+(1)->]
      \itemsep9.25pt
      \item \textit{Zeile 2}:\quad \bjava{void} ist kein Datentyp.
      \item \textit{Zeile 3/10}:\quad Wenn \bjava{omega} \bjava{final} ist, kann es im\\\qquad Konstruktor nicht geändert werden.
      \item \textit{Zeile 6}:\quad das Produkt aus \bjava{char} und \bjava{double} ist \bjava{double}\\\qquad und muss explizit zu \bjava{int} konvertiert werden.
      \item \textit{Zeile 9}:\quad Ein Konstruktor muss genau so heißen wie die\\\qquad Klasse. Hier ist das \bjava{I} aber groß. Alternativ fehlt\\\qquad mindestens der Rückgabetyp.
      \item \textit{Zeile 13}:\quad \bjava{double} ist ein Keyword und kann nicht als\\\qquad Bezeichner verwendet werden.
   \end{enumerate}
\end{frame}

\begin{frame}[c]{Fehlersuche\rhead{II}}
   \updateitemize{15.}%
   \begin{enumerate}[<+(1)->]
      \itemsep9.25pt
      \item[6.] \textit{Zeile 18}:\quad \bjava{andromeda} ist in \bjava{iDoGood()} keine Variable.
      \item[7.] \textit{Zeile 23}:\quad Fehlendes fehlt Semikolon (auskommentiert).
      \item[8.] \textit{Zeile 25}:\quad \bjava{System.Err} existiert nur kleingeschrieben als\\\qquad\bjava{System.err}.
      \item[9.] \textit{Zeile 30}:\quad \bjava{global} ist in Java kein gültiger Methoden-\\\qquad Modifikator.
      \item[10.] \textit{Zeile 31}:\quad \bjava{iDoGood} ist ein Konstruktor und kann nur mit\\\qquad\bjava{new} aufgerufen werden (die \bjava{boolean}-Methode\\\qquad bräuchte ein Objekt).
   \end{enumerate}
\end{frame}
\SidebarReset

\subsection{Recap}
\begin{frame}[c]{\paletteA{\sbfamily Kurzgesagt}\hfill OOP}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Eine Klasse definiert die Blaupause für Objekte \begin{itemize}
      \item Attribute definieren den Zustand
      \item Methoden definieren den Verhalten
   \end{itemize}
   \item Der Konstruktor baut den initialen Zustand \begin{itemize}
      \item \textsb{Instanziierung}: Erzeugen eines neuen Objektes
      \item Wenn keiner: erzeugt Java den leeren Standardkonstruktor
      \item \bjava{this} erlaubt Aufruf von überladenen Konstruktoren
   \end{itemize}
   \item Klassen, Methoden,~\ldots:\hfill \textsb{Sichtbarkeit}  (\bjava{public},~\ldots)
   \item \textsb{Gültigkeit}sbereich: Wo die Variablen \say{deklariert sind}.
\end{itemize}
\LargeSide
\end{frame}

% \newsavebox\postpengu
% \savebox\postpengu{\tikz\pingu[body=paletteA!68!pingu@white,body front=paletteA!38!pingu@white,eyes wink,eyes color=paletteA!68!pingu@white,bill color=paletteA!68!pingu@white,feet color=paletteA!68!pingu@white,heart=paletteA!38!pingu@white,santa hat=paletteA!68!pingu@white,santa hat second=paletteA!38!pingu@white,santa beard=paletteA!68!pingu@white];}
% \PostPage{\begin{tikzpicture}[overlay,remember picture]
%    \node[below left=.66cm,scale=1.33] at (current page.north east) {\rotatebox{-10}{\usebox\postpengu}};
%    \node[below right=.5cm] (qr) at(current page.north west) {\fancyqr[height=3.65cm]{https://github.com/EagleoutIce/christmas-eidi-recap}};
%    \node[below right,pingu@white,yshift=-.25cm,text width=3.75cm,font=\scriptsize] at(qr.south west) {Sources \& current version on GitHub};
% \end{tikzpicture}}

\begin{frame}
   TODO: die 3. Präsenzaufagbe als Wert 0 und 2. anstelle KAchellland

   TODO: Weihnachtswiederholung referenzieren
   TODO: outro
   TODO: iffull--false should just reveal the short compat repeat slides without their side banners!

\end{frame}

\iffull
\else
\outro{\vskip9mm\centering \onslide<2->{x}}
\fi
\iffull\end{document}\fi
