\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{Integral Refs in Higher Dimensions}
\subtitle{Tutorium vier}
\date{KW 21}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{4}

\iffull\begin{document}
\titleframe

\TopicOverview{4}
\fi

\iffull{\SummaryFrame
\setbox\pinguA=\hbox{\SolNoInlineSize\scalebox{.5}{\tikzpicture
\fill[lgray,rounded corners] (0,1.65) rectangle ++(3,3.85);
\fill[lgray,rounded corners] (3.5,1.65) rectangle ++(3,3.85);
\node[ldesc,above] at (1.5,5.5) {Stack};
\node[ldesc,above] at (5,5.5) {Heap};
\node[lrel] at (1.5,5) {\ldots};
\node[lrel] at (5,5) {\ldots};
\node[lrel] at (1.5,5-.85) {\bjava{byte b = 7}};
\node[lrel] at (1.5,5-.85*2) {\bjava{char c = '?'}};
\node[lrel] (fg) at (1.5,5-.85*3) {\bjava{int[] i =\ }\raisebox{-1pt}\faGenderless};
\node[lrel] (ft) at (5,5-.85-.425) {\bjava{\{1, 9, 0\}}};
\draw[lightgray,very thick,-Kite]  (fg.east) to[out=0,in=180] (ft.west);
\endtikzpicture}}
\begin{frame}[fragile,c]{Kurzwiederholung}
    \begin{itemize}[<+(1)->]
        \itemsep9.25pt
        \item Wir haben uns Methoden angesehen \begin{itemize}
            \item Methoden mit einem Rückgabetyp \say{$\neq$~\bjava{void}} müssen für jeden Pfad diesen Typ liefern
            \item Methoden haben Vor- \info{Parameter} und Nachbedingungen \info{Rückgabetyp}
            \item Parameter und lokale Variablen sind nur in ihrer Methode sichtbar
        \end{itemize}
        \item<6-> Für Arrays haben wir for-each\vspace*{-\medskipamount}
\columns[onlytextwidth,c]
\column{.45\linewidth}
\begin{plainjava}
!*\onslide<7->*!int[] arr = { 1, 9, -2, 3 };
!*\onslide<8->*!for(int elem : arr)
!*\onslide<9->*!    System.out.println(elem);!*\onslide<1->*!
\end{plainjava}
\column{.55\linewidth}
\begin{plainjava}
!*\onslide<10->*!int[] arr = new !*\tikzmarknode{@}{\sbasic{\skB{int}[\snum{5}]}}*!;
!*\onslide<11->*!for(int i = 0; i < arr.length; i++)
!*\onslide<12->*!    System.out.println(arr[i]);!*\onslide<1->*!
\end{plainjava}
\endcolumns\medskip
        \item<14-> Java verwaltet Daten auf dem Stack \info{Primitiv} und Heap \info{Komplex} \begin{itemize}
            \item<15-> Java kopiert, vergleicht, schützt, verwirft,\ldots\ Stackelemente
            \item<16-> Bei der Ablage auf dem Heap wird auf dem Stack eine Referenz\\zu diesem Element abgelegt \info{\bjava{null} für die \say{leere} Referenz}
        \end{itemize}
    \end{itemize}
    \onslide<1->
\begin{tikzpicture}[@O]
    \onslide<13->{\draw[Kite-,gray] (@)++(.2,.3) to[out=50,in=230] ++(.45,.3) node[above,T] {Initialisiert automatisch mit \T{\{0, 0, 0, 0, 0\}}};}
    \onslide<17->{\node[above left, yshift=\btdmfootheight] at (current page.south east) {\copy\pinguA};}
\end{tikzpicture}
\end{frame}
}\fi
\SetNextSectionText[.55\linewidth]{We can face our problem. We can arrange such facts as we have with order and method.\\--- Agatha Christie~\cite{chrsitie1934}}
\section{Präsenzaufgabe}
{\setbox\pinguA=\hbox{\tikz{\pingu[devil horns,eyes angry,pants=btdm@primary,wings raise]}}
\setbox\pinguB=\hbox{\tikz{\pingu[devil horns,eyes sad,pants=btdm@primary]}}
\MakeThePinguExplainIt[text width=2.23cm]{cap=!hide,cup=!hide,straw hat,body type=chubby,cake-hat,right item angle=16}{A--Z~\(\widehat{=}\) 65--90\\a--z~\(\widehat{=}\) 97--122}
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Flip-em till 'ya hit-em}
\begin{onlyenv}<2-10|handout:0>%
\onslide<2-10|handout:0>{Implementieren Sie die folgenden zwei Methoden, welche beide ein \bjava{char}-Array als Parameter übernehmen und alle
darin enthaltenen Kleinbuchstaben zu Großbuchstaben, und alle Großbuchstaben zu Kleinbuchstaben machen.} \onslide<3-10|handout:0>{Sie finden die Datei auf unserer Moodle Seite \info{auf Papier genügt es, nur den bei \say{\T{// TODO}} benötigten Code zu schreiben}.}\vspace*{-3mm}
\only<5>{\lstfs{9}}\only<6>{\lstfs{5}\lstset{multicols=2,lineskip=2pt}}
\only<7->{\lstfs{4}\lstset{multicols=2,lineskip=-1pt}}
\begin{plainjava}
!*\onslide<4->*!public class Praesenzaufgabe {
!*\onslide<4->*!    public static void flipInPlace(char[] flipBuchstaben) {
!*\onslide<4->*!        // TODO
!*\onslide<4->*!    }
!*\onslide<4->*!
!*\onslide<4->*!    public static char[] flipInCopy(char[] flipBuchstaben) {
!*\onslide<4->*!        // TODO
!*\onslide<4->*!    }
!*\onslide<4->*!
!*\onslide<4->*!    public static void main(String[] args) {
!*\onslide<4->*!        String s = "DieSeR SatZ HaT EinE merKwüRdige Groß- und KleinschreibunG.";
!*\onslide<4->*!        System.out.println(s);
!*\onslide<4->*!
!*\onslide<4->*!        char[] flipBuchstaben = s.toCharArray();
!*\onslide<4->*!
!*\onslide<4->*!        String inCopy = String.valueOf(flipInCopy(flipBuchstaben));
!*\onslide<4->*!        System.out.println(inCopy);
!*\onslide<4->*!
!*\onslide<4->*!        flipInPlace(flipBuchstaben);
!*\onslide<4->*!        String inPlace = String.valueOf(flipBuchstaben);
!*\onslide<4->*!        System.out.println(inPlace);
!*\onslide<4->*!    }
!*\onslide<4->*!}!*\onslide<1->*!
\end{plainjava}
\onslide<8->{Die erste Methode soll diese Änderungen direkt im übergebenen Array vornehmen, die zweite Methode soll auf einer
Kopie des Arrays arbeiten und diese Kopie dann zurückgeben. Überlegen Sie sich, welche Vor- und Nachteile die
jeweiligen Implementierungen haben.
[TODO: Hinweise, aber das sieht hier ja niemand heheheee]}
\end{onlyenv}
\begin{onlyenv}<11->
\vspace*{-\baselineskip}
    \begin{columns}[onlytextwidth,c]
\column{.3\linewidth}
\small \onslide<12->{Implementieren Sie beide Methoden, welche  alle im übergebenen \bjava{char}-Array enthaltenen Klein- zu Großbuchstaben, und alle Groß- zu Kleinbuchstaben machen.}
\column{.675\linewidth}
\begin{uncoverenv}<13->
\SetupLstHl\lstfs{9}
\begin{plainjava}
public class Praesenzaufgabe {
    public static void
        flipInPlace(char[] c) { /* TODO */ }
    public static char[]
        flipInCopy(char[] c) { /* TODO */ }
    |ihl|public static void main(String[] args) { ... }|ihl|
}
\end{plainjava}
\end{uncoverenv}
\end{columns}
\onslide<14->{\T{flipInPlace} soll diese Änderungen direkt im übergebenen Array vornehmen, \T{flipInCopy} soll auf einer
Kopie des Arrays arbeiten und diese zurückgeben.~}\onslide<15->{Überlegen Sie sich, welche Vor- und Nachteile die
jeweiligen Implementierungen haben.}
\end{onlyenv}
% TODO: Rest, TODO: devil pingu
\end{aufgabe}
\begin{tikzpicture}[@O]
    \only<9|handout:0>{\node[yshift=-2.5cm,above,scale=1.33] at (current page.center) {\copy\pinguA};}
    \only<10|handout:0>{\node[yshift=-2.5cm,above,scale=1.33] at (current page.center) {\copy\pinguB};}
    \onslide<16->{\node[left=-3mm,xshift=7mm,scale=.8,yshift=2mm] at(current page.0) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
}
\iffull
\subsection{Flip in Place}
{\renewcommand\K[2][]{\tikzmarknode{@#2#1}{\snum{\HStrut#2}}}
\begin{frame}[fragile,c]{Flip in Place}
\begin{plainjava}
!*\onslide<2->*!public static void flipInPlace(char[] flipBuchstaben) {
!*\onslide<3->*!    for(int i = 0; i < flipBuchstaben.length; i++) {
!*\onslide<4->*!        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {
!*\onslide<5->*!            flipBuchstaben[i] += !*\K{32}*!;
!*\onslide<4->*!        } !*\onslide<6->*!else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {
!*\onslide<7->*!            flipBuchstaben[i] -= !*\K[b]{32}*!;
!*\onslide<6->*!        }
!*\onslide<3->*!    }
!*\onslide<2->*!}
\end{plainjava}
\begin{tikzpicture}[@O]
    \onslide<8->{
        \foreach \K in {65,90,32,97,122,32b} {
            \node[btdm@primary!70!btdm@background,draw,ellipse,minimum width=6.5mm, minimum height=4.5mm] (@@\K) at (@\K) {};
        }
    }
    \onslide<10->{
        \node[above left=1cm,yshift=1.25cm,T,align=left] (@) at(current page.south east) {Wer soll das mit den Zahlen verstehen?}; % \\Was, wenn es nur von g--s gehen soll?
    }
    \onslide<9->{
        \foreach \K in {65,90,32,97,122,32b} {
            \draw[-Kite,lightgray] (@@\K) to[bend left] (@);
        }
    }
    \onslide<11->{
        \node[below,align=center] at(@.south) {Wir können benannte Konstanten einführen!\\\bjava{public static final int A = 65;}\\\ldots};
    }
\end{tikzpicture}
\end{frame}
\begin{frame}[fragile,c]{Flip in Place with Constants}
\begin{onlyenv}<1|handout:0>
\begin{plainjava}
public static void flipInPlace(char[] flipBuchstaben) {
    for(int i = 0; i < flipBuchstaben.length; i++) {
        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {
            flipBuchstaben[i] += !*\K{32}*!;
        } else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {
            flipBuchstaben[i] -= !*\K[b]{32}*!;
        }
    }
}
\end{plainjava}
\end{onlyenv}
\SetupLstHl
\begin{onlyenv}<2-3|handout:0>
\begin{plainjava}
!*\onslide<3->*!public static final int A = 65;  public static final int a = 97;
!*\onslide<3->*!public static final int Z = 90;  public static final int z = 122;
!*\onslide<3->*!
!*\onslide<1->*!|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {|ihl|
|ihl|            flipBuchstaben[i] += !*\K{32}*!;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {|ihl|
|ihl|            flipBuchstaben[i] -= !*\K[b]{32}*!;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<4|handout:0>
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += !*\K{32}*!;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= !*\K[b]{32}*!;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<5->
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|a - A|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|a - A|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}% copy for animations
\begin{tikzpicture}[@O]
    \onslide<6->{\node[above left=5mm,T,align=center] at(current page.south east) {What, if there would be a better way?\\What, if we want to check only for characters g--m};}
\end{tikzpicture}
\end{frame}
}
\fi
{
    \setbox\pinguA=\hbox{\tikz\pingu[eyes shock,wings shock];}
\begin{frame}[fragile,c]{Flip in Place with Java-Magic}
\SetupLstHl
\begin{onlyenv}<1|handout:0>
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|a - A|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|a - A|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<2|handout:0>
\begin{plainjava}
|ihl|public static final int A = 65;  public static final int a = 97;|ihl|
|ihl|public static final int Z = 90;  public static final int z = 122;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<3-4|handout:0>
\begin{plainjava}
|ihl|public static final int A = |ihl|'A'|ihl|;  public static final int a = 97;|ihl|
|ihl|public static final int Z = 90;  public static final int z = 122;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<5|handout:0>
\begin{plainjava}
|ihl|public static final int A = |ihl|'A'|ihl|;  public static final int a = |ihl|'a'|ihl|;|ihl|
|ihl|public static final int Z = |ihl|'Z'|ihl|;  public static final int z = |ihl|'z'|ihl|;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<6-7|handout:0>
\begin{plainjava}
|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|'A'|ihl| && flipBuchstaben[i] <= |ihl|'Z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|'a' - 'A'|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|'a'|ihl| && flipBuchstaben[i] <= |ihl|'z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|'a' - 'A'|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<8>
\begin{plainjava}
|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
    int shift = 'a' - 'A';
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|'A'|ihl| && flipBuchstaben[i] <= |ihl|'Z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|shift|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|'a'|ihl| && flipBuchstaben[i] <= |ihl|'z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|shift|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{tikzpicture}[@O]
    \onslide<4->{
        \node[above left=5mm,scale=.75] (@) at(current page.south east) {\copy\pinguA};
        \node[T,left=2mm,align=right] at(@.west) {Implizite\\Typkonvertierung!\\\T{char}~$\to$~\T{int}};
    }
    \onslide<7-8|handout:0>{
        \node[above=\btdmfootheight+2mm,T] at(current page.south) {Aber welche Logik steckt hinter \T{'a' - 'A'}?};
    }
\end{tikzpicture}
\end{frame}
}

\subsection{Flip in Copy}
\iffull
\begin{frame}[fragile,c]{Flip in Copy, Na\"\i ve Please}
\begin{center}
    \color{gray}\onslide<2->{There is a \T{clone} for every \cancel{Object} \say{Referenzvariable}}
\end{center}
\begin{onlyenv}<3-7|handout:0>
\begin{plainjava}
!*\onslide<3->*!public static char[] flipInCopy(char[] flipBuchstaben) {
!*\onslide<4->*!    char[] arrayKopie = flipBuchstaben.clone();
!*\onslide<5->*!    int shift = 'a' - 'A'; !*\Snode{@start}*!
!*\onslide<5->*!    for(int i = 0; i < arrayKopie.length; i++) {
!*\onslide<5->*!        if (arrayKopie[i] >= 'A' && arrayKopie[i] <= 'Z')
!*\onslide<5->*!            arrayKopie[i] += shift;
!*\onslide<5->*!        else if (arrayKopie[i] >= 'a' && arrayKopie[i] <= 'z')!*\Snode{@wide}*!
!*\onslide<5->*!            arrayKopie[i] -= shift;
!*\onslide<5->*!    }!*\Snode{@end}*!
!*\onslide<6->*!    return arrayKopie;
!*\onslide<3->*!}
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<8->
\begin{plainjava}
public static char[] flipInCopy(char[] flipBuchstaben) {
    char[] arrayKopie = flipBuchstaben.clone();
    flipInPlace(arrayKopie);
    return arrayKopie;
}
\end{plainjava}
\end{onlyenv}
\begin{tikzpicture}[@O]
    \onslide<7|handout:0>{\draw[decoration=brace,decorate] ([xshift=2mm]@start-|@wide) to[edge node={node[right=1mm] {hmmm\ldots}}] ([xshift=2mm]@end-|@wide);}
    \onslide<9-|handout:0>{
        \node[above=\btdmfootheight+2mm,T] at(current page.south) {Das ist ein weirdes Englisch-Deutsch-Gemisch};
    }
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[fragile,c]{Flip in Copy --- Custom Mode}
\begin{center}
    \color{gray}\onslide<2->{Ich kannte \T{clone} gaaar niiischt. Unnu? Ist das nicht böse?}
\end{center}
\SetupLstHl
\begin{uncoverenv}<3->
\begin{plainjava}
!*\onslide<1->*!|ihl|public static char[] flipInCopy(char[] flipBuchstaben) {|ihl|
!*\onslide<4->*!    char[] arrayKopie = new char[flipBuchstaben.length];
!*\onslide<5->*!    for(int i = 0; i < arrayKopie.length; i++)
!*\onslide<6->*!        arrayKopie[i] = flipBuchstaben[i];

!*\onslide<1->*!    |ihl|flipInPlace(arrayKopie);|ihl|
    |ihl|return arrayKopie;|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{uncoverenv}
\begin{tikzpicture}[@O]
    \onslide<7->{
        \node[above=\btdmfootheight,T,xshift=-3.75cm] at(current page.south) {\strut Werte primitiver Datentypen werden bei Zuweisung kopiert.};

        \only<8->{\node[above left,yshift=\btdmfootheight,T] at(current page.south east) {\strut\textattachfile{\curpath Praesenzaufgabe.java}{Praesenzaufgabe.java}, \textattachfile{\curpath PraesenzaufgabeNaiv.java}{PraesenzaufgabeNaiv.java}\;};}
    }
\end{tikzpicture}
\end{frame}

\subsection{Allgemeine Fragen}
\begin{frame}{Allgemeines}
    \begin{itemize}[<+(1)->]
        \itemsep13pt
        \iffull\item \T{Clone} widmen wir uns gleich nochmal\ldots\fi
        \item \task{Überlegen Sie sich, welche Vor- und Nachteile die jeweiligen Implementierungen haben.}
        \begin{itemize}[<+(1)->]
            \itemsep4.5pt
            \item Vorteile einer Kopie \info{gegenüber in-place}: Nebeneffekte von Methoden sind generell schlecht! \say{out-Parameter} sollten vermieden werden (wo nicht unbedingt notwendig).
            \item Nachteile einer Kopie \info{gegenüber in-place}: Der benötigte Speicher wird verdoppelt (was, wenn das Array riesig ist?)
        \end{itemize}
        \item Was ist nun besser?
                \begin{itemize}
                    \itemsep4.5pt
                    \item In der Regel die Variante mit Kopie. Die unerwarteten/ungewollten Seiteneffekte können Kaskaden schwer zu findender Fehler verursachen.
                    \item Sollten wirklich große Arrays erwartet werden, sollte man sich unter Umständen ein grundlegend anderes System überlegen.
                \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Alternativen?}
    \begin{itemize}[<+(1)->]
        \item Hätte man hier auch \say{for-each} für flip in place nutzen können?\vspace*{-1mm}
\begin{plainjava}
!*\onslide<3->*!for(int i = 0; i < flipBuchstaben.length; i++) {
!*\onslide<3->*!    if ('A' <= flipBuchstaben[i] && flipBuchstaben[i] <= 'Z') {
!*\onslide<3->*!        flipBuchstaben[i] += shift;
!*\onslide<3->*!    } else if ('a' <= flipBuchstaben[i] && flipBuchstaben[i] <= 'z') {
!*\onslide<3->*!        flipBuchstaben[i] -= shift;
!*\onslide<3->*!    }
!*\onslide<3->*!}!*\onslide<1->*!
\end{plainjava}
    \item<4-> Nein, so könnten wir nicht mehr \bjava{flipBuchstaben} an der Stelle \T{i} verändern.
    \item<5-> Mit \bjava{for(char c : flipBuchstaben)} ist \T{c} jeweils eine Kopie \info{primitiver Datentyp} und nicht mehr eine Referenz auf die Stelle im Array!
    \end{itemize}
\end{frame}

\iffull
\SetNextSectionText[.55\linewidth]{Have you ever heard the tragedy of Darth Clon\textbf{e}able the wise? Well, then prepare yourself for\ldots\ something at least.\\--- Florian}
\section{Clone-Wars}
\fi
{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{1.5em}\centering
\begin{tikzpicture}[@O]
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{\pingu[eyes wink]}
    \only<3|handout:0>{\pingu[right wing grab, lightsaber right, lightsaber right disabled]}
    \only<4|handout:0>{\pingu[right wing grab, eyes angry, lightsaber right=purple]}
    \only<5|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple]}
    \only<6|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,right item angle=-70],bill angry}
    \only<7|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70],bill angry}
    \pgfonlayer{background}
    \only<9->{\node[white!14!black,scale=9] at(current page.center) {\Large\textsc{clone}};}
    \endpgfonlayer
    \only<8-9|handout:0>{\pingu[right wing grab, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70,bill angry,right item angle=-80,lightsaber right yshift=-.45mm]}
    \only<10->{\pingu[right wing grab, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70,bill angry,right item angle=-80,lightsaber right yshift=-.45mm,left eye devil]}
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}
{
\iffull
\AddonFrame
\begin{frame}[t,fragile]{Die Object Klasse}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item \bjava{Object} ist die Klasse, welche die grundlegenden Eigenschaften für jede andere Klassen zur Verfügung stellt.
        \item Wir werden sie später im Rahmen von Vererbung genauer kennen lernen.\par
            Bis da hin: \bjava{toString} stammt beispielsweise dort her.
        \item Diese Klasse \bjava{Object} liefert auch die Methode \bjava{clone}, die auf jedem Objekt aufgerufen werden kann\pause\ldots\pause{} \ldots\pause{} \ldots
        \item \bjava{clone} muss aber von jeder Klasse selbst und individuell implementiert werden, wenn es denn unterstützt werden soll.
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Kopien}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Da die Variable eines Objekts in Java nur eine Referenz auf das eigentliche Objekt enthält, erzeugen wir durch den folgenden Code \textit{keine} Kopie:\pause{}
\begin{plainjava}
Scanner a = new Scanner(System.in);
Scanner b = a;
\end{plainjava}
        \item Oft stellen sich auch Fragen wie:
         \begin{itemize}
            \itemsep6pt
             \item Was soll kopiert werden?
             \item Funktioniert eine Kopie überhaupt?
             \item Was ist, wenn das zu kopierende Objekt selbst wieder (zum Beispiel in den Attributen) Referenzen auf andere Objekte enthält?
             \item Was, wenn diese Referenzen zirkulär sind?
         \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Kopie-Varianten}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Deswegen unterscheiden wir zwei Arten von Kopien: \textit{shallow} und \textit{deep}.
            \infoblock{Genau genommen gibt es noch viel mehr, wie zum Beispiel \textit{lazy}, aber das soll uns hier nicht weiter stören.}
        \item Eine \textit{shallow copy} kopiert \say{so wenig wie möglich}. Oder auch nur \say{die erste Hierarchieebene.}
        \item Eine \textit{deep copy} kopiert das komplette Objekt, sowie alle Objekt-Referenzen die dieses Objekt wieder besitzt und so weiter.
        \item Während shallow copies meist von Hand geschrieben werden,\pause{} wird eine deep copy meistens durch (De-)Serialisierung gelöst.\pause{}\infoblock{Sonst müssten bei einer deep copy auch alle vom Objekt verwendeten Ressourcen wieder deep-copyable sein.\pause{} Das Verfahren hat allerdings ebenfalls Nachteile. Stichwort: \solGet{keywordA}{\link{https://docs.oracle.com/en/java/javase/17/jfapi/exclude-fields-being-persisted-transient-keyword.html}{transient}}.}
    \end{itemize}
\end{frame}

\begingroup
\lstset{add to literate={X}{{{\solGet{keywordC}{X}}}}1 {Y}{{{\solGet{keywordC}{Y}}}}1 {Z}{{{\solGet{keywordC}{Z}}}}1}
\begin{frame}[t,fragile]{Kopien, ein Beispiel}
    \begin{itemize}[<+(1)->]
        \item Betrachten wir die folgende Klasse (\bjava{Y} und \bjava{Z} seien ebenfalls gegeben):\pause
\begin{plainjava}
class X {
    int a;
    Y y;
    Z z;
}
\end{plainjava}
        \item Eine \textit{shallow copy} würde ein neues \bjava{X}-Objekt erzeugen und die Attribute durch \say{\bjava{=}} zuweisen.\pause{} Damit wird \bjava{a} kopiert, \bjava{y} und \bjava{z} referenzieren aber (je) dasselbe Objekt.
        \item Eine \textit{deep copy} würde rekursiv auch neue Objekte von \bjava{Y} und \bjava{Z} erzeugen.\pause{} \infoblock{Quizfrage: was passiert oder besser, was kann alles passieren, wenn \bjava{Y} wieder eine Referenz auf \bjava{X} enthält?}
        \item Und was davon macht jetzt \bjava{Object::clone()}?\pause{} Spoiler: Nobody knows.
    \end{itemize}
\end{frame}
\endgroup

\begin{frame}[t,fragile]{Cloneable}
    \begin{itemize}[<+(1)->]
        \itemsep8pt
        \item Das Interface Cloneable \textit{fordert nichts} von einer gegebene Klasse.
        \item Es ist ein sogenanntes \say{Marker} interface.\pause{} Wer es implementiert, sorgt dafür, dass gewisse Methoden sich einem gewissen Vertrag unterwerfen.\smallskip\pause\par\infoblock{Diese Erklärung ist an sich nachträglich entstanden. Die komplette Geschichte um das \bjava{Cloneable}-Interface ist eine einzige Tragödie.}
        \item Aus der \link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Cloneable.html}{Java-Dokumentation} \info{\say{contract}}:\par\pause
        \textit{\textcolor{codeouthl}{[}\ldots\textcolor{codeouthl}{]}~Note that this interface does not contain the clone method.
        Therefore, it is not possible to clone an object merely by virtue of the
        fact that it implements this interface. \onslide<+(1)->{Even if the clone method is invoked \link{https://www.oracle.com/technical-resources/articles/java/javareflection.html}{reflectively}, there is no guarantee that it will succeed. \textcolor{codeouthl}{[}\ldots\textcolor{codeouthl}{]}}}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Cloneable, Schadensbericht}
    \begin{itemize}[<+(1)->]
        \itemsep9pt
        \item Das Interface widerspricht der sonstigen Schreibweise.\pause{} \info{Clonable vs. Cloneable.}
        \item Es fordert nichts und kann theoretisch von jeder Klasse implementiert werden.
        \item Es liefert keine weiteren Informationen über die Kopie.
        \item Es stellt keine Anforderungen an die Java-Syntax (Sichtbarkeit), die nicht gleichermaßen geprüft werden können.
        \item Der Rückgabewert der \bjava{Object::clone}-Methode ist stets \bjava{Object}, wir brauchen also einen expliziten Cast.\pause{} \info{Beispielsweise bei \bjava{(Date) birthday.clone()}.}
        \item \ldots\pause{} \ldots\pause{} \ldots
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Long story short}
    \begin{itemize}[<+(1)->]
        \itemsep12pt
        \item Manche Java Klassen implementieren \bjava{Cloneable} korrekt.\pause{} \info{Wie \bjava{Date}.}
        \item Bei Arrays sind die Kopien mit \bjava{clone} immer \textit{shallow}.
        \item Ansonsten haben sich andere Prinzipien durchgesetzt. So beispielsweise Copy-Konstruktoren.
        % \item Diesen werden noch später im Semester begegnen.
    \end{itemize}
\end{frame}
}

{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{4.5em}\centering
\begin{tikzpicture}
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm]
        \pingu[xshift=3cm,yshift=.5cm]
        \pingu[]
    }
    \only<3|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right, lightsaber right disabled,eyes wink]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left, lightsaber left disabled,eyes wink]
        \pingu[right wing grab, lightsaber right, lightsaber right disabled, eyes shiny,left wing wave, lightsaber left, lightsaber left disabled,right item angle=-80,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \only<4->{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right=orange,eyes wink]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left=orange,eyes wink]
        \pingu[right wing grab, lightsaber right=pingu@blue, eyes shiny,left wing wave, lightsaber left=green,right item angle=-80,lightsaber right double,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}
\fi

\SetNextSectionText{Schleifen, Arrays, Methoden\\Abgabe: \DTMDate{2022-05-23}}
\section{Übungsblatt 4}
\subsection{Aufgabe 1}
{\taskenum
\begin{frame}[fragile]{Aufgabe 1: Referenzvariablen}
\task<2->{Betrachten Sie den folgenden Java Code~(\only<2->{\textattachfile{\curpath Referenzvariablen.java}{Referenzvariablen.java}}):}\vspace*{-4mm}
\lstfs{8}
\begin{plainjava}[multicols=2,lineskip=-.5pt,prebreak={},numbers=left,numbersep=2pt]
public class Referenzvariablen {
  public static void setzeElementVielleicht(int[] array, int idx, int ele) {
    if (array == null || idx >= array.length || ele <= 0) {
      System.out.println("Eingabe ungültig!");
      return;
    }
    array[idx] = ele;
    ele = 4;
    array = null;
  }

  public static void main(String[] args) {
    int ele = 1;
    int idx = ele;
    ele = 2;
    int[] array = new int[3];
    setzeElementVielleicht(array, idx, ele);
    System.out.println(ele);
    System.out.println(idx);
    if (array != null) {
      for (int wert : array) {
        System.out.println(wert);
      }
    } else {
      System.out.println("Array ungültig!");
    }
  }
}
\end{plainjava}
\vspace*{-4mm}\begin{enumerate}
    \item<3-> \task{Welche Ausgaben erzeugen die Zeilen~18 und~19? Begründen Sie Ihre Antwort.}
    \item<4-> \task{Welche Ausgaben erzeugen die Zeilen~20--26? Begründen Sie Ihre Antwort.}
\end{enumerate}
\end{frame}
{\def\n{\textcolor{codeouthl}{\textbackslash n}\,}
\def\Z#1;{\textit{Z#1}}
\begin{frame}{Ein schneller Blick auf knappe Antworten}
\begin{enumerate}[<+(1)->]
    \itemsep10pt
    \item {\intask Welche Ausgaben erzeugen die Zeilen~18 und~19?}\hfill\pause\Z18; liefert~2, und~\Z19;~1.\smallskip\\*
    Zuerst die Ausgabe von \T{ele}, dieses wird in~\Z13; mit~1 initialisiert und in~\Z15; mit~2 überschrieben. \pause Der Parameter \T{ele} in~\Z2; besitzt einen anderen Sichtbarkeits- und Gültigkeitsbereich, zudem wird der Wert durch \textit{Call-by-Value} kopiert. Damit hat das Unterprogramm keinen Einfluss auf den wert in \T{ele} aus \T{main}. \pause Auf \T{ele} findet kein weiterer Zugriff statt, es ist~2.\smallskip\par\pause
    Analog argumentiert es sich für \T{idx}, welches in~\Z14; mit dem dortigen Wert von \T{ele} (ist~1) initialisiert wird (da es ein primitiver Datentyp ist, wird hier auch mit \textit{Call-by-Value} der Wert kopiert). \pause Anschließend findet kein verändernder Zugriff statt und \T{idx} ist~1.
    \item \task{Welche Ausgaben erzeugen die Zeilen~20--26?}\par
    \pause Sie erzeugen \say{\T{0\n2\n0}} \info{wobei \T{\textbackslash n} ein neue Zeile darstellt}.\\*
\end{enumerate}
\end{frame}

\begin{frame}{Ein schneller Blick auf knappe Antworten\hfill II}
\begin{enumerate}[<+(1)->]
    \itemsep10pt
    \item {\intask Welche Ausgaben erzeugen die Zeilen~18 und~19?}\hfill\Z18; liefert~2, und~\Z19;~1.
    \item \task{Welche Ausgaben erzeugen die Zeilen~20--26?}\par
    \pause Sie erzeugen \say{\T{0\n2\n0}} \info{wobei \T{\textbackslash n} ein neue Zeile darstellt}.\smallskip\\*
    \pause Die Zielen befassen sich mit der Ausgabe von \T{array}. Dieses wird in~\Z16; Java initialisiert hier direkt mit \bjava{\{0, 0, 0\}}. \pause Das Unterprogramm erfüllt nun in~\Z2; die Referenz zu \T{array} als Kopie \info{das ist \textit{Call-by-Value}, verhält sich aber wie \textit{Call-by-Reference}}, \pause das \bjava{if} in~\Z3; scheitert, da \T{array} auf \bjava{\{0, 0, 0\}}  verweist und \bjava{idx = 1}, \bjava{ele = 2} (aus vorheriger Antwort). \pause
   \Z7; ändert damit das gemeinsame Array zu \bjava{\{0, 2, 0\}} \info{Seiteneffekt}, die Neuzuweisung in~\Z9; überschreibt lediglich die in den Parameter kopierte Referenz. \pause
    Damit löst das \bjava{if} in~\Z20; aus und es erfolgt besagte Ausgabe.
\end{enumerate}
\end{frame}
}
}
\iffull
{\AddonFrame
\begin{frame}{Heap und Stack\ldots\ Again}
    \begin{itemize}
        \itemsep12pt
        \item Das könnte man jetzt aufwändig durchanimieren\ldots
        \item Ich möchte aber, das ihr das zur Übung macht!
        \item Wählt einen beliebigen \info{sinnvollen} Punkt im Programmablauf aus und zeichnet Heap- und Stack zu diesem Zeitpunkt \begin{itemize}
            \item Am Besten im Unteralgorithmus
            \item Wie werden wohl \say{mehrdimensionale} Arrays dargestellt?
        \end{itemize}
        \item Hier zeige ich gleich die Animation eines anderen Codes \info{als Hilfe}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Sprechen über Signaturen}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \itemsep6pt
    \item Wie unterscheidet Java Methoden?\quad\pause Durch ihre Signatur!\quad\pause Und was ist das?
    \item Der Name und die Parametertypliste!\quad \info{\link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html\#jls-8.4.2}{JLS17~$8.4.2$}}
    \item Der Rückgabetyp ist zum Beispiel \textit{kein Teil} \info{Hust hust \link{https://docs.microsoft.com/en-us/dotnet/standard/base-types/common-type-system\#methods}{CLR}}
    \item Betrachten wir ein Beispiel:
\begin{plainjava}[aboveskip=0pt]
!*\onslide<8->*!public String foo(int i, double[] dubletti, boolean b) {
!*\onslide<9->*!    |ihl|...|ihl|
!*\onslide<8->*!}
\end{plainjava}
    \item Die Signatur lautet \say{\bjava{foo(int, double[], boolean)}}
    \item Das werden wir in Zukunft weiter behandeln und einbetten!
\end{itemize}
\end{frame}

% \paragraph{Eine alte Heap-Stack-Freude}
\makeatletter
\lhns@elemwidth3cm
\lhns@minborderheight8cm
\makeatother
\newcommand<>\lm[1][]{\only#2{#1\llap{\faAngleRight~}}}
\newcommand<>\rm[1][]{\only#2{#1\rlap{~\faAngleLeft}}}
\begin{frame}[c,fragile]{Der Swap-Stack-Heap-Durchlauf}
\vspace*{-.3\topsep}\begin{columns}[onlytextwidth,c]
\lstfs{8}\column{.6\linewidth}
\begin{plainjava}[lineskip=1pt]
!*\onslide<2->*!public class SwapFunction {
!*\onslide<2->*!    !*\lm<10|handout:0>*!public static void swap(int a, int b) {
!*\onslide<2->*!        !*\lm<11|handout:1>*!int tmp = b; b = a; a = tmp;
!*\onslide<2->*!    }!*\medskip*!
!*\onslide<2->*!    !*\lm<15-16|handout:3>*!public static void swap(int[] a, int[] b) {
!*\onslide<2->*!        !*\lm<17|handout:0>*!if(a.length != b.length) return;
!*\onslide<2->*!        !*\lm<18,21,23,25|handout:0>*!for(int i = 0; i < a.length; i++) {
!*\onslide<2->*!            !*\lm<19-20,22,24|handout:0>*!int tmp = b[i]; b[i] = a[i]; a[i] = tmp;
!*\onslide<2->*!        }!*\lm<26|handout:4>[~~]*!
!*\onslide<2->*!    }!*\medskip*!
!*\onslide<2->*!    !*\lm<3|handout:0>*!public static void main(String[] args) {
!*\onslide<2->*!        !*\lm<4|handout:0>*!int a = 21; int b = 42;
!*\onslide<2->*!        !*\lm<5-6|handout:0>*!int[] c = {1, 2, 3};
!*\onslide<2->*!        !*\lm<7|handout:0>*!int[] d = {4, 5, 6};
!*\onslide<2->*!        !*\lm<8-9|handout:0>*!swap(a, b);!*\rm<12|handout:2>*!!*\onslide<9|handout:1>*! // :yields: swap(int, int)
!*\onslide<2->*!        !*\lm<13-14|handout:0>*!swap(c, d);!*\rm<27|handout:0>*!!*\onslide<14|handout:3>*! // :yields: swap(int[], int[])
!*\onslide<2->*!    }
!*\onslide<2->*!}
\end{plainjava}
\column{.4\linewidth}
\vspace*{-\baselineskip}\centering
\downsize\linewidth{\begin{tikzpicture}[lhns@basestyle/.append style={execute at begin node=\strut,font=\ttfamily},lhns@blockstyle/.append style={draw=gray,thick}]
\begin{heap-n-stack}{}

\heap{\only<-5|handout:0>{-heapland-}\only<6->{\,\{\only<-19|handout:-3>{1}\only<20-|handout:4->{4}, \only<-21|handout:-3>{2}\only<22-|handout:4->{5}, \only<-23|handout:-3>{3}\only<24-|handout:4->{6}\}}}
\only<7->{\heap{\,\{\only<-19|handout:-3>{4}\only<20-|handout:4->{1}, \only<-21|handout:-3>{5}\only<22-|handout:4->{2}, \only<-23|handout:-3>{6}\only<24-|handout:4->{3}\}}}
\renderheap

\only<3->{\stack{\textbf{main}}}
\only<4->{\stack{a = 21}}
\only<4->{\stack{b = 42}}
\only<5->{\stack{c}}
\only<7->{\stack{d}}
\only<10-11|handout:1>{\stack{\small\textbf{swap(int, int)}}
\stack{a = \only<10|handout:0>{21}\only<11>{42}}
\stack{b = \only<10|handout:0>{42}\only<11>{21}}
\only<11>{\stack{tmp = 42}}}
\only<15-26|handout:3>{\stack{\scriptsize\textbf{swap(int[], int[])}}
\stack{a}
\stack{b}
\only<16->{\draw[lhns] (stack-6.east) -- ++(.5,0) to[out=0,in=180] (heap-0.west);
\draw[lhns] (stack-7.east) -- ++(.5,0) to[out=0,in=192] (heap-1.west);}
}
\only<18-25|handout:0>{\stack{i = \only<18-20|handout:0>{0}\only<21-22|handout:0>{1}\only<23-24|handout:0>{2}\only<25|handout:0>{3}}}
\only<19-20,22,24|handout:0>{\stack{tmp = \only<19-20>{4}\only<22>{5}\only<24>{6}}}
\renderstack

\only<6->{\draw[lhns] (stack-3.east) to[out=0,in=180] (heap-0.west);}
\only<7->{\draw[lhns] (stack-4.east) to[out=0,in=180] (heap-1.west);}

\end{heap-n-stack}
\end{tikzpicture}}
\end{columns}
\end{frame}
}
\fi

\subsection{Aufgabe 2}
{\taskenum
\begin{frame}{Aufgabe 2: Mehrdimensionale Arrays}
    \task<2->{Im Folgenden sollen Methoden zum Verarbeiten von mehrdimensionalen Arrays (Matrizen) implementiert werden.
    Legen Sie dazu eine Java Datei \T{Matrix.java} an.
    Im Folgenden sei~\(n\) die Anzahl der Zeilen,~\(m\) die Anzahl der Spalten,~\(i\) und~\(j\) die jeweiligen Indizes, sowie \(a_{ij}\) das Element in der \(i\)-ten Zeile und \(j\)-ten Spalte. Die \link{https://de.wikipedia.org/wiki/Zeilensummennorm}{Zeilensummennorm} ist in der Mathematik die von der Summennorm abgeleitete natürliche Matrixnorm. Die Zeilensummennorm \(\dist{A}_\infty\) einer Matrix~\(A\) entspricht der maximalen Betragssumme aller ihrer Zeilen:\nomathskip
\begin{columns}[onlytextwidth,c]
\column{.3\linewidth}
\begin{equation*}
    \dist{A}_\infty =\max_{i = 1, \ldots, n} \sum_{j = 1}^n \abs{a_{ij}}
\end{equation*}
\column{.7\linewidth}
\textbf{Beispiel:} Die Zeilensummennorm der Matrix~\(A = \left(\begin{smallmatrix}
    1 & -2 & -3 \\
    2 & 4 & -1
\end{smallmatrix}\right)\) is gegeben durch \(\dist{A}_\infty = \max\{\abs{1} + \abs{-2} + \abs{-3},\;\allowbreak \abs{2} + \abs{4} + \abs{-1}\} = \max\{6, 7\} = 7\).
\end{columns}
\begin{enumerate}
    \item \label{tsk:a}Legen Sie ein 2-D Array mit~\(3 \times 3\) Elementen vom Typ double an und füllen Sie es mit gültigen Werten.
    \item Implementieren Sie eine Methode \T{public static double berechneBetragssumme(double[] arr)}, die die Betragsnorm von \T{arr}, d.h. die Summe der Beträge der Elemente, berechnet und zurückgibt. Für ungültige Eingaben (\T{arr} ist \T{null} oder hat die Länge~\(0\)) soll \T{-1.0} zurückgegeben werden.
    \item \label{tsk:c}Implementieren Sie eine Methode \T{public static double berechneZeilensummennorm(\allowbreak double[][] \allowbreak mat)}, die ein 2-D Array als Argument annimmt, die Zeilensummennorm berechnet und diese zurückgibt. Für ungültige Eingaben (mat ist null oder hat die Länge~\(0\)) soll \T{-1.0} zurückgegeben werden.
    \item Rufen Sie die Methode aus Teilaufgabe~\ref{tsk:c} mit ihrer Matrix aus und geben Sie das Ergebnis auf die Konsole aus.
\end{enumerate}
}
\end{frame}
}

\begin{frame}[fragile]{a)~Ein Array Anlegen}
\SetupLstHl
\begin{itemize}[<+(1)->]
    \itemsep8pt
    \item Hier mal etwas beliebiges
\begin{plainjava}[aboveskip=0pt]
!*\onslide<3->*!double[][] matrix = { { 1.5, -2, 1 }, { -5, 1, 6.1 }, { -2, -4, 1 } };
\end{plainjava}
    \item<4-> Hier haben wir übrigens~--- Java sei dank~--- stark abgekürzt:
\begin{plainjava}[aboveskip=0pt]
!*\onslide<5->*!double[][] matrix = new double[][] { new double[] { |ihl|:ldots:|ihl| }, |ihl|:ldots:|ihl| };
\end{plainjava}
    \item<6-> Quiz! Sind diese Statements gültig? Wenn ja, welchen Wert hat \T{m1}, \T{m2},~\ldots? \info{Warum?}
\begin{plainjava}[aboveskip=0pt,lineskip=3pt]
!*\onslide<7->*!double[][] m1; !*\Snode{@1}*!
!*\onslide<9->*!double[][] m2 = new double[][]; !*\Snode{@2}*!
!*\onslide<11->*!double[][] m3 = new double[2][]; !*\Snode{@3}*!
!*\onslide<13->*!int[][]:ws::ws::ws::ws:m4 = new int[1][3]; !*\Snode{@4}*!
!*\onslide<15->*!double[][] m5 = { null, {}, { null } }; !*\Snode{@5}*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[@O]
\onslide<8->{\node[T,right=-1pt,scale=.9] at(@1.east) {\faCheck~\T{m1} ist noch nicht initialisiert};}
\onslide<10->{\node[T,right=-1pt,align=left,scale=.9] at(@2.east) {\faFlash~Java \textup{muss} das Array initialisieren~\(\to\) braucht dessen Größe};}
\onslide<12->{\node[T,right=-1pt,scale=.9] at(@3.east) {\faCheck~\T{m3} ist \T{\{ null, null \}} (Default-Wert für \T{double[]})};}
\onslide<14->{\node[T,right=-1pt,scale=.9] at(@4.east) {\faCheck~\T{m4} ist \T{\{\;\{ 0, 0, 0 \}\;\}} (Default-Wert für \T{int})};}
\onslide<16->{\node[T,below right,xshift=-1pt,yshift=.6\baselineskip,align=left,scale=.9] at(@5.east) {\faFlash~\T{null} und \T{\{\}} \info{leer} sind valide \T{double[]},\\\phantom{\faFlash}~\T{\{ null \}} aber nicht, da \T{double} nicht \T{null}\\\phantom{\faFlash}~sein kann.};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{b)~\T{\bfseries berechneBetragssumme(double[])}}
\begin{plainjava}[lineskip=2pt]
!*\onslide<2->*!public static double berechneBetragssumme(double[] arr) {
!*\onslide<3->*!    if (arr == null || arr.length == 0) {
!*\onslide<4->*!        System.out.println("Eingabe ungültig!");
!*\onslide<4->*!        return -1.0;
!*\onslide<3->*!    }
!*\onslide<5->*!    double norm = 0;
!*\onslide<6->*!    for (double element : arr) {
!*\onslide<7->*!        norm = norm + Math.abs(element);
!*\onslide<6->*!    }
!*\onslide<8->*!    return norm;
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[fragile,c]{c)~\T{\bfseries berechneZeilensummennorm(double[][])}}
\begin{plainjava}[lineskip=2pt]
public static double berechneZeilensummennorm(double[][] mat) {
    if (mat == null || mat.length == 0) {
        System.out.println("Eingabe ungültig!");
        return -1.0;
    }
    double max = Double.MIN_VALUE;
    for (double[] array : mat) {
        double norm = berechneBetragssumme(array);
        if (norm == -1.0):ws::ws::ws::ws::ws:return -1.0; // Fehler in Unteralgorithmus?
        else if (norm > max) max = norm;
    }
    return max;
}
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{d)~Ausgabe}
\begin{itemize}[<+(1)->]
    \itemsep8pt
    \item Ein super kompliziertes Aufrufchen \info{für zwei Punkte!}:
\begin{plainjava}[aboveskip=0pt]
!*\onslide<3->*!System.out.println(berechneZeilensummennorm(matrix));
\end{plainjava}
    \item<4-> Der gesamte Code findet sich in der Datei \only<4->{\textattachfile{\curpath Matrix.java}{Matrix.java}}
    % \item     TODO: daruaf eingehen ob es besser ist in for ouder außerhalb von for zu initialisiern
    \item Und wie wechseln wir die Funktion nun einfach aus? \begin{itemize}
        \item Mit EidI-Wissen eher weniger
        \item Aber \link{https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html}{Lambdas} sind hier hilfreich!
    \end{itemize}
\end{itemize}
\end{frame}

\subsection{Aufgabe 3}
\begin{frame}{Aufgabe 3: Numerische Integration}
\task<2->{In dieser Aufgabe sollen Sie ein einfaches Verfahren zur numerischen Integration implementieren. Legen Sie dazu eine Java Datei namens \T{NumerischeIntegration.java} an und implementieren Sie alle folgenden Teilaufgaben innerhalb dieser Datei. \onslide<3->{Die Funktion \(f(x) = \exp(-x^2)\) besitzt \link{https://www.wolframalpha.com/input?i=integral+e\%5E\%28-x\%5E2\%29+from+0+to+1}{keine Stammfunktion bestehend nur aus elementaren Funktionen}, was eine Berechnung schwierig macht. Man ist jedoch an guten Approximationen interessiert. Wir beschränken uns auf das Intervall \([0, 1]\), suchen also möglichst genaue Approximationen für das folgende Integral: \(A_f = \int_0^1 \exp(-x^2) \mathrm{d}x\)}\medskip% no \d here :D

\onslide<4->{Eine bekannte Methode ist die Approximation des Integrals durch eine Summe von Trapezflächen. Dazu zerlegt man das Intervall \([0, 1]\) in \(n \geq 1\) Segmente~\([x_i, x_{i + 1}]\) mit \(9 = x_1 < x_2 < \ldots < x_{n - 1} < x_n = 1.\)}\medskip

\onslide<5->{Die Fläche auf dem Intervall~\([x_i, x_{i + 1}]\) erhält man dann durch ein Trapez mit Eckpunkten \(a = (x_i, 0)\), \(b = (x_{i + 1}, 0)\), \(c = (c_{i + x}, f(x_{i + 1}))\) und \(d = (x_i, f(x_i))\). Die Fläche \(A_i\) eines derartigen Trapezes kann für \(x_{i + 1} \geq x_i\) durch \(A_i = (x_{i + 1} - x_i) \bigl(f(x_i) + f(x_{i + 1})\bigr) / 2\) berechnet werden. Die Approximation des Integrals ergibt sich dann durch Summierung der einzelnen Trapezflächen: \(A_f \approx A_f(n) = \sum_{i = 1}^n A_i.\)}
}
% TODO grafik?
\end{frame}

\begin{frame}[fragile]{a)~Daten Einlesen und b)~\T{\bfseries berechneF(double)}}
    \begin{itemize}[<+(1)->]
        \item Das Einlesen erfolgt hier leicht:
\begin{plainjava}[aboveskip=0pt]
!*\onslide<3->*!int n = Integer.parseInt(args[0]);
\end{plainjava}
        \item Ein \link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html}{Scanner} kann hier theoretisch auch möglich sein \begin{itemize}
            \item Den wollen wir dann aber auch immer schließen!
            \item Uns reichen Kommandozeilenparameter
        \end{itemize}
        \item Und nun noch berechnen \info{\(f(x) = \exp(-x^2)\)}:
\begin{plainjava}
!*\onslide<8->*!public static double berechneF(double x) {
!*\onslide<9->*!    return Math.exp(-(x*x));
!*\onslide<8->*!}
\end{plainjava}
        \item<10-> Natürlich kann man hier auch \bjava{Math.pow(x, 2.0)} oder so benutzen
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{c)~\T{\bfseries berechneTrapezFlaeche(double, double)}}
    \begin{itemize}[<+(1)->]
        \item Ein ungültiger Eckpunkt liegt vor, wenn \(x_2 < x_1\):
\begin{plainjava}
!*\onslide<3->*!public static double berechneTrapezFlaeche(double x1, double x2) {
!*\onslide<4->*!    if(x2 < x1)
!*\onslide<5->*!        return 0;
!*\onslide<4->*!    else
!*\onslide<6->*!        return (x2 - x1) * ((berechneF(x1) + berechneF(x2)) / 2.0);
!*\onslide<3->*!}
\end{plainjava}
        \item Auch hier handelt es sich um unspektakuläres übernehmen der Aufgabenstellung
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{d)~\T{\bfseries trapezVerfahren(int)}}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item Wir können hier über die Schritte (\(i < n\)) oder über \T{x} terminieren.\infoblock{Das Verhalten Umsetzung unterscheidet sich bei Rundungsfehlern!}
\begin{plainjava}
!*\onslide<3->*!public static double trapezVerfahren(int n) {
!*\onslide<4->*!    if (n < 1) {
!*\onslide<5->*!        System.err.println("Eingabe ungültig");
!*\onslide<6->*!        return -1.0;
!*\onslide<4->*!    }
!*\onslide<7->*!    |ihl|...|ihl|
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\end{frame}


\savebox\codebox{\SetupLstHl\LstBoardStyle\topsep0pt\lstfs{9}\begin{minipage}{11.33cm}
\begin{plainjava}^^J
for(double x = 0; x <= 1 - schrittweite; x += schrittweite) \{^^J
:ws::ws::ws::ws:|ihl|...|ihl|^^J
\}^^J
\end{plainjava}
\end{minipage}}
\MakeThePinguExplainIt[text width=11.33cm]{cap=!hide,headphones,glasses=!hide,cup=!hide,sunglasses,eyes hearts,body type=chubby,lollipop left,right item angle=-52}{Auch möglich wäre soetwas:\\\copy\codebox}
\begin{frame}[fragile,c]{d)~\T{\bfseries trapezVerfahren(int)}\hfill II}
\SetupLstHl
\begin{plainjava}
!*\onslide<1->*!public static double trapezVerfahren(int n) {
!*\onslide<1->*!    |ihl|...|ihl|
!*\onslide<2->*!    double schrittweite = 1.0 / n; !*\Snode{@1}*!
!*\onslide<3->*!    double x = 0.0;
!*\onslide<4->*!    double A = 0.0;
!*\onslide<5->*!    while (x <= 1.0 - schrittweite) {
!*\onslide<6->*!        A = A + berechneTrapezFlaeche(x, x + schrittweite);
!*\onslide<7->*!        x = x + schrittweite;
!*\onslide<5->*!    }
!*\onslide<8->*!    return A;
!*\onslide<1->*!}
\end{plainjava}
\begin{tikzpicture}[@O]
    \onslide<9->{\node[left=-4mm,xshift=4mm,scale=.8,yshift=\btdmfootheight] at(current page.-27) {\copy\pinguexplainbox};}% copy for animations
    \onslide<10->{
        \node[right,T] (@) at(@1.east) {Ginge hier auch nur \T{1/n}?};
    }
    \onslide<11->{
        \node[below right,yshift=1mm,T] at(@.south west) {Nö, dann wäre das mit \(\text{\T{n}} > 1\) immer 0 (da Ganzzahldivison).};
    }
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{e)~\T{\bfseries Ausgabe}}
\begin{itemize}[<+(1)->]
    \item Wieder eine fancy Ausgabe!
\begin{plainjava}
!*\onslide<3->*!System.out.println(trapezVerfahren(n));
\end{plainjava}
    \item Der gesamte Code befindet sich hier:~\only<4->{\textattachfile{\curpath NumerischeIntegration.java}{NumerischeIntegration.java}}
\end{itemize}
\end{frame}

\iffull
\SetNextSectionText{Methoden und OOP\\Abgabe: \DTMDate{2022-05-30}}
\section{Aussicht: Übungsblatt 5}
\subsection{Aufgabe 1 und 2}
\begin{frame}{Aufgaben 1\; und 2}
\begin{itemize}[<+(1)->]
    \itemsep9pt
    \item Hier helfen \link{https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html}{varargs}! \begin{itemize}
        \item Einfach nur Arrays aber in \info{un-}gruselig!
        \item Und in Punktig! \info{Hier driftet Müde-Flo wohl ein bisschen ab\ldots}
    \end{itemize}
    \item Sonst haben wir ja schonmal was mit einer Quersumme gemacht \info{Übungsblatt~3, Aufgabe~3}
    \item Mehr Tipps kann ich dazu auch nicht geben\ldots
    \item Und wegen Aufgabe~2\ldots \begin{itemize}
        \item Da haben wir heute ja schon was mit Zeichen gemacht!
        \item Die Aufgabe lässt sich schön elegant lösen
    \end{itemize}
\end{itemize}
\end{frame}

\subsection{Aufgabe 3}
\setbox\pinguA=\hbox{\begin{tikzpicture}[scale=.65, every node/.style={transform shape}]
\tikzumlset{fill class=white, fill note=white!20}
\umlclass[x=0,y=0,name=stud]{Student}{
    {studierendenzahl : int}\\
    {name : String}\\
    {matrikelnummer : int}\\
    {besuchtVorlesungen : String[]}}{
        % {Student (name : String, nummer : int)}\\ % not even a ctor?
    {getName() : String}\\
    {getNummer() : int}\\
    {addVorlesung(String name) : void}\\
    {getVorlesungen() : String[]}\\
    {removeVorlesung(String name) : void }}
% oh gosh this is ugly
\path (-4cm+6mm,2cm-1pt) -- ++(0,-1.92) node [black,midway, above,rotate=90,yshift=0.75cm] {Attribute};
\path (-4cm+6mm,2cm-1.92cm-1pt) -- ++(0,-2.78) node [black,midway, above,rotate=90,yshift=.75cm] {Methoden};
\node at(0,3.25) [above=-6mm] (kln) {Klassenname};
% Hackey decky
\umlclass[x=10,y=0]{Objekt: Student}{
    {studierendenzahl: 10142}\\
    {name: \dq Peter-Hans\dq}\\
    {matrikelnummer: 10142001}\\
    {besuchtVorlesungen: \{\dq EidI\dq, \dq GdBs\dq, \dq Ana1\dq, \dq Pengu\dq \} }}{
    {getName() : String}\\
    {getNummer() : int}\\
    {addVorlesung(String name) : void}\\
    {getVorlesungen() : String[]}\\
    {removeVorlesung(String name) : void }}
\end{tikzpicture}}
\begin{frame}{Aufgabe 3: Objektorientierung: Klassenentwurf}
\begin{itemize}[<+(1)->]
    \itemsep9pt
    \item Wir möchten einen \textit{Klassenentwurf} \info{Und Objektlies}
    \item Gerne von Hand (dann aber sehr deutlich): \begin{itemize}
        \itemsep3pt
        \item Sonst gibt es \link{https://app.diagrams.net/}{draw.io}
        \item Man kann das aber auch mit \LaTeX\ machen
        \item Oder mit anderen Zeichenprogrammen\ldots
        \item Generierte Klassenentwürfe sind aber verboten!
    \end{itemize}
\end{itemize}
\begin{tikzpicture}[@O]
    \onslide<8->{\node[above left,yshift=\btdmfootheight,scale=.8,xshift=-5mm] at (current page.south east) {\copy\pinguA};}
\end{tikzpicture}
\end{frame}
\fi


\SetNextSectionText[.55\linewidth]{There aren't that many people in the world who are good programmers and there are not that many people in the world who are good writers, and here we are expecting them to be both.\\--- Donald E. Knuth,~\cite[p.649]{knuth1999digital}}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep6.5pt
    \item In manchen Fällen \textit{muss} Java intiialisieren \info{Arrays!} \begin{itemize}
        \item Ganzzahlen werden \(0\), Fließkommazahlen \(0.0\) (im jeweiligen Typ, also \bjava{0.0f},~\ldots)
        \item \bjava{boolean} wird \bjava{false}, \bjava{char} wird \bjava{'\0'} \info{Unicode-\say{Null}}
        \item Referenzdatentypen (wie Arrays) werden \bjava{null}
    \end{itemize}
    \item Java unterscheidet Methoden durch ihre Signatur (Name \& Parametertypliste)
    \item Wir haben einen Blick auf Clone(s) geworfen \info{I've seen the dark side now}
    \item Auch wenn Heap und Stack nicht Klausurrelevant sind, helfen sie bei vielem! \begin{itemize}
        \item Call-by-Value und Call-by-Reference (Seiteneffekte,~\ldots)
        \item Was genau schützt \bjava{final},~\ldots
    \end{itemize}
\end{itemize}
\end{frame}
}

\outro{\vskip9mm\centering \onslide<2->{\scalebox{1.35}{\begin{tikzpicture}
    \pingu[cloak=pingu@bronze!80!pingu@black,right wing wave, lightsaber right=pingu@blue,eyes wink]
\end{tikzpicture}}}}


\iffull\end{document}\fi
