\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{Integral Refs in Higher Dimensions}
\subtitle{Tutorium vier}
\date{KW 21}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{4}

\iffull\begin{document}
\titleframe

\TopicOverview{4}
\fi

\iffull{\SummaryFrame
\setbox\pinguA=\hbox{\SolNoInlineSize\scalebox{.5}{\tikzpicture
\fill[lgray,rounded corners] (0,1.65) rectangle ++(3,3.85);
\fill[lgray,rounded corners] (3.5,1.65) rectangle ++(3,3.85);
\node[ldesc,above] at (1.5,5.5) {Stack};
\node[ldesc,above] at (5,5.5) {Heap};
\node[lrel] at (1.5,5) {\ldots};
\node[lrel] at (5,5) {\ldots};
\node[lrel] at (1.5,5-.85) {\bjava{byte b = 7}};
\node[lrel] at (1.5,5-.85*2) {\bjava{char c = '?'}};
\node[lrel] (fg) at (1.5,5-.85*3) {\bjava{int[] i =\ }\raisebox{-1pt}\faGenderless};
\node[lrel] (ft) at (5,5-.85-.425) {\bjava{\{1, 9, 0\}}};
\draw[lightgray,very thick,-Kite]  (fg.east) to[out=0,in=180] (ft.west);
\endtikzpicture}}
\begin{frame}[fragile,c]{Kurzwiederholung}
    \begin{itemize}[<+(1)->]
        \itemsep9.25pt
        \item Wir haben uns Methoden angesehen \begin{itemize}
            \item Methoden mit einem Rückgabetyp \say{$\neq$~\bjava{void}} müssen für jeden Pfad diesen Typ liefern
            \item Methoden haben Vor- \info{Parameter} und Nachbedingungen \info{Rückgabetyp}
            \item Parameter und lokale Variablen sind nur in ihrer Methode sichtbar
        \end{itemize}
        \item<6-> Für Arrays haben wir for-each\vspace*{-\medskipamount}
\columns[onlytextwidth,c]
\column{.45\linewidth}
\begin{plainjava}
!*\onslide<7->*!int[] arr = { 1, 9, -2, 3 };
!*\onslide<8->*!for(int elem : arr)
!*\onslide<9->*!    System.out.println(elem);!*\onslide<1->*!
\end{plainjava}
\column{.55\linewidth}
\begin{plainjava}
!*\onslide<10->*!int[] arr = new !*\tikzmarknode{@}{\sbasic{\skB{int}[\snum{5}]}}*!;
!*\onslide<11->*!for(int i = 0; i < arr.length; i++)
!*\onslide<12->*!    System.out.println(arr[i]);!*\onslide<1->*!
\end{plainjava}
\endcolumns\medskip
        \item<14-> Java verwaltet Daten auf dem Stack \info{Primitiv} und Heap \info{Komplex} \begin{itemize}
            \item<15-> Java kopiert, vergleicht, schützt, verwirft,\ldots\ Stackelemente
            \item<16-> Bei der Ablage auf dem Heap wird auf dem Stack eine Referenz\\zu diesem Element abgelegt \info{\bjava{null} für die \say{leere} Referenz}
        \end{itemize}
    \end{itemize}
    \onslide<1->
\begin{tikzpicture}[overlay,remember picture]
    \onslide<13->{\draw[Kite-,gray] (@)++(.2,.3) to[out=50,in=230] ++(.45,.3) node[above,T] {Initialisiert automatisch mit \T{\{0, 0, 0, 0, 0\}}};}
    \onslide<17->{\node[above left, yshift=\btdmfootheight] at (current page.south east) {\copy\pinguA};}
\end{tikzpicture}
\end{frame}
}\fi
\SetNextSectionText[.55\linewidth]{TODO: quote}
\section{Präsenzaufgabe}
{\setbox\pinguA=\hbox{\tikz{\pingu[devil horns,eyes angry,pants=btdm@primary,wings raise]}}
\setbox\pinguB=\hbox{\tikz{\pingu[devil horns,eyes sad,pants=btdm@primary]}}
\MakeThePinguExplainIt[text width=2.23cm]{cap=!hide,cup=!hide,straw hat,body type=chubby,cake-hat,right item angle=16}{A--Z~\(\widehat{=}\) 65--90\\a--z~\(\widehat{=}\) 97--122}
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Flip-em till 'ya hit-em}
\begin{onlyenv}<2-10|handout:0>%
\onslide<2-10|handout:0>{Implementieren Sie die folgenden zwei Methoden, welche beide ein \bjava{char}-Array als Parameter übernehmen und alle
darin enthaltenen Kleinbuchstaben zu Großbuchstaben, und alle Großbuchstaben zu Kleinbuchstaben machen.} \onslide<3-10|handout:0>{Sie finden die Datei auf unserer Moodle Seite \info{auf Papier genügt es, nur den bei \say{\T{// TODO}} benötigten Code zu schreiben}.}\vspace*{-3mm}
\only<5>{\lstfs{9}}\only<6>{\lstfs{5}\lstset{multicols=2,lineskip=2pt}}
\only<7->{\lstfs{4}\lstset{multicols=2,lineskip=-1pt}}
\begin{plainjava}
!*\onslide<4->*!public class Praesenzaufgabe {
!*\onslide<4->*!    public static void flipInPlace(char[] flipBuchstaben) {
!*\onslide<4->*!        // TODO
!*\onslide<4->*!    }
!*\onslide<4->*!
!*\onslide<4->*!    public static char[] flipInCopy(char[] flipBuchstaben) {
!*\onslide<4->*!        // TODO
!*\onslide<4->*!    }
!*\onslide<4->*!
!*\onslide<4->*!    public static void main(String[] args) {
!*\onslide<4->*!        String s = "DieSeR SatZ HaT EinE merKwüRdige Groß- und KleinschreibunG.";
!*\onslide<4->*!        System.out.println(s);
!*\onslide<4->*!
!*\onslide<4->*!        char[] flipBuchstaben = s.toCharArray();
!*\onslide<4->*!
!*\onslide<4->*!        String inCopy = String.valueOf(flipInCopy(flipBuchstaben));
!*\onslide<4->*!        System.out.println(inCopy);
!*\onslide<4->*!
!*\onslide<4->*!        flipInPlace(flipBuchstaben);
!*\onslide<4->*!        String inPlace = String.valueOf(flipBuchstaben);
!*\onslide<4->*!        System.out.println(inPlace);
!*\onslide<4->*!    }
!*\onslide<4->*!}!*\onslide<1->*!
\end{plainjava}
\onslide<8->{Die erste Methode soll diese Änderungen direkt im übergebenen Array vornehmen, die zweite Methode soll auf einer
Kopie des Arrays arbeiten und diese Kopie dann zurückgeben. Überlegen Sie sich, welche Vor- und Nachteile die
jeweiligen Implementierungen haben.
[TODO: Hinweise, aber das sieht hier ja niemand heheheee]}
\end{onlyenv}
\begin{onlyenv}<11->
\vspace*{-\baselineskip}
    \begin{columns}[onlytextwidth,c]
\column{.3\linewidth}
\small \onslide<12->{Implementieren Sie beide Methoden, welche  alle im übergebenen \bjava{char}-Array enthaltenen Klein- zu Großbuchstaben, und alle Groß- zu Kleinbuchstaben machen.}
\column{.675\linewidth}
\begin{uncoverenv}<13->
\SetupLstHl\lstfs{9}
\begin{plainjava}
public class Praesenzaufgabe {
    public static void
        flipInPlace(char[] c) { /* TODO */ }
    public static char[]
        flipInCopy(char[] c) { /* TODO */ }
    |ihl|public static void main(String[] args) { ... }|ihl|
}
\end{plainjava}
\end{uncoverenv}
\end{columns}
\onslide<14->{\T{flipInPlace} soll diese Änderungen direkt im übergebenen Array vornehmen, \T{flipInCopy} soll auf einer
Kopie des Arrays arbeiten und diese zurückgeben.~}\onslide<15->{Überlegen Sie sich, welche Vor- und Nachteile die
jeweiligen Implementierungen haben.}
\end{onlyenv}
% TODO: Rest, TODO: devil pingu
\end{aufgabe}
\begin{tikzpicture}[overlay,remember picture]
    \only<9|handout:0>{\node[yshift=-2.5cm,above,scale=1.33] at (current page.center) {\copy\pinguA};}
    \only<10|handout:0>{\node[yshift=-2.5cm,above,scale=1.33] at (current page.center) {\copy\pinguB};}
    \onslide<16->{\node[left=-3mm,xshift=7mm,scale=.8,yshift=2mm] at(current page.0) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
}
\iffull
\subsection{Flip in Place}
{\renewcommand\K[2][]{\tikzmarknode{@#2#1}{\snum{\HStrut#2}}}
\begin{frame}[fragile,c]{Flip in Place}
\begin{plainjava}
!*\onslide<2->*!public static void flipInPlace(char[] flipBuchstaben) {
!*\onslide<3->*!    for(int i = 0; i < flipBuchstaben.length; i++) {
!*\onslide<4->*!        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {
!*\onslide<5->*!            flipBuchstaben[i] += !*\K{32}*!;
!*\onslide<4->*!        } !*\onslide<6->*!else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {
!*\onslide<7->*!            flipBuchstaben[i] -= !*\K[b]{32}*!;
!*\onslide<6->*!        }
!*\onslide<3->*!    }
!*\onslide<2->*!}
\end{plainjava}
\begin{tikzpicture}[remember picture,overlay]
    \onslide<8->{
        \foreach \K in {65,90,32,97,122,32b} {
            \node[btdm@primary!70!btdm@background,draw,ellipse,minimum width=6.5mm, minimum height=4.5mm] (@@\K) at (@\K) {};
        }
    }
    \onslide<10->{
        \node[above left=1cm,yshift=1.25cm,T,align=left] (@) at(current page.south east) {Wer soll das mit den Zahlen verstehen?}; % \\Was, wenn es nur von g--s gehen soll?
    }
    \onslide<9->{
        \foreach \K in {65,90,32,97,122,32b} {
            \draw[-Kite,lightgray] (@@\K) to[bend left] (@);
        }
    }
    \onslide<11->{
        \node[below,align=center] at(@.south) {Wir können benannte Konstanten einführen!\\\bjava{public static final int A = 65;}\\\ldots};
    }
\end{tikzpicture}
\end{frame}
\begin{frame}[fragile,c]{Flip in Place with Constants}
\begin{onlyenv}<1|handout:0>
\begin{plainjava}
public static void flipInPlace(char[] flipBuchstaben) {
    for(int i = 0; i < flipBuchstaben.length; i++) {
        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {
            flipBuchstaben[i] += !*\K{32}*!;
        } else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {
            flipBuchstaben[i] -= !*\K[b]{32}*!;
        }
    }
}
\end{plainjava}
\end{onlyenv}
\SetupLstHl
\begin{onlyenv}<2-3|handout:0>
\begin{plainjava}
!*\onslide<3->*!public static final int A = 65;  public static final int a = 97;
!*\onslide<3->*!public static final int Z = 90;  public static final int z = 122;
!*\onslide<3->*!
!*\onslide<1->*!|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= !*\K{65}*! && flipBuchstaben[i] <= !*\K{90}*!) {|ihl|
|ihl|            flipBuchstaben[i] += !*\K{32}*!;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= !*\K{97}*! && flipBuchstaben[i] <= !*\K{122}*!) {|ihl|
|ihl|            flipBuchstaben[i] -= !*\K[b]{32}*!;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<4|handout:0>
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += !*\K{32}*!;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= !*\K[b]{32}*!;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<5->
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|a - A|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|a - A|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}% copy for animations
\begin{tikzpicture}[overlay,remember picture]
    \onslide<6->{\node[above left=5mm,T,align=center] at(current page.south east) {What, if there would be a better way?\\What, if we want to check only for characters g--m};}
\end{tikzpicture}
\end{frame}
}
\fi
{
    \setbox\pinguA=\hbox{\tikz\pingu[eyes shock,wings shock];}
\begin{frame}[fragile,c]{Flip in Place with Java-Magic}
\SetupLstHl
\begin{onlyenv}<1|handout:0>
\begin{plainjava}
public static final int A = 65;  public static final int a = 97;
public static final int Z = 90;  public static final int z = 122;

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|A|ihl| && flipBuchstaben[i] <= |ihl|Z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|a - A|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|a|ihl| && flipBuchstaben[i] <= |ihl|z|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|a - A|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<2|handout:0>
\begin{plainjava}
|ihl|public static final int A = 65;  public static final int a = 97;|ihl|
|ihl|public static final int Z = 90;  public static final int z = 122;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<3-4|handout:0>
\begin{plainjava}
|ihl|public static final int A = |ihl|'A'|ihl|;  public static final int a = 97;|ihl|
|ihl|public static final int Z = 90;  public static final int z = 122;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<5|handout:0>
\begin{plainjava}
|ihl|public static final int A = |ihl|'A'|ihl|;  public static final int a = |ihl|'a'|ihl|;|ihl|
|ihl|public static final int Z = |ihl|'Z'|ihl|;  public static final int z = |ihl|'z'|ihl|;|ihl|

|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= A && flipBuchstaben[i] <= Z) {|ihl|
|ihl|            flipBuchstaben[i] += a - A;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= a && flipBuchstaben[i] <= z) {|ihl|
|ihl|            flipBuchstaben[i] -= a - A;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<6-7|handout:0>
\begin{plainjava}
|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|'A'|ihl| && flipBuchstaben[i] <= |ihl|'Z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|'a' - 'A'|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|'a'|ihl| && flipBuchstaben[i] <= |ihl|'z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|'a' - 'A'|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<8>
\begin{plainjava}
|ihl|public static void flipInPlace(char[] flipBuchstaben) {|ihl|
    int shift = 'a' - 'A';
|ihl|    for(int i = 0; i < flipBuchstaben.length; i++) {|ihl|
|ihl|        if (flipBuchstaben[i] >= |ihl|'A'|ihl| && flipBuchstaben[i] <= |ihl|'Z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] += |ihl|shift|ihl|;|ihl|
|ihl|        } else if (flipBuchstaben[i] >= |ihl|'a'|ihl| && flipBuchstaben[i] <= |ihl|'z'|ihl|) {|ihl|
|ihl|            flipBuchstaben[i] -= |ihl|shift|ihl|;|ihl|
|ihl|        }|ihl|
|ihl|    }|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{onlyenv}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<4->{
        \node[above left=5mm,scale=.75] (@) at(current page.south east) {\copy\pinguA};
        \node[T,left=2mm,align=right] at(@.west) {Implizite\\Typkonvertierung!\\\T{char}~$\to$~\T{int}};
    }
    \onslide<7-8|handout:0>{
        \node[above=\btdmfootheight+2mm,T] at(current page.south) {Aber welche Logik steckt hinter \T{'a' - 'A'}?};
    }
\end{tikzpicture}
\end{frame}
}

\subsection{Flip in Copy}
\iffull
\begin{frame}[fragile,c]{Flip in Copy, Na\"\i ve Please}
\begin{center}
    \color{gray}\onslide<2->{There is a \T{clone} for every \cancel{Object} \say{Referenzvariable}}
\end{center}
\begin{onlyenv}<3-7|handout:0>
\begin{plainjava}
!*\onslide<3->*!public static char[] flipInCopy(char[] flipBuchstaben) {
!*\onslide<4->*!    char[] arrayKopie = flipBuchstaben.clone();
!*\onslide<5->*!    int shift = 'a' - 'A'; !*\Snode{@start}*!
!*\onslide<5->*!    for(int i = 0; i < arrayKopie.length; i++) {
!*\onslide<5->*!        if (arrayKopie[i] >= 'A' && arrayKopie[i] <= 'Z')
!*\onslide<5->*!            arrayKopie[i] += shift;
!*\onslide<5->*!        else if (arrayKopie[i] >= 'a' && arrayKopie[i] <= 'z')!*\Snode{@wide}*!
!*\onslide<5->*!            arrayKopie[i] -= shift;
!*\onslide<5->*!    }!*\Snode{@end}*!
!*\onslide<6->*!    return arrayKopie;
!*\onslide<3->*!}
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<8->
\begin{plainjava}
public static char[] flipInCopy(char[] flipBuchstaben) {
    char[] arrayKopie = flipBuchstaben.clone();
    flipInPlace(arrayKopie);
    return arrayKopie;
}
\end{plainjava}
\end{onlyenv}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<7|handout:0>{\draw[decoration=brace,decorate] ([xshift=2mm]@start-|@wide) to[edge node={node[right=1mm] {hmmm\ldots}}] ([xshift=2mm]@end-|@wide);}
    \onslide<9-|handout:0>{
        \node[above=\btdmfootheight+2mm,T] at(current page.south) {Das ist ein weirdes Englisch-Deutsch-Gemisch};
    }
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[fragile,c]{Flip in Copy --- Custom Mode}
\begin{center}
    \color{gray}\onslide<2->{Ich kannte \T{clone} gaaar niiischt. Unnu? Ist das nicht böse?}
\end{center}
\SetupLstHl
\begin{uncoverenv}<3->
\begin{plainjava}
!*\onslide<1->*!|ihl|public static char[] flipInCopy(char[] flipBuchstaben) {|ihl|
!*\onslide<4->*!    char[] arrayKopie = new char[flipBuchstaben.length];
!*\onslide<5->*!    for(int i = 0; i < arrayKopie.length; i++)
!*\onslide<6->*!        arrayKopie[i] = flipBuchstaben[i]

!*\onslide<1->*!    |ihl|flipInPlace(arrayKopie);|ihl|
    |ihl|return arrayKopie;|ihl|
|ihl|}|ihl|
\end{plainjava}
\end{uncoverenv}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<7->{
        \node[above=\btdmfootheight,T,xshift=-3.75cm] at(current page.south) {\strut Werte primitiver Datentypen werden bei Zuweisung kopiert.};

        \only<8->{\node[above left,yshift=\btdmfootheight,T] at(current page.south east) {\strut\textattachfile{\curpath Praesenzaufgabe.java}{Praesenzaufgabe.java}, \textattachfile{\curpath PraesenzaufgabeNaiv.java}{PraesenzaufgabeNaiv.java}\;};}
    }
\end{tikzpicture}
\end{frame}

\subsection{Allgemeine Fragen}
\begin{frame}{Allgemeines}
    \begin{itemize}[<+(1)->]
        \itemsep13pt
        \iffull\item \T{Clone} widmen wir uns gleich nochmal\ldots\fi
        \item \task{Überlegen Sie sich, welche Vor- und Nachteile die jeweiligen Implementierungen haben.}
        \begin{itemize}[<+(1)->]
            \itemsep4.5pt
            \item Vorteile einer Kopie \info{gegenüber in-place}: Nebeneffekte von Methoden sind generell schlecht! \say{out-Parameter} sollten vermieden werden (wo nicht unbedingt notwendig).
            \item Nachteile einer Kopie \info{gegenüber in-place}: Der benötigte Speicher wird verdoppelt (was, wenn das Array riesig ist?)
        \end{itemize}
        \item Was ist nun besser?
                \begin{itemize}
                    \itemsep4.5pt
                    \item In der Regel die Variante mit Kopie. Die unerwarteten/ungewollten Seiteneffekte können Kaskaden schwer zu findender Fehler verursachen.
                    \item Sollten wirklich große Arrays erwartet werden, sollte man sich unter Umständen ein grundlegend anderes System überlegen.
                \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Alternativen?}
    \begin{itemize}[<+(1)->]
        \item Hätte man hier auch \say{for-each} für flip in place nutzen können?\vspace*{-1mm}
\begin{plainjava}
!*\onslide<3->*!for(int i = 0; i < flipBuchstaben.length; i++) {
!*\onslide<3->*!    if ('A' <= flipBuchstaben[i] && flipBuchstaben[i] <= 'Z') {
!*\onslide<3->*!        flipBuchstaben[i] += shift;
!*\onslide<3->*!    } else if ('a' <= flipBuchstaben[i] && flipBuchstaben[i] <= 'z') {
!*\onslide<3->*!        flipBuchstaben[i] -= shift;
!*\onslide<3->*!    }
!*\onslide<3->*!}!*\onslide<1->*!
\end{plainjava}
    \item<4-> Nein, so könnten wir nicht mehr \bjava{flipBuchstaben} an der Stelle \T{i} verändern.
    \item<5-> Mit \bjava{for(char c : flipBuchstaben)} ist \T{c} jeweils eine Kopie \info{primitiver Datentyp} und nicht mehr eine Referenz auf die Stelle im Array!
    \end{itemize}
\end{frame}

\iffull
\SetNextSectionText[.55\linewidth]{Have you ever heard the tragedy of Darth Clon\textbf{e}able the wise? Well, then prepare yourself for\ldots\ something at least.\\--- Florian}
\section{Clone-Wars}
\fi
{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{1.5em}\centering
\begin{tikzpicture}[overlay,remember picture]
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{\pingu[eyes wink]}
    \only<3|handout:0>{\pingu[right wing grab, lightsaber right, lightsaber right disabled]}
    \only<4|handout:0>{\pingu[right wing grab, eyes angry, lightsaber right=purple]}
    \only<5|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple]}
    \only<6|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,right item angle=-70],bill angry}
    \only<7|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70],bill angry}
    \pgfonlayer{background}
    \only<9->{\node[white!14!black,scale=9] at(current page.center) {\Large\textsc{clone}};}
    \endpgfonlayer
    \only<8-9|handout:0>{\pingu[right wing grab, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70,bill angry,right item angle=-80,lightsaber right yshift=-.45mm]}
    \only<10->{\pingu[right wing grab, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70,bill angry,right item angle=-80,lightsaber right yshift=-.45mm,left eye devil]}
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}
{
\iffull
\AddonFrame
\begin{frame}[t,fragile]{Die Object Klasse}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item \bjava{Object} ist die Klasse, welche die grundlegenden Eigenschaften für jede andere Klassen zur Verfügung stellt.
        \item Wir werden sie später im Rahmen von Vererbung genauer kennen lernen.\par
            Bis da hin: \bjava{toString} stammt beispielsweise dort her.
        \item Diese Klasse \bjava{Object} liefert auch die Methode \bjava{clone}, die auf jedem Objekt aufgerufen werden kann\pause\ldots\pause{} \ldots\pause{} \ldots
        \item \bjava{clone} muss aber von jeder Klasse selbst und individuell implementiert werden, wenn es denn unterstützt werden soll.
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Kopien}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Da die Variable eines Objekts in Java nur eine Referenz auf das eigentliche Objekt enthält, erzeugen wir durch den folgenden Code \textit{keine} Kopie:\pause{}
\begin{plainjava}
Scanner a = new Scanner(System.in);
Scanner b = a;
\end{plainjava}
        \item Oft stellen sich auch Fragen wie:
         \begin{itemize}
            \itemsep6pt
             \item Was soll kopiert werden?
             \item Funktioniert eine Kopie überhaupt?
             \item Was ist, wenn das zu kopierende Objekt selbst wieder (zum Beispiel in den Attributen) Referenzen auf andere Objekte enthält?
             \item Was, wenn diese Referenzen zirkulär sind?
         \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Kopie-Varianten}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Deswegen unterscheiden wir zwei Arten von Kopien: \textit{shallow} und \textit{deep}.
            \infoblock{Genau genommen gibt es noch viel mehr, wie zum Beispiel \textit{lazy}, aber das soll uns hier nicht weiter stören.}
        \item Eine \textit{shallow copy} kopiert \say{so wenig wie möglich}. Oder auch nur \say{die erste Hierarchieebene.}
        \item Eine \textit{deep copy} kopiert das komplette Objekt, sowie alle Objekt-Referenzen die dieses Objekt wieder besitzt und so weiter.
        \item Während shallow copies meist von Hand geschrieben werden,\pause{} wird eine deep copy meistens durch (De-)Serialisierung gelöst.\pause{}\infoblock{Sonst müssten bei einer deep copy auch alle vom Objekt verwendeten Ressourcen wieder deep-copyable sein.\pause{} Das Verfahren hat allerdings ebenfalls Nachteile. Stichwort: \solGet{keywordA}{\link{https://docs.oracle.com/en/java/javase/17/jfapi/exclude-fields-being-persisted-transient-keyword.html}{transient}}.}
    \end{itemize}
\end{frame}

\begingroup
\lstset{add to literate={X}{{{\solGet{keywordC}{X}}}}1 {Y}{{{\solGet{keywordC}{Y}}}}1 {Z}{{{\solGet{keywordC}{Z}}}}1}
\begin{frame}[t,fragile]{Kopien, ein Beispiel}
    \begin{itemize}[<+(1)->]
        \item Betrachten wir die folgende Klasse (\bjava{Y} und \bjava{Z} seien ebenfalls gegeben):\pause
\begin{plainjava}
class X {
    int a;
    Y y;
    Z z;
}
\end{plainjava}
        \item Eine \textit{shallow copy} würde ein neues \bjava{X}-Objekt erzeugen und die Attribute durch \say{\bjava{=}} zuweisen.\pause{} Damit wird \bjava{a} kopiert, \bjava{y} und \bjava{z} referenzieren aber (je) dasselbe Objekt.
        \item Eine \textit{deep copy} würde rekursiv auch neue Objekte von \bjava{Y} und \bjava{Z} erzeugen.\pause{} \infoblock{Quizfrage: was passiert oder besser, was kann alles passieren, wenn \bjava{Y} wieder eine Referenz auf \bjava{X} enthält?}
        \item Und was davon macht jetzt \bjava{Object::clone()}?\pause{} Spoiler: Nobody knows.
    \end{itemize}
\end{frame}
\endgroup

\begin{frame}[t,fragile]{Cloneable}
    \begin{itemize}[<+(1)->]
        \itemsep8pt
        \item Das Interface Cloneable \textit{fordert nichts} von einer gegebene Klasse.
        \item Es ist ein sogenanntes \say{Marker} interface.\pause{} Wer es implementiert, sorgt dafür, dass gewisse Methoden sich einem gewissen Vertrag unterwerfen.\smallskip\pause\par\infoblock{Diese Erklärung ist an sich nachträglich entstanden. Die komplette Geschichte um das \bjava{Cloneable}-Interface ist eine einzige Tragödie.}
        \item Aus der \link{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Cloneable.html}{Java-Dokumentation} \info{\say{contract}}:\par\pause
        \textit{\textcolor{lightgray}{[}\ldots\textcolor{lightgray}{]}~Note that this interface does not contain the clone method.
        Therefore, it is not possible to clone an object merely by virtue of the
        fact that it implements this interface. \onslide<+(1)->{Even if the clone method is invoked \link{https://www.oracle.com/technical-resources/articles/java/javareflection.html}{reflectively}, there is no guarantee that it will succeed. \textcolor{lightgray}{[}\ldots\textcolor{lightgray}{]}}}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Cloneable, Schadensbericht}
    \begin{itemize}[<+(1)->]
        \itemsep9pt
        \item Das Interface widerspricht der sonstigen Schreibweise.\pause{} \info{Clonable vs. Cloneable.}
        \item Es fordert nichts und kann theoretisch von jeder Klasse implementiert werden.
        \item Es liefert keine weiteren Informationen über die Kopie.
        \item Es stellt keine Anforderungen an die Java-Syntax (Sichtbarkeit), die nicht gleichermaßen geprüft werden können.
        \item Der Rückgabewert der \bjava{Object::clone}-Methode ist stets \bjava{Object}, wir brauchen also einen expliziten Cast.\pause{} \info{Beispielsweise bei \bjava{(Date) birthday.clone()}.}
        \item \ldots\pause{} \ldots\pause{} \ldots
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Long story short}
    \begin{itemize}[<+(1)->]
        \itemsep12pt
        \item Manche Java Klassen implementieren \bjava{Cloneable} korrekt.\pause{} \info{Wie \bjava{Date}.}
        \item Bei Arrays sind die Kopien mit \bjava{clone} immer \textit{shallow}.
        \item Ansonsten haben sich andere Prinzipien durchgesetzt. So beispielsweise Copy-Konstruktoren.
        % \item Diesen werden noch später im Semester begegnen.
    \end{itemize}
\end{frame}
}

{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{1.5em}\centering
\begin{tikzpicture}
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm]
        \pingu[xshift=3cm,yshift=.5cm]
        \pingu[]
    }
    \only<3|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right, lightsaber right disabled,eyes wink]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left, lightsaber left disabled,eyes wink]
        \pingu[right wing grab, lightsaber right, lightsaber right disabled, eyes shiny,left wing wave, lightsaber left, lightsaber left disabled,right item angle=-80,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \only<4->{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right=orange,eyes wink]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left=orange,eyes wink]
        \pingu[right wing grab, lightsaber right=pingu@blue, eyes shiny,left wing wave, lightsaber left=green,right item angle=-80,lightsaber right double,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}
\fi

\SetNextSectionText{Schleifen, Arrays, Methoden\\Abgabe: \DTMDate{2022-05-23}}
\section{Übungsblatt 4}
\subsection{Aufgabe 1}
\begin{frame}{Aufgabe 1: Referenzvariablen}

\end{frame}
\begin{frame}
    TODO: letztes Semester Blatt 5 im join P7
TODO: clone escapade
TODO: berechne TtrapezFlaeche prüfe auf < 0 und so optional, je nachdem wi eman es betrachtet (eigenständig, nicht....)
TODO: Animationsdurchläufe Heap Stack für Referenzvariablen
\end{frame}

\subsection{Aufgabe 2}
\begin{frame}{Aufgabe 2: Mehrdimensionale Arrays}

\end{frame}

\subsection{Aufgabe 3}
\begin{frame}{Aufgabe 3: Numerische Integration}

\end{frame}


\iffull
\SetNextSectionText{Methoden und OOP\\Abgabe: \DTMDate{2022-05-30}}
\section{Aussicht: Übungsblatt 5}
\subsection{Aufgabe 1}
\begin{frame}
TODO
\end{frame}

\fi


\SetNextSectionText{TODO: Quote}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep6.5pt
    \item TODO:
\end{itemize}
\end{frame}
}

\outro{\vskip6mm\centering X}


\iffull\end{document}\fi
