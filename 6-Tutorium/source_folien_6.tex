\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{TODO}
\subtitle{Tutorium sechs}
\date{KW 24}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{6}

\iffull\begin{document}
\titleframe

\TopicOverview{7}
\fi

\iffull{\SummaryFrame
\def\sub#1#2{\node[font=\footnotesize\sffamily,scale=.715,align=center,gray,below=-2.65mm] at(#1.south) {\strut#2\strut};}
\setbeamerfont{description item}{series=\mdseries,shape=\itshape}
\begin{frame}[c]{Algorithmen}
\begin{itemize}[<+(1)->]
   \itemsep14pt
   \item Totale Korrektheit \begin{description}[Partielle Korrektheit: ]
      \item[Terminiertheit:] \kern0pt\onslide<+(1)->{Endliche Schritte für jede Eingabe}
      \item[Partielle Korrektheit:] \kern0pt\onslide<+(1)->{Wenn terminiert, dann korrekt}
   \end{description}
   \item Weitere Eigenschaften \begin{description}[Determiniertheit: ]
      \item[Determiniertheit:] \kern0pt\onslide<+(1)->{Gleiche Eingabe~\(\to\) Gleiche Ausgabe}
      \item[Determinismus:] \kern0pt\onslide<+(1)->{Gleiche Eingabe~\(\to\) Gleiche Zustandsfolge}
   \end{description}
\end{itemize}\vfill
\centerline{%
\begin{tikzpicture}
    \onslide<+(1)->{\node (0) at(0,0) {\strut Spezifikation};
    \sub0{Begriffe mit\\Problemrelevanz}}
    \foreach[count=\i,remember =\i as \li (initially 0)] \a/\t in {Abstraktion/{Gegeben \& Gesucht},{\makebox[14mm]{\only<17->{\sbseries}Entwurf}}/{Algorithmus},Verifikation/{Termination \&\\partielle Korrektheit},Aufwandsanalyse/{Laufzeitverhalten}} {
        \onslide<+(1)->{\node[right=.5mm] (k\i) at(\li.east) {\strut\faAngleRight};
        \node[right=.5mm] (\i) at (k\i.east) {\strut\a};
        \sub\i{\t}}
    }
\end{tikzpicture}}
\end{frame}

\def\mto{\ensuremath{\to}}
\def\dt#1{{\textcolor{paletteA!58!white}{\sbseries\strut#1}}}
\begin{frame}[c]{Konstrukte}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item \textit{Implizit}:\quad\pause \dt{byte}~\mto~\dt{short}~\mto~\dt{int}~\mto~\dt{long}~\mto~\dt{float}~\mto~\dt{double}\\
   Zahlen von klein zu groß, sowie: \dt{char}~\mto~\dt{int}
   \item \textit{Präzedenzregeln}:\pause\\
   Post vor Prä, sonst wie Arithmetik \& Logik
   \item \textit{Default-Werte}:\quad\pause Zahlen und Zeichen \bjava{0}, Boolean \bjava{false}, Rest \bjava{null}\pause\\
   Nur bei: Arrays, Instanz- und Klassenvariablen (\link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html\#jls-4.12.5}{JLS17~4.12.5})
   \item \textit{Überschatten}:\pause\\
   Lokaler Bezeichner überdeckt Gültigkeit des globalen
\end{itemize}
\end{frame}

\def\mto{\ensuremath{\to}}
\begin{frame}[c]{Arrays \& Iteration}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Arrays sind komplexe Datentypen
   \item Mehrdimensionale Arrays sind eindimensionale Arrays von eindimensionalen Arrays von\ldots
   \item Die drei Schleifenarten sind gleich mächtig \begin{itemize}
      \item Maximum bekannt: \bjava{for}
      \item Mindestens ein mal: \bjava{do}-\bjava{while}
      \item Sonst: \bjava{while}
   \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[c]{Unterprogramme}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item \textit{Überladung:}\quad\pause Gleicher Name, andere Signatur \begin{itemize}
      \item \textit{Signatur:} \pause Name \& Parametertypliste
      \item Müssen zudem in selber Klasse sein (später: Vererbung)
   \end{itemize}
   \item Beim Aufruf macht Java call-by-value: \begin{itemize}
      \item Alle Parameter werden kopiert (Stack)
   \end{itemize}
   \item \bjava{void} gibt als Keyword an, dass die Methode keinen Rückgabetyp hat
\end{itemize}
\end{frame}

\begin{frame}[c]{Objektorientierte Progammierung}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Eine Klasse definiert die Blaupause für Objekte \begin{itemize}
      \item Attribute definieren den Zustand
      \item Methoden definieren den Verhalten
   \end{itemize}
   \item Der Konstruktor baut den initialen Zustand \begin{itemize}
      \item \textit{Instanziierung}: \pause Erzeugen eines neuen Objektes
      \item Wenn keiner: \pause erzeugt Java den leeren Standardkonstruktor
      \item \bjava{this} erlaubt Aufruf von überladenen Konstruktoren
   \end{itemize}
   \item Klassen, Methoden,~\ldots:\quad \textit{Sichtbarkeit} (\bjava{public},~\ldots)
   \item \textit{Gültigkeit}sbereich:\quad Wo die Variablen \say{deklariert sind} (Überschatten,~\ldots)
\end{itemize}
\end{frame}
}\fi

% TODO: make sectionlink auto triggerat start of section
\SetNextSectionText[.75\linewidth]{Ich glaub es bedarf weiterer Animationen.\smallskip\\ --- Break-Down-Flo}
\section{Präsenzaufgabe}
{\taskenum
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Meine Kleine, du hast Palindrom!}
    \onslide<2->{In dieser Aufgabe sollen Sie eine rekursive Methode implementieren, die überprüfen soll, ob es sich bei dem als Parameter übergebenen String um ein Palindrom handelt. Ein Palindrom ist ein Wort, das vorwärts und rückwärts gelesen identisch ist.} \onslide<3->{Die Überprüfung soll nicht case-sensitive sein, d.h. das Wort \say{Kajak} soll zum Beispiel ein gültiges Palindrom sein.}

    \onslide<4->{Beantworten Sie zudem folgende Fragen bezüglich Ihrer Implementierung:}
    \begin{enumerate}
        \item<5-> Ist Ihre Implementierung ein linear-rekursiver Algorithmus? Warum?
        \item<6-> Ist Ihre Implementierung ein end- oder kopf-rekursiver Algorithmus? Warum?
    \end{enumerate}
\end{aufgabe}
\end{frame}
}

\begin{frame}[c,fragile]{Eine erste Idee}
    \onslide<2->{\only<3->{\color{gray}}In dieser Aufgabe sollen Sie eine {\color{black}rekursive Methode} implementieren, die überprüfen soll, ob es sich bei dem als {\color{black}Parameter übergebenen String} um ein {\color{black}Palindrom} handelt. Ein Palindrom ist ein Wort, das vorwärts und rückwärts gelesen identisch ist. Die Überprüfung soll {\color{black}nicht case-sensitive} sein, d.h. das Wort \say{Kajak} soll zum Beispiel ein gültiges Palindrom sein.}\bigskip

    \onslide<4->{\color{black}Idee:}
    \footnotesize\begin{itemize}
        \item<5-> Prüfe für \(i = 0\) bis \(i = \floor{\sfrac{\text{\bjava{s.length}}}{2}}\), ob \say{\bjava{s[i] == s[s.length - i - 1]}}.
        \item<6-> \bjava{String::toLowerCase()} entweder für jeden Vergleich oder einmal per Hilfsmethode.
        \item<7-> Noch einfacher: Anstelle \bjava{i} zu inkrementieren, löschen wir das erste und letzte Zeichen nach dem Vergleich (via \bjava{String::substring(int, int)}---das Ende ist exklusiv)!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Von Palindromen}
\SetupLstHl\lstfs{10}%
\begin{plainjava}
!*\CodeFileMarkerAttach<2->{Palindrome.java}*!
!*\onslide<3->*!public static boolean isPalindrome(String s) { !*\Snode{@helper}*!
!*\onslide<4->*!    return isPalindromeRecursive(s.toLowerCase());
!*\onslide<3->*!}


!*\onslide<6->*!private static boolean isPalindromeRecursive(String s) {
!*\onslide<7->*!    if(s.length() < 2) !*\Snode{@1}*!
!*\onslide<8->*!        return true;
!*\onslide<9->*!    else if(s.charAt(0) != s.charAt(s.length() - 1)) !*\Snode{@2}*!
!*\onslide<9->*!        return false;
!*\onslide<7->*!    else !*\Snode{@3}*!
!*\onslide<7->*!        return isPalindromeRecursive(s.substring(1, s.length() - 1));
!*\onslide<6->*!}!*\onslide<1->*!
\end{plainjava}
\begin{tikzpicture}[@O]
    \onslide<5->{\node[T,yshift=.33mm,right] at(@helper) {die \say{Hilfsmethode}};}

    \onslide<7->{\node[T,yshift=.33mm,right] at(@1) {Basisfall: weniger als zwei Zeichen};}
    \onslide<9->{\node[T,yshift=.33mm,right] at(@2) {Basisfall: kein Palindrom!};}
    \onslide<7->{\node[T,yshift=.33mm,right] at(@3) {Rekursionsfall};}
\end{tikzpicture}
\end{frame}

\iffull
\MakeThePinguExplainIt[text width=7cm]{cap=!hide,glasses=!hide,sunglasses round,eyes shiny,cup=!hide,santa beard,halo,right item angle=-142,staff right length=17mm}{Mit \bjava{:lan:ret:c:urn:ran:} haben wir hier die zurückzugebenden anonymen Variablen referenziert. Generell ist hier das \say{Speichern} der Position für den Aufstieg der Rekursion informal dargestellt.}
\begin{frame}[c,fragile]{Sie Simulantario Sie!}
\sollockinline\SetupLstHl\lstfs{9}\begin{plainjava}
!*\onslide<2->*!!*\MD4*!private static boolean isPalindrome(String s) { !*\rBS<handout:2-4|4->{s=\dq RegalelaGEr\dq }*!
!*\onslide<2->*!    !*\MD5*!return isPalindrom!*\mb{7,38}\mbg[2-3]{8-42}*!eRecursive(s!*\mb6*!.toLowerCase());!*\ml[4]{43}*! !*\rBS<handout:2-3|6-41>{\dq regalelager\dq }~~\rBS<handout:4|43>{true}*!
!*\onslide<2->*!}
!*\onslide<2->*!!*\MD{8,15,20,25,30,35}*!private static boolean isPalindromeRecursive(String s) { !*\rBS<handout:0|8-14>{s=\dq regalelager\dq }\rBS<handout:0|15-19>{s=\dq egalelage\dq }\rBS<handout:0|20-24>{s=\dq galelag\dq }\rBS<handout:2|25-29>{s=\dq alela\dq }\rBS<handout:0|30-34>{s=\dq lel\dq }\rBS<handout:3|35-37>{s=\dq e\dq }*!
!*\onslide<2->*!    !*\MD{9,16,21,26,31,36}*!if(s.length() < 2) return true;!*\ml[3]{37}*!
!*\onslide<2->*!    !*\MD[2]{10,17,22,27,32}*!else if(s.charAt(0) != s.charAt(s.length() - 1)) return false; !*\rBS<handout:0|10-14>{'r'!='r'}\rBS<handout:0|17-19>{'e'!='e'}\rBS<handout:0|22-24>{'g'!='g'}\rBS<handout:2|27-29>{'a'!='a'}\rBS<handout:0|32-34>{'l'!='l'}*!
!*\onslide<2->*!    !*\MD{11,18,23,28,33}*!else return isPalindrom!*\mb{14,19,24,29,34}\mbg[2-3]{15-18,20-23,25-28,30-33,35-41}*!eRecursive(s!*\mb{13}*!.substring(1, s!*\mb{12}*!.length() - 1));!*\ml{38,39,40,41,42}*!
!*\onslide<2->*!}
\end{plainjava}
\only<handout:1|3>{\begin{center}
    \huge\bfseries \say{RegalelaGEr}\\[-2mm]
    {\normalfont\info{Wer sieht auch ein \T{e}, dass die Arme hochwirft?}}
\end{center}}
\begin{onlyenv}<handout:2-4|4-43>\begin{center}\lstfs{6}\lstset{aboveskip=0pt,belowskip=0pt,add to literate={:ll:}{{{\color{lightgray!60!gray}$\ldots$}}}1}
    \begin{tikzpicture}[b/.style={draw=gray,fill=white,text width=4.1cm,minimum height=2.25cm,thick,rounded corners=2pt,inner xsep=1em}]
            \node[b] (a) at(0,0) {%
\begin{plainjava}
!*\MD4*!boolean isPalindrome(String s) {
    !*\MD5*!return isPalindrom!*\mb[1-]{7-42}*!eRecurs!*\mb{6}*!:ll:!*\ml{43-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "RegalelaGEr"}\onslide<43->{ \bjava{:lan:ret:c:urn:ran: = true}}}
            };
\node[above right,gray] at(a.south west) {\(1\)};
\begin{onlyenv}<handout:-3|8-42>\node[b,right=-4cm,yshift=-.1cm] (b) at(a.east) {%
\begin{plainjava}
!*\MD8*!boolean isPalindromeRecursive:ll:
    !*\MD9*!if(s.length() < 2) return:ll:
    !*\MD{10}*!else if(s.charAt(0) != s.c:ll:
    !*\MD{11}*!else return isPalindrom!*\mb[1-]{14-41}*!eRe!*\mb{12-13}*!:ll:!*\ml{42-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "regalelager"}\onslide<42->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
\node[above right,gray] at(b.south west) {\(2\)};
    \end{onlyenv}
\begin{onlyenv}<handout:-3|15-41>\node[b,right=-4cm,yshift=-.1cm] (c) at(b.east) {%
\begin{plainjava}
!*\MD{15}*!boolean isPalindromeRecursive:ll:
    !*\MD{16}*!if(s.length() < 2) return:ll:
    !*\MD{17}*!else if(s.charAt(0) != s.c:ll:
    !*\MD{18}*!else return isPalindrom!*\mb[1-]{19-40}*!eRe:ll:!*\ml{41-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "egalelage"}\onslide<41->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
\node[above right,gray] at(c.south west) {\(3\)};
    \end{onlyenv}
\begin{onlyenv}<handout:-3|20-40>\node[b,right=-4cm,yshift=-.1cm] (d) at(c.east) {%
\begin{plainjava}
!*\MD{20}*!boolean isPalindromeRecursive:ll:
    !*\MD{21}*!if(s.length() < 2) return:ll:
    !*\MD{22}*!else if(s.charAt(0) != s.c:ll:
    !*\MD{23}*!else return isPalindrom!*\mb[1-]{24-39}*!eRe:ll:!*\ml{40-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "galelag"}\onslide<40->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
    \node[above right,gray] at(d.south west) {\(4\)};
    \end{onlyenv}
\begin{onlyenv}<handout:-3|25-39>\node[b,right=-4cm,yshift=-.1cm] (e) at(d.east) {%
\begin{plainjava}
!*\MD{25}*!boolean isPalindromeRecursive:ll:
    !*\MD{26}*!if(s.length() < 2) return:ll:
    !*\MD{27}*!else if(s.charAt(0) != s.c:ll:
    !*\MD{28}*!else return isPalindrom!*\mb[1-]{29-38}*!eRe:ll:!*\ml{39-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "alela"}\onslide<39->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
\node[above right,gray] at(e.south west) {\(5\)};
    \end{onlyenv}
\begin{onlyenv}<handout:3|30-38>\node[b,right=-4cm,yshift=-.1cm] (f) at(e.east) {%
\begin{plainjava}
!*\MD{30}*!boolean isPalindromeRecursive:ll:
    !*\MD{31}*!if(s.length() < 2) return:ll:
    !*\MD{32}*!else if(s.charAt(0) != s.c:ll:
    !*\MD{33}*!else return isPalindrom!*\mb[1-]{34-37}*!eRe:ll:!*\ml{38-}*!
}
\end{plainjava}\medskip
\centerline{\bjava{s = "lel"}\onslide<38->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
\node[above right,gray] at(f.south west) {\(6\)};
    \end{onlyenv}
\begin{onlyenv}<handout:3|35-37>\node[b,right=-4cm,yshift=-.1cm] (g) at(f.east) {%
\begin{plainjava}
!*\MD{35}*!boolean isPalindromeRecursive:ll:
    !*\MD{36}*!if(s.length() < 2) return:ll:!*\ml[1-]{37-}*!
    else if(s.charAt(0) != s.c:ll:
    else return isPalindromeRe:ll:
}
\end{plainjava}\medskip
\centerline{\bjava{s = "e"}\onslide<37->{ \bjava{:lan:ret:c:urn:ran: = true}}}
        };
\node[above right,gray] at(g.south west) {\(7\)};
    \end{onlyenv}
    \end{tikzpicture}
\end{center}
\end{onlyenv}
\begin{tikzpicture}[remember picture,overlay]
    \onslide<handout:4-|44->{\node[left=-7mm,scale=.8] at(current page.-20) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}
\fi

\iffull
\begin{frame}[c,fragile]{Iterativer Ansatz}
    \begin{itemize}[<+(1)->]
        \item Diese Aufgabe lässt sich auch iterativ prüfen.
        \item Für das Palindrom schauen wir für jedes Zeichen \(i\) der \say{linken Hälfte} ob es mit dem gespiegelten \(\text{\T{length}} - i - 1\) der \say{rechten Hälfte} übereinstimmt:
    \end{itemize}
\begin{plainjava}
!*\onslide<4->*!public static boolean isPalindromeIterative(String s) {
!*\onslide<5->*!    s = s.toLowerCase();
!*\onslide<6->*!    for(int i = 0; i < s.length() / 2; i++) {
!*\onslide<7->*!        if(s.charAt(i) != s.charAt(s.length() - i - 1))
!*\onslide<7->*!            return false;
!*\onslide<6->*!    }
!*\onslide<8->*!    return true;
!*\onslide<4->*!}
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Iterativer Ansatz, II}
    \lstfs{10}\begin{itemize}[<+(1)->]
        \item Dies können wir als \only<-9|handout:0>{???}\only<10->{Tail}-Rekursion umschreiben:
    \end{itemize}
\begin{plainjava}
!*\CodeFileMarkerAttach<3->{PalindromeIterative.java}*!
!*\onslide<3->*!public static boolean isPalindrome(String s) {
!*\onslide<4->*!    return helper(s.toLowerCase(), 0);
!*\onslide<3->*!}
!*\onslide<3->*!
!*\onslide<5->*!private static boolean helper(String s, int i) {
!*\onslide<6->*!    if (i >= s.length() / 2)
!*\onslide<6->*!        return true;
!*\onslide<7->*!    if (s.charAt(i) != s.charAt(s.length() - i - 1))
!*\onslide<7->*!        return false;
!*\onslide<8->*!    return helper(s, i + 1);
!*\onslide<5->*!}
\end{plainjava}
\begin{tikzpicture}[overlay, remember picture]
\begin{uncoverenv}<9->
    \node[above left=.925cm,text width=9.65cm,draw=gray,thick,rounded corners=2pt,scale=.65,yshift=.25cm] at(current page.south east) {%
\begin{plainjava}[aboveskip=0pt, belowskip=0pt]
s = s.toLowerCase();
for(int i = 0; i < s.length() / 2; i++) {
    if(s.charAt(i) != s.charAt(s.length() - i - 1))
        return false;
}
return true;
\end{plainjava}
    };
\end{uncoverenv}
\end{tikzpicture}
\end{frame}
\fi


\begin{frame}
    TODO: rekursions arten undZeichnen: TOODO. schauen für anschnitt rekursion und übernahme oder so

    TODO: fehler in lösung irgendwo..
    TODO: aussicht
\end{frame}

\SetNextSectionText[.55\linewidth]{TODO}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep5pt
    \item TODO
\end{itemize}
\end{frame}
}

% TODO: pascal case


\outro{\vskip9mm\centering \onslide<2->{\scalebox{1.35}{\begin{tikzpicture}
       % TODO
    \end{tikzpicture}}}}

\iffull\end{document}\fi
