\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\definecolor{@joda}{RGB}{204, 186, 157}
\definecolor{@joda@}{RGB}{78, 68, 66}
\setbox\pinguA=\hbox{\tikz\pingu[body=pingu@green!52!pingu@black,body front=pingu@green!52!pingu@black!5!pingu@white,cloak=@joda,cloak cap=@joda,lightsaber right=pingu@green,lightsaber right length=1.4cm,shirt=@joda@,shirt no buttons,small,eyes wink,cane left=pingu@bronze!80!pingu@black,cane left length=11mm,cane left raise=1mm,right item angle=-30];}
\titlesuffix{\tikzpicture[overlay,remember picture]
    \node[above left,yshift=\btdmfootheight-1mm] at(current page.south east) {\copy\pinguA};
\endtikzpicture}
\def\packtitlenode#1#2{\node[font=\usebeamerfont{title},inner xsep=0pt,opacity=#1,outer ysep=2pt] (#2) {getauscht};}
\title[Erstes Tutorium -- Übungsblatt 2]{Diese Worte \texorpdfstring{\,\setbox0=\hbox{getau\kern5pt\relax scht}\phantom{\copy0}\llap{\tikz[baseline=(k.base)]{%
\packtitlenode0k
\def\kA{310}\def\kB{130}\def\kS{-.5\wd0-5pt}
\scope[xshift=-\kS]\packtitlenode0x
\clip (x.south west)--(x.\kA)--(x.\kB)-| cycle;
\packtitlenode1x
\endscope
\scope[xshift=\kS]
\packtitlenode0y
\clip (y.south east)--(y.\kA)--(y.\kB)-| cycle;
\packtitlenode1y
\endscope
% cutline
\fill[btdm@border@down,rounded corners=1.5pt] ([yshift=4pt,xshift=1.5pt]y.\kA)--([yshift=-4pt]y.\kB)--++(-3pt,0)--([xshift=-1.5pt,yshift=4pt]y.\kA) -- cycle;
\fill[btdm@border@down,rounded corners=1.5pt] ([yshift=4pt,xshift=-1.5pt]x.\kA)--([yshift=-4pt,xshift=-1.5pt]x.\kB)--++(3pt,0)--([xshift=1.5pt,yshift=4pt]x.\kA) -- cycle;
}\kern-.5\wd0}\;~}{getauscht} ich habe}
\subtitle{Tutorium Zwei}
\date{KW 19}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{2}

\iffull\begin{document}
\titleframe

\TopicOverview{2}
\fi

\iffull{\SummaryFrame
\def\sub#1#2{\node[font=\tiny\sffamily,align=center,gray,below=-3mm] at(#1.south) {\strut#2\strut};}
\begin{frame}[fragile,c]{Kurzwiederholung}
    \begin{itemize}[<+(1)->]
        \itemsep14pt
        \item Algorithmenkonstruktion\smallskip\par \centerline{%
            \begin{tikzpicture}
                \onslide<+(1)->{\node (0) at(0,0) {\strut Spezifikation};
                \sub0{Begriffe mit\\Problemrelevanz}}
                \foreach[count=\i,remember =\i as \li (initially 0)] \a/\t in {Abstraktion/{Gegeben \& Gesucht},{\makebox[14mm]{\only<8->{\sbseries}Entwurf}}/{Algorithmus},Verifikation/{Termination \&\\partielle Korrektheit},Aufwandsanalyse/{Laufzeitverhalten}} {
                    \onslide<+(1)->{\node[right=.5mm] (k\i) at(\li.east) {\strut\faAngleRight};
                    \node[right=.5mm] (\i) at (k\i.east) {\strut\a};
                    \sub\i{\t}}
                }
            \end{tikzpicture}}\vspace*{-\medskipamount}
        \item<9-> Kerneigenschaften eines Algorithmus: \begin{itemize}
            \item<10-> Von einem Prozessor \info{Mensch,~\ldots} in endlich vielen Schritten Ausführ- und Reproduzierbar
            \item<11-> Eine endliche Beschreibung in Elementaroperationen.
        \end{itemize}
        \item<12-> Abstrakte Variablenoperationen:
\begin{plainjava}
!*\onslide<13->*!long x; !*\tikzmarknode{@1}{\phantom{Ig}}*!
!*\onslide<13->*!x = 21; !*\tikzmarknode{@2}{\phantom{Ig}}*!
!*\onslide<13->*!x = 42; !*\tikzmarknode{@3}{\phantom{Ig}}*!
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
\onslide<14->{\node[right,T] at(@1.east) {\textbf{Deklaration} --- Reservieren von Namen mit Typ long};}
\onslide<15->{\node[right,T] at(@2.east) {\textbf{Initialisierung} --- Erste Wertzuweisung, macht die Variable verwendbar};}
\onslide<16->{\node[right,T] at(@3.east) {\textbf{Wertzuweisung} --- Überschreiben/Ändern des vorherigen Wertes};}
\end{tikzpicture}
\onslide<1->
\end{frame}
}\fi

\SetNextSectionText{\say{Mach's farbig}\\--- Isabell Bannweg}
\iffull
\section[Programmparameter]{Exkurs: Kommandozeilenparameter}
\begin{frame}[fragile]{M-Array me und andere Zukunftsträume}
    \begin{itemize}[<+(1)->]
        \itemsep9pt
        \item Arrays werden später genauer behandelt.
        \item Arrays sind Listen fester Größe die Elemente des gleichen Datentyps beinhalten.
        \item Wir notieren sie mit \T{[]}:
\begin{plainjava}[lineskip=2pt]
!*\onslide<5->*!int!*\tikzmarknode{@}{\sbasic{\HStrut[]}}*! arr = {!*\tikzmarknode{@0}{\snum{\HStrut42}}*!, !*\tikzmarknode{@2}{\snum{\HStrut-7}}*!,  !*\tikzmarknode{@4}{\snum{\HStrut13}}*!};

!*\onslide<7->*!System.out.println(!*\tikzmarknode{@3}{\sbasic{arr[\snum{\HStrut1}]}}*!);!*\onslide<9->*! // :yields: -7

!*\onslide<10->*!System.out.println(!*\tikzmarknode{@5}{\sbasic{\HStrut arr.length}}*!);!*\onslide<12->*! // :yields: 3

!*\onslide<13->*!System.out.println(!*\tikzmarknode{@6}{\sbasic{arr[arr.length - \snum{\HStrut1}]}}*!); !*\onslide<15->*!// :yields: 13
!*\onslide<1->*!
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture,codeouthl]
    \def\hlhs{0mm}
    \onslide<6->{
        \hlcode[-.35pt]{@}{array}
        \draw[Kite-] ([yshift=-.2mm]@.south) to[out=290,in=180] ++(1,-.35) node[right] {\small\itshape Ein Array an Integern};
    }
    \onslide<8->{
        \def\hlopa{.6}
        \def\hlcolor{pingu@yellow}\hlcode[-.35pt]{@2}{-7}
        \hlcode[-.35pt]{@3}{1}
        \node at(@2) {\snum{\HStrut-7}};
        \node at(@3) {\sbasic{\HStrut arr[\snum{1}]}};
    }
    \onslide<9->{\draw[Kite-] ([yshift=-.2mm]@3.330) to[out=240,in=0] ++(-1,-.25) node[left] {Beginnt bei \(0\)};}
    \onslide<14->{
        \def\hlopa{.6}
        \def\hlcolor{pingu@green}\hlcode[-.35pt]{@4}{13}
        \hlcode[-.35pt]{@6}{1}
        \node at(@4) {\snum{\HStrut13}};
        \node at(@6) {\sbasic{\HStrut arr[arr.length - \snum{1}]}};
    }
    \onslide<11->{
        \def\hlopa{.6}\def\hlcolor{pingu@red}
        \hlcode[-.35pt]{@5}{1}
        \node at(@5) {\sbasic{\HStrut arr.length}};
        \node[above=-1.25mm,opacity=.6,pingu@red] at(@0.north) {\textbullet};
        \node[above=-1.25mm,opacity=.6,pingu@red] at(@2.north) {\textbullet};
        \node[above=-1.25mm,opacity=.6,pingu@red] at(@4.north) {\textbullet};
    }
    \onslide<12->{\draw[Kite-] ([yshift=-.2mm]@5.335) to[out=240,in=0] ++(-1,-.3) node[left] {Liefert die Array-Größe};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Die Sache mit dem \T{\bfseries String[] args}}
% I am not using \SetupLstHl because i want the fade out... of course i do... :c
\begin{uncoverenv}<2->
\begin{plainjava}[lineskip=4pt]
!*\only<2|handout:0>{\sbasic{\skA{public class} Example \{}}\only<3->{\sbasic{\color{codeouthl}public class Example \{}}*!
    !*\only<2|handout:0>{\sbasic{\skA{public} \skB{static void} main(}}\only<3->{\sbasic{\color{codeouthl}public static void main(}}*!String[] args!*\only<2|handout:0>{\sbasic{) \{}}\only<3->{\sbasic{\color{codeouthl}) \{}}*!
        !*\onslide<6->*!System.out.println(args.length);!*\onslide<1->*!
    !*\only<2|handout:0>{\sbasic{\}}}\only<3->{\sbasic{\color{codeouthl}\}}}*!
!*\only<2|handout:0>{\sbasic{\}}}\only<3->{\sbasic{\color{codeouthl}\}}}*!
\end{plainjava}
\end{uncoverenv}
\begin{itemize}[<+(1)->]
    \itemsep6pt
    \item<4-> Hier haben wir ein Array von Strings.
    \item<5-> Dieses wird von der Java Virtual Machine gefüllt.
    \item<7-> Beim Programmstart mit \cbash{java Example}, können wir Argumente übergeben.
\end{itemize}
\end{frame}

\iffull
\MakeThePinguExplainIt[text width=3.5cm]{cap=!hide,eye patch right,eye patch left,headband=paletteA,bill=flat,lollipop left,right item angle=-30,cup=!hide,glasses=!hide,body type=legacy}{Fürs Erste werden wir es dabei belassen.}
\begin{frame}[fragile,c]{Ein wunderbares Beispiel}
\SetupLstHl
\begin{plainjava}[lineskip=4.5pt]
!*\onslide<2->*!|ihl|public class Example {|ihl|
!*\onslide<2->*!    |ihl|public static void main(|ihl|String[] !*\tikzmarknode{args}{\sbasic{\HStrut args}}*!|ihl|) {|ihl|

!*\onslide<3->*!        for(int !*\tikzmarknode{i}{\sbasic{\HStrut i}}*! = 0; !*\tikzmarknode{i4}{\sbasic{\HStrut i}}*! < !*\tikzmarknode{args-length}{\sbasic{\HStrut args.length}}*!; !*\tikzmarknode{i2}{\sbasic{\HStrut i}}*!++) {
!*\onslide<4->*!            System.out.println(!*\tikzmarknode{args-a}{\sbasic{\HStrut args[}\kern-1pt}\kern1pt\tikzmarknode{i3}{\sbasic{\HStrut i}}\kern1pt\tikzmarknode{args-b}{\kern-1pt\sbasic{\HStrut ]}}*!);
!*\onslide<3->*!        }

!*\onslide<2->*!    |ihl|}|ihl|
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<5->{\node[below left,xshift=-5mm,yshift=-1.65cm,outer sep=0pt, inner sep=0pt] (@) at(current page.north east) {\bbash{Hermeline mögen Mäuse}};
    \node[left=0pt,outer sep=0pt, inner sep=0pt] (@2) at(@.west) {\bbash{java Example}\T{~}\null};}
    \def\hlhs{.1mm}
    \onslide<6->{
        \draw[decoration={brace,aspect=.85},decorate] (@.south east) to coordinate[pos=.85] (@3) (@.south west);
        \draw[-Kite] ([yshift=-4pt]@3.south) to[out=220,in=40] ([yshift=3pt]args.north);
    }
    \onslide<7->{
        \def\hlopa{.5}
        \def\hlcolor{pingu@green}\hlcode[-.35pt]{args}{@args}
        \node at(args) {\sbasic{\HStrut args}};
        \node[T,below right] at(args.south) {args = \{\T{\dq}Hermeline\T{\dq}, \T{\dq}mögen\T{\dq}, \T{\dq}Mäuse\T{\dq}\}};
    }
    \onslide<8->{
        \def\hlopa{.5}
        \def\hlcolor{pingu@green}\hlcode[-.35pt]{args-length}{@args}
        \node at(args-length) {\sbasic{\HStrut args.length}};
        \node[above,pingu@green] at (args-length.north) {\sbseries\itshape 3};
    }
    \onslide<10->{{
        \def\hlopa{.5}
        \def\hlcolor{pingu@green}
        \hlcode[-.35pt]{args-a}{@args}\node at(args-a) {\sbasic{\HStrut args[\kern-1pt}};
        \hlcode[-.35pt]{args-b}{@args}\node at(args-b) {\sbasic{\kern-1pt\HStrut ]}};
    }}
    \onslide<9->{
        \def\hlopa{.275}
        \def\hlcolor{pingu@yellow}
        \hlcode[-.35pt]{i}{@i}\node at(i) {\sbasic{\HStrut i}};
        \hlcode[-.35pt]{i2}{@i}\node at(i2) {\sbasic{\HStrut i}};
        \hlcode[-.35pt]{i3}{@i}\node at(i3) {\sbasic{\HStrut i}};
        \hlcode[-.35pt]{i4}{@i}\node at(i4) {\sbasic{\HStrut i}};
    }
    \onslide<11->{ \node[below right,yshift=-1mm] (@a) at (i3.south) {\T{Hermeline}}; \draw[very thick,pingu@green!50!btdm@background,-Kite,rounded corners=2pt] (args-a.south) |- (@a); \node[left=1cm,pingu@yellow] at (@a.west) {\T{\sbseries i\,=\,0}};}
    \onslide<12->{ \node[below right,yshift=-.635cm] (@b) at (i3.south) {\T{mögen}}; \draw[very thick,pingu@green!50!btdm@background,-Kite,rounded corners=2pt] (args-a.south) |- (@b); \node[left=1cm,pingu@yellow] at (@b.west) {\T{\sbseries i\,=\,1}}; }
    \onslide<13->{ \node[below right,yshift=-1.2cm] (@c) at (i3.south) {\T{Mäuse}}; \draw[very thick,pingu@green!50!btdm@background,-Kite,rounded corners=2pt] (args-a.south) |- (@c); \node[left=1cm,pingu@yellow] at (@c.west) {\T{\sbseries i\,=\,2}};}
    \onslide<0|handout:1>{\node[left=-2mm,xshift=5mm,scale=.8,yshift=\btdmfootheight] at(current page.-16) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
\fi

%     \item<8-> Mit \bbash{java Example Hermeline mögen Mäuse} ist \bjava{args = \{"Hermeline", "mögen", "Mäuse"\}}.

\iffull
\begin{frame}[c]{}
    \strut\bigskip\par\centering\scalebox{.8}{\begin{tikzpicture}
        \only<2->{\pingu[right wing shock,tie=paletteA,halo,name=pingu-a,left wing wave]
        \node[ellipse callout,draw,callout absolute pointer={([yshift=2mm,xshift=-4mm]pingu-a-wing-left-tip)},above right=6mm,align=center] at(pingu-a-wing-left-tip) {Zahlen als Parameter\\werden leider auch\\zu \bjava{String}.};}

        \scope[shift={(current bounding box.east)},yshift=-6mm,xshift=1cm]
            \only<3->{\pingu[eyes hearts,eyes color=paletteC!20!pingu@black,wings raise,halo,name=pingu-b,shirt=pingu@blue!80!pingu@white,second shirt=pingu@purple!70!pingu@white]
            \node[ellipse callout,draw,callout absolute pointer={([yshift=2mm,xshift=-2mm]pingu-b-wing-left-tip)},above right=6mm,align=center] at(pingu-b-wing-left-tip) {Wir machen\\einen eigenen\\Zahlenkonverter.};}
        \endscope
    \end{tikzpicture}}\bigskip
    \begin{center}
        \onslide<4->{\textit{Leider} nein.}\quad \onslide<5->{Wir greifen \say{nur} vor\ldots}\qquad \onslide<6->{\scalebox{.8}{\begin{tikzpicture}[align-half-base]
            \pingu[body type=legacy,eyes sad,wings grab,feet sit]
        \end{tikzpicture}}}
    \end{center}
    % TODO: Wrapper-klassen für Integer-parseInt und so
\end{frame}
\fi

\begin{frame}{\T{\sbseries int}? Wie primitiv!}
    \begin{itemize}
        \itemsep14pt
        \item<2-> Für jeden primitiven Datentyp existiert eine \say{Wrapper-Klasse}\onslide<3->{\clap{\smash{\raisebox{-.4\height}{\rotatebox{10}{\textbf{KLASSE??}}}}}}
        \item<4-> Wie \bjava{System}, welches uns \bjava{out.println} liefert, gibt es \bjava{Integer} für \bjava{int} \begin{itemize}
            \itemsep4pt
            \item<5-> \bjava{Integer.parseInt(...)}, \bjava{Double.parseDouble(...)},~\ldots\ konvertieren \bjava{\"42\"} zu \bjava{42}
            \item<6-> Genauer liefert \bjava{Integer.parseInt(\"42\")} die Zahl \bjava{42} zurück
            \item<7-> Wir gehen hier zunächst nur von gültigen Eingaben (Zahlen) aus
        \end{itemize}
        \item<8-> Nun sind wir gewappnet für die Präsenzaufgabe!
    \end{itemize}
\end{frame}
\fi

\SetNextSectionText{Es gibt keine if-Schleifen, sondern nur if-Abfragen!\\--- \IfBtdmDarkmode{}{\def\fancyulbackground{btdm@primary}}\link{http://if-schleife.de/}{if-schleife.de}}
\section{Präsenzaufgabe}
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Wenn\ldots\ Ja wenn nur die Schleife nicht wär\ldots}
    \onslide<2->{Legen Sie eine Java Datei namens \T{ErsteSchleife.java} an \info{oder bearbeiten Sie die Aufgabe auf einem Blatt Papier}.} \onslide<3->{Lesen Sie in der main Methode eine \bjava{int} Variable namens \(n\) über die Kommandozeilenparameter ein und implementieren Sie eine for Schleife, die jede dritte Zahl von \(1\) bis einschließlich \(n\) ausgibt.}
    \onslide<4->Beispiel:
\begin{plainjava}
n = 13 !*\onslide<5->*!// :yields: 1 4 7 10 13
\end{plainjava}
\onslide<1->
\end{aufgabe}
\end{frame}

\begin{frame}[fragile]{Ein Schleifenzähler}
    \DoAnimations
    \begin{itemize}
        \item<2-> Mit dem Vorwissen ist es an sich nur Einsetzen:
\begin{plainjava}[lineskip=2pt]
$3->$public class ErsteSchleife {
$4->$    public static void main(String[] args) {
$5->$        int n = Integer.parseInt(args[0]);$5->\tikzmarknode{robust}{\HStrut}$
$6->$        for(int i = 1; i <= n; i = i + 3){
$7->$            System.out.$7->\tikzmarknode{println}{\text{\sbasic{println}}}$(i);
$6->$        }
$4->$    }
$3->$}
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<8->{
        \draw[thick,paletteA,opacity=.3,decoration={snake,amplitude=1.25pt},decorate] ([yshift=-1pt]println.south east) to coordinate[pos=.5] (@) ([yshift=-1pt]println.south west);
    }
    \onslide<9->{
        \draw[Kite-,gray] ([yshift=-2pt]@) to[out=270,in=180] ++(1,-.5) node[right,align=left] (@2) {Das Beispiel der Aufgabe hatte keine neuen Zeilen!};
    }
    \onslide<10->{
        \node[below right,yshift=1mm,gray] at (@2.south west) {Dafür gibt es \say{print} anstelle von \say{print \textbf{l}i\textbf{n}e}.};
    }
    \onslide<11->{
        \draw[Kite-,gray] (robust) to[out=0,in=180] ++(.5,-.15) node[below right,align=left,yshift=.6\baselineskip] {Was, wenn es keine\\Argumente gibt? Hier\\hilft eine if-Abfrage};
    }
    \only<12->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath ErsteSchleife.java}{ErsteSchleife.java}\;};}
\end{tikzpicture}
\end{frame}

\iffull
\begin{frame}[fragile]{In the Mean-While}
\DoAnimations
\begin{itemize}
    \itemsep4pt
    \item<2-> Wir können dies aber auch mit einer \bjava{while}-Schleife machen (links)
\columns[onlytextwidth,c]
\column{.475\linewidth}
\begin{plainjava}
$3->$int i = 1;
$4->$while(i <= n) {
$5->$    System.out.print(i + " ");
$6->$    i += 3;
$4->$}$1->$
\end{plainjava}
\column{.525\linewidth}
\begin{plainjava}
$8->$int i = 1;
$9->$if(n > 0) {$9->\tikzmarknode{check}{\HStrut}$
$10->$    do {
$11->$        System.out.print(i + " ");
$12->$        i += 3;
$10->$    } while (i <= n)$10->\tikzmarknode{semi}{\text{\sbasic{;}}}$
$9->$}$1->$
\end{plainjava}
\smallskip
\endcolumns
    \item<7-> Oder mit einer \bjava{do}-\bjava{while}-Schleife (rechts)
    \item<15-> \say{\bbash{java ErsteSchleife 12}} liefert die Ausgabe \say{\bbash{1 4 7 10 }}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<13->{\node[right,T] at(semi.east) {\say{;}~Nicht vergessen!};}
    \onslide<14->{\node[right,T] (@) at(check.east) {Soll die Schleife überhaupt}; \node[below right,yshift=1.35mm,T] at(@.south west) {einmal laufen?};}
    \only<16->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath ErsteSchleifeWhile.java}{ErsteSchleifeWhile.java}, \textattachfile{\curpath ErsteSchleifeDoWhile.java}{ErsteSchleifeDoWhile.java}\;};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Essen für die Reste!}
\DoAnimations
\begin{itemize}[<+(1)->]
    \itemsep4pt
    \item Anstelle von \(i \gets i + 3\) können wir beispielsweise auch Modulo-Rechnen:
\begin{plainjava}
$3->$for (int i = 0; i <= n; i++) {
$4->$    if(i % 3 == 1)
$5->$        System.out.print(i + " ");
$3->$}
\end{plainjava}
    \item<6-> Es gibt eigentlich immer etliche Möglichkeiten\ldots
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \only<7->{\node[above left,yshift=\btdmfootheight] at (current page.south east) {\textattachfile{\curpath ErsteSchleifeModulo.java}{ErsteSchleifeModulo.java}\;};}
\end{tikzpicture}
\end{frame}
\fi


\SetNextSectionText{Algorithmen, Datentypen, Boolesche Ausdrücke\\Abgabe: \DTMDate{2022-05-09}}
\section{Übungsblatt 2}
\subsection{Aufgabe 1}
{\def\C#1{\textbf{\llap{\raisebox{1pt}{\scriptsize\faCaretRight}\;}#1}}
\begin{frame}{Aufgabe 1: Algorithmen und Unteralgorithmen}
    \task{%
    \onslide<2->{Oft ist es zur besseren Strukturierung notwendig komplexere Algorithmen aufzuteilen. Dies ist beispielsweise der Fall, wenn Code-Elemente häufig an verschiedenen Stellen eingesetzt werden oder wenn es der Übersichtlichkeit dienen soll. Im Folgenden sollen Sie einen einfachen Sortieralgorithmus in zwei Teilalgorithmen umsetzen. Zusätzlich sollen
    Sie lernen die Eingaben (sog. Parameter oder Argumente) des Aufrufs auf Gültigkeit zu überprüfen. Für zukünftige Aufgaben sollen Sie dies selbstständig erkennen und umsetzen.}\medskip
\columns[onlytextwidth,c]
\column{.4125\linewidth}
\onslide<5->{\scalebox{.8}{\begin{tabular}{cc *4c l}
    \toprule
        \multicolumn{2}{c}{Indizes} & \multicolumn{4}{c}{Liste} & Vertauschen? \\
        i & j & \(l_1\) & \(l_2\) & \(l_3\) & \(l_4\) & \\
        \midrule
        1 & 2 & \C5 & \C8 & 4 & 0 & Nein, denn \(5 \not>8\) \\
        1 & 3 & \C5 & 8 & \C5 & 0 & Ja, denn \(5 > 4\) \\
        1 & 4 & \C4 & 8 & 5 & \C0 & Ja, denn \(4 > 0\) \\
        \multicolumn{7}{c}{Runde vorbei, alle \(j \in \{i + 1, \ldots, N\}\) betrachtet!} \\
        2 & 3 & 0 & \C8 & \C5 & 5 & Ja, denn \(8 > 5\) \\
        2 & 4 & 0 & \C5 & 8 & \C4 & Ja, denn \(5 > 4\) \\
        \multicolumn{7}{c}{Runde vorbei, alle \(j \in \{i + 1, \ldots, N\}\) betrachtet!} \\
        3 & 4 & 0 & 4 & \C8 & \C5 & Ja, denn \(8 > 5\) \\
        \multicolumn{7}{c}{Fertig, alle \(i \in \{1, \ldots, N - 1\}\) betrachtet!} \\
        \multicolumn{2}{r}{\(\rightarrow\)} & 0 & 4 & 5 & 8 \\
    \bottomrule
\end{tabular}}}
\column{.5875\linewidth}
\onslide<3->{Gehen Sie zur Sortierung nach folgendem Schema vor.\medskip}

\onslide<4->{Seien \(l_1, \ldots, l_N\) die Werte einer Liste \(L\) der Länge \(N\). Für \textit{jedes} \(i \in \{1, \ldots, N - 1\}\) betrachte der Reihe nach \textit{jedes} \(l_j\) mit \(j \in \{i + 1, \ldots, N\}\) und vergleiche \(l_i\) mit \(l_j\). Falls \(l_i > l_j\) vertausche \(l_i\) und \(l_j\) und fahre mit dem nächsten \(j\) fort.}\bigskip\par
\onslide<6->{So sortiert der beschriebene Algorithmus die Liste \((5, 8, 4, 0)\) aufsteigend zu \((0, 4, 5, 8)\). Die beiden\;~~~\C{Markierungen} je Zeile geben an, welche Elemente in dem jeweiligen Schritt verglichen werden.}
\endcolumns
    }
\end{frame}}

{\taskenum
\SetAlgoVlined
\MakeThePinguExplainIt[text width=5cm]{cap=!hide,pumpkin-hat,cup=paletteC,right item angle=-10}{In der Aufgabe stand etwas von \say{größer als~1}, aber wie wir Listen indizieren ist nicht von uns standardisiert.}
\begin{frame}{Elemente vertauschen}
\begin{enumerate}
    \item \task<2->{Entwerfen Sie einen Algorithmus, der gegeben einer Liste und zwei Indizes die entsprechenden Elemente
vertauscht. Stellen Sie sicher, dass die Indizes \(i\) und \(j\) gültig sind, d.h. dass sie \only<9->{\expandafter\textbf}{größer als \(1\)} und kleiner als die
Länge der Liste sind. Stellen Sie zudem sicher, dass die Länge der Liste mindestens \(2\) beträgt. Der Algorithmus soll für den Fall der Ungültigkeit mit einer Fehlermeldung abbrechen.}\medskip
\onslide<3->{\begin{algorithm}[H]
\PreCode
    \KwIn{List \(L = (l_1, \ldots, l_N)\), Index \(i\), and Index \(j\)}\medskip
\StartCode
    \onslide<4->{\If{\(N < 2\) \KwOr \(i < 1\) \KwOr \(j < 1\) \KwOr \(i > N\) \KwOr \(j > N\)}{
        \onslide<5->{print \say{Eingabe ungültig!} to output device\;
        stop program\;}
    }}

    \onslide<6->{make new \(t\) have value \(l_i\)\;}
    \onslide<7->{make \(l_i\) have value \(l_j\)\;}
    \onslide<8->{make \(l_j\) have value \(t\)\;}
\end{algorithm}}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10-|handout:1>{\node[left=-2mm,xshift=5mm,scale=.8,yshift=\btdmfootheight] at(current page.-16) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{enumerate}
\end{frame}
\begin{frame}{Sich den Tag schön-sortieren}
\begin{enumerate}
    \setcounter{enumi}{1}
    \item<2-> \task{Entwerfen Sie einen Algorithmus, der genau nach dem angegebenen Schema eine Liste sortiert. Stellen Sie auch hier sicher, dass die Liste mindestens zwei Elemente hat. Falls Sie Teilaufgabe~a) nicht bearbeitet haben, können Sie annehmen, dass der Algorithmus \T{vertausche(L, i, j)} zur Verfügung steht.}\medskip
\onslide<3->{{\small\begin{algorithm}[H]
\PreCode
    \KwIn{List \(L = (l_1, \ldots, l_N)\)}\medskip
\StartCode
\onslide<4->{\If{\(N < 2\)}{
    \onslide<5->{print \say{Eingabe ungültig!} to output device and stop program\;}
}}
\onslide<6->{Make new \(i\) have value \(1\)\;
\While{\(i < N\)}{
    \onslide<7->{Make new \(j\) have the value \(i + 1\)\;
    \While{\(j \leq N\)}{
        \onslide<8->{\lIf{\(l_i > l_j\)}{call \T{vertausche(L, i, j)}}}
        Increment \(j\) by \(1\)\;
    }}
    Increment \(i\) by \(1\)\;
}}
\end{algorithm}}}
\end{enumerate}
\end{frame}

{\def\G#1{\textcolor{gray}{#1}}
\def\J#1{\textbf{\paletteC{\small\itshape#1}}}
\def\K#1{\textbf{\paletteC{\small\itshape\only<18->{\color{codeouthl}}#1}}}% special waste :D
\def\E{\,{\color{gray}E}\color{btdm@text}}% fix grouping bug-raise in compactmode
\begin{frame}{Du kriegsts' nicht raus? Better Call Gauß!}
\begin{enumerate}
    \setcounter{enumi}{2}
    \item<2-> \task{Geben Sie eine worst-case Laufzeitabschätzung für Ihren Algorithmus aus Teilaufgabe~b) an. Falls Sie Teilaufgabe~a) nicht bearbeitet haben, können Sie annehmen, dass das Vertauschen (inkl. aller  Überprüfungen höchstens) neun elementare Operationen benötigt. Begründen Sie Ihre Antwort.}\medskip\par
    \onslide<3->{\say{Wir} haben die~a) bearbeitet. Also\ldots Lets begin!\medskip}
\onslide<4->{\begin{algorithm}[H]
\PreCode
    \only<5->{\color{codeouthl}}\KwIn{List \(L = (l_1, \ldots, l_N)\), Index \(i\), and Index \(j\)}\bigskip
\StartCode
    \color{btdm@text}
    \DontPrintSemicolon % to get complexity counters behind
    \If{\smash{\(\overset{\only<6->{\J1}}{N < 2}\)} \KwOr \smash{\(\overset{\only<7->{\J1}}{i < 1}\)} \KwOr \smash{\(\overset{\only<8->{\J1}}{j < 1}\)} \KwOr \smash{\(\overset{\only<9->{\J1}}{i > N}\)} \KwOr \smash{\(\overset{\only<10->{\J1}}{j > N}\)}}{
        \only<18->{\color{codeouthl}}print \say{Eingabe ungültig!} to output device;\only<-10|handout:0>{\;} \only<11->{\quad\K1\tikzmarknode{2-start}{\HStrut}\;}
        stop program;\only<-11|handout:0>{\;} \only<12->{\quad\K1\tikzmarknode{2-end}{\HStrut}\;}
    }

    make new \(t\) have value \(l_i\); \only<-12|handout:0>{\;}\only<13->{\quad\J1\tikzmarknode{3-start}{\HStrut}\;}
    make \(l_i\) have value \(l_j\);   \only<-13|handout:0>{\;}\only<14->{\quad\J1\;}
    make \(l_j\) have value \(t\);     \only<-14|handout:0>{\;}\only<15->{\quad\J1\tikzmarknode{3-end}{\HStrut}\;}
\end{algorithm}}
\end{enumerate}
\begin{tikzpicture}[overlay,remember picture]
    % only because the markers are placed with only
    \only<16->{{\only<18->{\color{codeouthl}}\draw[decoration=brace,decorate] ([xshift=4mm]2-start.north east) to[edge node={node[right=2pt] {\K2 \only<18->{\color{codeouthl} (Nur schlechtester Pfad)}}}] ([xshift=4mm]2-end.south east-|2-start.north east);}}

    \only<17->{\draw[decoration=brace,decorate] ([xshift=4mm]3-start.north east) to[edge node={node[right=2pt] {\J3}}] ([xshift=4mm]3-end.south east-|3-start.north east);}
    \onslide<19->{\node[above left,yshift=\btdmfootheight+.5mm] at(current page.south east) {\sbseries\(\rightarrow~1\E + 1\E + 1\E + 1\E + 1\E + 3\E = 8\E\)\;};}
\end{tikzpicture}
\end{frame}

\def\SW#1#2{\only<-\the\numexpr#1-1\relax|handout:0>{\;}\only<#1->{#2\;}}
\def\L#1{\textbf{\paletteA{\small\itshape#1}}}
\def\K#1{\textbf{\paletteC{\small\itshape\only<19->{\color{codeouthl}}#1}}}% update anim slide
\def\MM#1{\textbf{\paletteC{\small\itshape\only<21-|handout:1>{\color{codeouthl}}#1}}}% update anim slide
\begin{frame}[c]{Du kriegsts' nicht raus? Better Call Gauß!\hfill The Sequel!}
\onslide<2->{{\small\begin{algorithm}[H]
\DontPrintSemicolon
\PreCode
    \only<3->{\color{codeouthl}}\KwIn{List \(L = (l_1, \ldots, l_N)\)}\medskip
\StartCode
\color{btdm@text}
\If{\smash{\(\overset{\only<4->{\J1}}{N < 2}\)}}{
    {\only<20->{\color{codeouthl}}print \say{Eingabe ungültig!} to output device and stop program;\SW5{\quad\K2}}
}
Make new \(i\) have value \(1\);\SW6{\quad\J1}\medskip
\While(\only<14->{\quad\L{N\({}-{}\)1}}){\smash{\(\overset{\only<7->{\MM1}}{i < N}\)}}{
    Make new \(j\) have the value \(i + 1\);\SW8{\quad\J2}\medskip
    \While(\only<15->{\quad\tikzmarknode{inner-loop}{\smash{\L{\only<1-|handout:0>{?}\only<19->{\(\only<1-|handout:0>{{}={}} \frac{\text{N\/}^2 - \text{N}}{\text{2}}\)}}}}}){\smash{\(\overset{\only<9->{\MM1}}{j \leq N}\)}}{\vskip\dimexpr\medskipamount+3pt\relax
        \If{\smash{\(\overset{\only<10->{\J1}}{l_i > l_j}\)}}{call \T{vertausche(L, i, j)};\SW{11}{\quad\J8}}
        Increment \(j\) by \(1\);\SW{12}{\quad\J1}
    }
    Increment \(i\) by \(1\);\SW{13}{\quad\J1}
}
\end{algorithm}}}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<16->{\node[above left,T,align=left,text width=6cm,yshift=\btdmfootheight+1.95cm] at(current page.south east) {Angenommen \(N\) sei \(5\), dann gilt für die Anzahl innerer Schleifendurchläufe:\smallskip\\
    \columns[onlytextwidth,c]
    \only<17->{\column{.3\linewidth}\begin{tabular}{ll}
        i & \# \\
        \midrule
        1 &  4 \\
        2 &  3 \\
        3 &  2 \\
        4 &  1 \\
    \end{tabular}}
    \column{.7\linewidth}
    \only<18->{Wir summieren also von \(1\) bis \(N - 1\). Nach Gauß: \(\frac{N^2 - N}{2}\) \textit{Gesamtdurchläufe}.}
    \endcolumns
    };}
    \onslide<21->{\node[above left,yshift=\btdmfootheight,text width=.6\linewidth] at(current page.south east) {\sbseries\footnotesize\begin{align*}
        \rightarrow~&1\E + 1\E + (N - 1) \cdot (2\E + 1\E) + \frac{N^2 - N}{2} (1\E + 8\E + 1\E) \HStrut\\[-.5mm]
        \color{btdm@text}\only<22->{={}& \color{btdm@text}-1\E + 3\cdot N\E + 5\cdot N^2\E - 5\cdot N\E}\strut \HStrut\\[-.25mm]
        \color{btdm@text}\only<23->{={}& \color{btdm@text}5\cdot N^2\E - 2\cdot N\E - 1\E} \only<23->{\quad \in \O(N^2)}
    \end{align*}};}
\end{tikzpicture}
\end{frame}
}}

\iffull
{\AddonFrame
\begin{frame}{Unterprogramm -dadamm}
    \begin{itemize}[<+(1)->]
        \itemsep15pt
        \item \bjava{System.out.print}, \bjava{Integer.parseInt},~\ldots\ sind keine Elementaroperation
        \item Es sind implementierte Algorithmen, die eine Aufgabe erledigen
        \item Wenn wir bestehende Algorithmen wiederverwenden, heißen sie \say{Unteralgorithmen} \begin{itemize}
            \item Sie erlauben einen ersten Abstraktionsmechanismus um Teilprobleme auszulagern
            \item Ziel ist dann die Komposition aus immer abstrakteren Bausteinen
        \end{itemize}
        \item (Unter-)Algorithmen sind ein wichtiger und elementarer Teil der Programmierung
        \item Die Umsetzung in Java werden wir später betrachten.
    \end{itemize}
\end{frame}
}
\fi

\subsection{Aufgabe 2}
{\taskenum
\begin{frame}{Aufgabe 2: Datentypen}
    \task<2->{Welchen Datentyp würden Sie wählen um folgende Daten zu speichern? \only<3->{\textbf}{Begründen Sie Ihre Antwort!}}\smallskip
    \begin{enumerate}
        \itemsep12pt
        \item<4-> \task{Die Email-Adresse einer Person}
            \onslide<5->{Email-Adressen sind lange Zeichenketten welche auch Sonderzeichen enthalten. Daher ist \bjava{String} naheliegend.}
        \item<6-> \task{Den Akkustand eines Smartphones}
            \onslide<7->{Ein Akkustand wird für gewöhnlich als Ganzzahl angegeben (\(\rightarrow\) \bjava{byte}, \bjava{short}, \bjava{int} und \bjava{long}). Der Akkustand reicht dabei meist von \qtyrange{0}{100}\percent\ \(\rightarrow\) \bjava{byte}.}
        \item<8-> \task{Den Notendurchschnitt einer Prüfung}
            \onslide<9->{Die Noten einer Prüfung ist meist eine Fließkommazahl (\(\rightarrow\) \bjava{float}, \bjava{double}), deren Wertebereich klein mit geringer Auflösung an Nachkommastellen ist (z.B.~1--6 mit einer Nachkommastelle). Deswegen wählen wir hier \bjava{float}.}
    \end{enumerate}
\end{frame}
\begin{frame}{Aufgabe 2: Datentypen\hfill II}
\begin{enumerate}
    \setcounter{enumi}{3}
    \itemsep12pt
    \item<2-> \task{Ein Satzzeichen}
    \onslide<3->{Wir gehen hier von einem Satzzeichen aus, welches durch eine einzige UTF-16 Einheit dargestellt werden kann. In diesem Fall reicht ein \bjava{char} (sonst \bjava{String} das ist aber schon wieder Overkill).}
\end{enumerate}\vfill
\begin{itemize}
    \itemsep9pt
    \item<4-> Eine eindeutig richtige Antwort gibt es nicht \info{Begründungen!}.
    \item<5-> Begründungen wie \say{weniger Speicherplatz} sind problematisch(er) \begin{itemize}
        \itemsep1pt
        \item<6-> Java kann für ein \bjava{byte} auch \qty{32}\bit\ oder mehr (\qty{64}\bit,~\ldots) reservieren
        \item<7-> Analog wird \bjava{boolean} oft als \bjava{byte} umgesetzt \info{\link{https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html\#jvms-2.3.4}{JVMS17~2.3.4}}
        \item<8-> Das hat mit Geschwindigkeit, Parallelisierung, Sicherheit,~\ldots\ zu tun
        %% \item<9-> Bei Arrays sieht das wieder anders aus\ldots
        \item<9-> Für uns in EidI sind die Details nicht wichtig
    \end{itemize}
\end{itemize}
\end{frame}
}

\iffull
{\AddonFrame
\def\dt#1{{\large\bfseries\skB{\HStrut#1}}}
\MakeThePinguExplainIt[text width=6cm,opacity=.6,yshift=-1cm]{cap=!hide,cup=!hide,@block/.append style={fill=#1!40!pingu@white},@draw/.append style={draw=#1!40!pingu@white},glasses=!hide,glasses round,eyes wink,small,hat,body type=chubby}{Das sind \textit{alle} \say{impliziten Typkonvertierungen} in Java.\smallskip\\String hat da nichts zu suchen.}
\setbox\pinguA=\hbox{\tikz{\pingu[@block/.append style={fill=#1!40!pingu@white},@draw/.append style={draw=#1!40!pingu@white},wings grab,eyes shiny,headband=pingu@green,feet=sit]}}
\begin{frame}[c]{Ein wenig mehr über primitive Datentypen}
\centering\begin{tikzpicture}[scale=3,every path/.append style={line cap=round}]
   \onslide<2->{\node[right] (boolean) at(0,0)             {\dt{boolean}};}
   \onslide<3->{\node[right] (byte) at(0,-1.66*1/2.65)     {\dt{byte}};}
   \onslide<3->{\node[right=6.5mm] (short) at(byte.east)   {\dt{short}};}
   \onslide<4->{\node[below=1.35cm] (char) at(short.south) {\dt{char}};}
   \onslide<3->{\node[right=6.5mm] (int) at(short.east)    {\dt{int}};}
   \onslide<3->{\node[right=6.5mm] (long) at(int.east)     {\dt{long}};}
   \onslide<3->{\node[right=6.5mm] (float) at(long.east)   {\dt{float}};}
   \onslide<3->{\node[right=6.5mm] (double) at(float.east) {\dt{double}};}

\begin{scope}[every path/.append style={draw,-Kite}]
\onslide<5->{\path (byte) -- (short);
\path (short) -- (int);
\path (int) -- (long);
\path (long) -- (float);
\path (float) -- (double);}
\onslide<6->{
    \path[rounded corners=2pt] (char) -| (int) coordinate[pos=.3] (join);
\pgfonlayer{background}
\onslide<6->{\node[below right,xshift=5mm,yshift=-1mm,codeouthl] (join-d) at (join) {UTF-16};
\path[codeouthl,line cap=round] (join.east) to[bend right] (join-d.west);}
\endpgfonlayer
}
\onslide<7->{
   \node[codeouthl,above] at (byte.north) {8};
   \node[codeouthl,above] at (short.north) {16};
   \node[codeouthl,above] at (int.north) {32};
   \node[codeouthl,above] at (long.north) {64};
   \node[codeouthl,above] at (float.north) {32};
   \node[codeouthl,above] at (double.north) {64};
   \node[codeouthl,above] at (char.north) {16};
}
\onslide<8->{\draw[decoration={brace,mirror,amplitude=3pt},decorate,codeouthl,-] ([yshift=1pt]float.south west) -- ([yshift=1pt]double.south east) node[pos=.5,below=4.5pt] {\sbseries Rundungsproblem!};}
\onslide<9->{\draw[decoration={brace,mirror,amplitude=3pt},decorate,codeouthl,-] ([yshift=1pt]byte.south west) -- ([yshift=1pt]short.south east) node[pos=.5,below=4.5pt] {\sbseries \(+\),~~\(/\),~~\ldots~~\(\longrightarrow\)~~\T{int}};}
\end{scope}
\end{tikzpicture}
% TODO: pingu der sagt, dass das alles ist und alle immpliziten Konvertieungen. Noch ein Wort zu String und void
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[left=-3mm,xshift=7mm,scale=.8,yshift=\btdmfootheight] at(current page.-26) {\copy\pinguexplainbox};}% copy for animations
    \onslide<11->{
        \node[left=-10.5mm,scale=.7] (@) at(current page.16) {\rotatebox{90}{\copy\pinguA}};
        \node[left,T,align=right] at(@.west)  {\T{void} ist in Java kein Datentyp!\\\link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html\#jls-4.2}{JLS17~$4.2$}\;\&\;\link{https://docs.oracle.com/javase/specs/jls/se17/html/jls-14.html\#jls-14.8}{$14.8$}};
    }
\end{tikzpicture}
\end{frame}
}
\fi


\subsection{Aufgabe 3}
{
\def\ms#1{{\color{lightgray}\mathbf{#1}}}
\def\to{~{\color{lightgray}\longrightarrow}~}%
\def\Aspect{.5}
\def\true{\sliteral{true}}
\def\false{\sliteral{false}}

\newcommand*\tfu[3][0pt]{\draw[decoration={brace,aspect=\Aspect},decorate,-] ([yshift=#1]#2.north) -- ([yshift=#1]#2@.north) node[above,pos=\Aspect] {\scriptsize\itshape#3};}
\def\tfd#1#2{\draw[decoration={brace,aspect={1-\Aspect}},decorate,-] (#1@.south) -- (#1.south) node[below,pos={1-\Aspect}] {\scriptsize\itshape#2};}
\begin{frame}[fragile]{Aufgabe 3: Boolesche Ausdrücke}
    \task<2->{Betrachten Sie den folgenden Java Code-Ausschnitt. Werten Sie die folgenden Ausdrücke in der Reihenfolge, in der sie ausgeführt werden (d.h. von oben nach unten), aus. Geben Sie dazu für jede Zeile (beginnend mit der zweiten Zeile) den neuen Wert der Variablen \T{b} an.\vspace*{-\medskipamount}}
\begin{plainjava}[lineskip=13.5pt]
!*\onslide<3->*!boolean b = true;
!*\onslide<4->*!b = !*\bnode{or2}{\bnode{not1}{!(\bnode{or1}{\true\ || \false})} || \bnode{b1}{b}}*!; !*\tikzmarknode{R1}\HStrut*!
!*\onslide<5->*!b = !*\bnode{not2}{!(\bnode{and1}{\true\ \&\& \false})}*!; !*\tikzmarknode{R2}\HStrut*!
!*\onslide<6->*!b = (!*\bnode{or3}{\bnode{not3}{!(\bnode{and2}{\true\ \&\& \true})} || (\bnode{or4}{\false\ || \false})}*!); !*\tikzmarknode{R3}\HStrut*!
!*\onslide<7->*!b = !*\bnode{not4}{!\bnode{b2}{b}}*!; !*\tikzmarknode{R4}\HStrut*!
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<8->{\node[above left,yshift=\btdmfootheight,text width=15.5cm,scale=.6] at(current page.south east) {\begin{alignat*}{5}
        \ms{a\text{++},~~a\text{-\,-}}&\to~\ms{\textcolor{gray}{!a},~~ -a,~~ \text{++}a,~~\text{-\,-}a}&&\to~\ms{a~*~b,~~a~/~b,~~a~\%~b} && \to~\ms{a+b,~~a-b} \\
        &\to~\ms{a==b,~~a<b,~~\ldots} && \to~\ms{a~\mbox{\textasciicircum}~b}&&\to~\ms{\textcolor{gray}{a~\&\&~b}}\\
        & \to~\ms{\textcolor{gray}{a~||~b}} &&\to \ms{\ldots} &&\to \ms{\textcolor{gray}{\textbf{(}\;\textbf{)}}}
     \end{alignat*}};}
    \color{lightgray}
    \onslide<9->{\tfu{or1}{true}}
    \onslide<10->{{\only<13->{\def\Aspect{.25}}\tfd{not1}{false}}}
    \onslide<11->{\tfd{b1}{true}}
    \onslide<12->{\node[right,T] at(R1.east) {b ist \textbf{\T{true}}};}
    \onslide<13->{{\def\Aspect{.75}\tfu{and1}{false}}}
    \onslide<14->{{\only<16->{\def\Aspect{.25}}\tfd{not2}{true}}}
    \onslide<15->{\node[right,T] at(R2.east-|R1.south) {b ist \textbf{\T{true}}};}
    \onslide<16->{{\def\Aspect{.75}\tfu{and2}{true}}}
    \onslide<17->{\tfd{not3}{false}}
    \onslide<18->{\tfd{or4}{false}}
    \onslide<19->{\node[right,T] at(R3.east) {b ist \textbf{\T{false}}};}
    \onslide<20->{\tfu{b2}{false}}
    \onslide<21->{\tfd{not4}{true}}
    \onslide<22->{\node[right,T] at(R4.east) {b ist \textbf{\T{true}}};}
\end{tikzpicture}
\end{frame}
}

\subsection{Aufgabe 4}
\begin{frame}[fragile]{Aufgabe 4: Varablen anlegen und verarbeiten}
    \begin{taskblock}<2->
        In der Vorlesung haben Sie gelernt, wie in Java Variablen deklariert und initialisiert werden. Nun sollen Sie in einem kleinen Beispiel diese Konzepte selbst umsetzen. Betrachten Sie die \T{.java}-Datei namens \T{Variablen.java} mit folgendem Inhalt:\smallskip\begin{uncoverenv}<3->
\begingroup\subdue
class Variablen \{
    public static void main(String[] args) \{

    \}
\}\smallskip
\endgroup
\end{uncoverenv}
\begin{enumerate}
    \itemsep6pt
    \item<4-> Erweitern Sie den Code so, dass zwei int Variablen deklariert werden. Initialisieren Sie diese \only<6->{\textbf}{anschließend} mit
    einem beliebigen gültigen Wert und addieren Sie sie. Das Ergebnis dieser Addition soll in eine neue dritte int
    Variable gespeichert werden. Geben Sie das Ergebnis dann über den Aufruf System.out.println(name) aus,
    wobei Sie name entsprechend ersetzen.
    \item<5-> Geben Sie als Kommentar im Java Code aus Teilaufgabe~a) jeweils an, ob es ich bei dieser Zeile um eine Deklaration, Initialisierung oder Zuweisung handelt.
\end{enumerate}
\end{taskblock}
\end{frame}

{\taskenum
\DoAnimations
\MakeThePinguExplainIt[text width=8cm]{cap=!hide,cup=!hide,straw hat,german flag left,body type=legacy,right item angle=-160}{Ist es wichtig, dass die letzte Initialisierung mit einer Summe ist? Nö. Es ist einfach nur der erste Wert, den \T{Ergebnis} erhält.}
\begin{frame}[fragile]{Simple Adds and Stuff}
\begin{enumerate}
    \item<2-> \task{Erweitern Sie den Code (Deklarieren, Initialisieren, Addieren und Ausgeben)}
    \item<10-> \task{Geben Sie an, wo Deklarationen, Initialisierungen und Zuweisungen stattfinden.}
\end{enumerate}
\begin{plainjava}
$3->\text{\only<-4|handout:0>{\sbasic{\skA{class} Variablen \{}}\only<5->{\sbasic{\color{codeouthl}class Variablen \{}}}$
$4->$    $4->\text{\only<-4|handout:0>{\sbasic{\skA{public static} \skB{void} main(\skB{String}[] args) \{}}\only<5->{\sbasic{\color{codeouthl}public static void main(String[] args) \{}}}$
$6->$       int zahl1, zahl2, ergebnis; $6->\text{\Snode{R1}}$
$7->$       zahl1 = 40; $7->\text{\Snode{R2}}$
$7->$       zahl2 =  2; $7->\text{\Snode{R3}}$
$8->$       ergebnis = zahl1 + zahl2; $8->\text{\Snode{R4}}$
$9->$       System.out.println(ergebnis); $9->\text{\Snode{R5}}$
$4->$    $4->\text{\only<-4|handout:0>{\sbasic{\}}}\only<5->{\sbasic{\color{codeouthl}\}}}}$
$3->\text{\only<-4|handout:0>{\sbasic{\}}}\only<5->{\sbasic{\color{codeouthl}\}}}}$
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
\onslide<11->{\node[right,T] at(R1.east) {Alle drei Variablen werden \textbf{deklariert}};}
\onslide<12->{\node[right,T] at(R2.east) {Eine \textbf{Initialisierung} mit Wert \T{40}};}
\onslide<13->{\node[right,T] at(R3.east) {Eine \textbf{Initialisierung} mit Wert \T{2}};}
\onslide<14->{\node[right,T] (@) at(R4.east) {Eine \textbf{Initialisierung} mit dem Ergebnis der Summe};}
\onslide<15->{\node[right,T] at(R5.east) {Eine Ausgabe (für die~b irrelevant)};}
\onslide<16->{\node[left=-3mm,xshift=7mm,scale=.8,yshift=\btdmfootheight] at(current page.-22) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}
}

\SetNextSectionText{Kontrollstrukturen\\Abgabe: \DTMDate{2022-05-16}}
\section{Aussicht: Übungsblatt 3}
\begin{frame}{Ein kleiner Schwenk}
\begin{itemize}
    \itemsep8pt
    \item<2-> Wenn wir Java-Code möchten, steht das da \info{ab jetzt wird das der Standardfall sein.}
    \item<3-> In Aufgabe~1 suchen wir \textit{einen} booleschen Ausdruck der das Programm abbildet. \onslide<2->{\infoblock{Vergleiche hierzu die Präsenzaufgabe von letzter Woche.}}
    \item<5-> Für die Schleifen der 2.~Aufgabe, kann man sich die Alternativen dieser Präsenzaufgabe nochmal ansehen.
    % \item<6-> Aufgaben~3 und~4 sind da schon interessanter\ldots
    \item<6-> Allgemein gilt: Wenn Pseudocode oder ein Ansatz gegeben ist, soll der Algorithmus auch diesen Verwenden oder darauf aufbauen!
\end{itemize}
\end{frame}

\begin{frame}{Aufgabe 3: Algorithmen in Java implementieren}
    \begin{itemize}[<+(1)->]
        \itemsep12pt
        \item Eine abstrakte Notation wird konkret.
        \item Viele einzelne Punkte werden nun kollektiv Wichtig \begin{itemize}
            \itemsep3.5pt
            \item Einhalten der Java-Syntax
            \item Welcher Datentyp passt am besten?
            \item Welche Art von Schleife, Fallunterscheidung,~\ldots\ eignet sich?
            \item Was drückt der Pseudocode implizit aus, ist aber in Java explizit notwendig?
            \item Und umgekehrt: was müssen wir in Java nicht schreiben?
            \item \ldots
        \end{itemize}
        \item Kommentare empfehlen sich da, wo der Gedanke des Algorithmus hinter Java-\allowbreak Gebrabbel verschwindet. \info{If you are interested, consider looking up literate programming~\cite{knuth1984literate}}
    \end{itemize}
\end{frame}

\begin{frame}{Aufgabe 4: Iterative Wurzelberechnung}
    \begin{itemize}
        \itemsep10pt
        \item Für die Fließkommazahl gibt es \bjava{Float.parseFloat} oder \bjava{Double.parseDouble}
        \item Verwendet das Heron-Verfahren wie angegeben \info{keine alternative Wurzelberechnung}
        \item Auch wenn es nicht gefordert ist, begründet gerne eure Entscheidungen in Kommentaren.
        \item An welcher Stelle kommen Unteralgorithmen zum Einsatz. Wo könnten sie noch hilfreich sein?
    \end{itemize}
\end{frame}

% \begin{frame}
%     TODO: Rundungsproblem
% \end{frame}

\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep14pt
    \item TODO: get bib to work here
    \item Kommandozeilenparameter landen im \bjava{args}-Array (als \bjava{String})
    \item \bjava{Integer.parseInt("13")} liefert die vom \bjava{String} beschriebene Ganzzahl (\bjava{13})
    \item Unteralgorithmen sind ein elementarer Programmiermechanismus
    \item Javas implizite Typkonvertierungen existieren nur für primitive Datentypen \begin{itemize}
        \item \bjava{byte}~\(\to\)~\bjava{short}~\(\to\)~\bjava{int}~\(\to\)~\bjava{long}~\(\to\)~\bjava{long}~\(\to\)~\bjava{double}\quad und \bjava{char}~\(\to\)~\bjava{int}
        \item \say{Zahlen von klein nach groß, \bjava{char} zu \bjava{int}}
    \end{itemize}
\end{itemize}
\end{frame}
}

\outro{\vskip6mm\centering\begin{tikzpicture}[scale=1.5]
    \only<2->{\pingu[wings=shock,body type=chubby,eyes hearts=pingu@red!10!pingu@black, santa hat, santa beard]}
\end{tikzpicture}}


\iffull\end{document}\fi
