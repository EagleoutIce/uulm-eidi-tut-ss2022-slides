\RequirePackage[cmintegrals,cmbraces,ebgaramond]{newtxmath}
\InputIfFileExists{../global.src}\relax\relax
\iffull
\title[Nulltes Tutorium -- Übungsblatt 0]{Mein Compiler und ich}
\subtitle{Tutorium ZeroHero}
\date{KW 17}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{0}

\pingudefaultsappend{eyes=shiny,wings=grab,glasses opacity=.97}

\iffull\begin{document}\fi

\titleframe

\SetNextSectionText{\say{My dear Watson, try a little analysis yourself,} said he, with a touch of impatience. \say{You know my methods. Apply them, and it will be instructive to compare results.}\\--- Conan Doyle~\cite[chp.~VI]{doyle2010sign}}
\section{Präsenzaufgabe}
{\def\f#1->#2\;{\parbox{7.5em}{\(S = \text{\T{#1}}\)\hfill}\(\quad{\color{gray}\longrightarrow}\quad\hbox to5em{\say{#2}\hfill}\)}
\begin{frame}{Präsenzaufgabe}
\begin{aufgabe}{Das habe ich schon gesehen!}
    \onslide<2->{Entwerfen Sie einen Algorithmus, um herauszufinden, ob in einer Zeichenkette \(S\) das Zeichen \T{a}, aber nicht das Zeichen \T{b} vorkommt. Als Ergebnis soll der Algorithmus ausgeben können, ob diese Bedingung zutrifft (\say{Ja}) oder nicht (\say{Nein}).}\medskip\par
    \onslide<3->{Einige Beispiele\ldots
\begin{itemize}[<+(1)->]
    \item<4-> \f ababababa->Nein\; \info{Hat \T{a}, aber auch \T{b}}
    \item<5-> \f aaaaaaaaa->Ja\; \info{Hat \T{a} und kein \T{b}}
    \item<6-> \f cdefg->Nein\; \info{Kein \T{a} und kein \T{b}}
    \item<7-> \f klmohna->Ja\; \info{Hat \T{a} und kein \T{b}}
\end{itemize}}
    \onslide<1->
\end{aufgabe}
\end{frame}
}

{
\SetAlgoVlined
\SetKwIF{If}{ElseIf}{Else}{Wenn}{tue:\quad}{}{sonst:}{}
\SetKwFor{For}{für}{tue:}{ende}
\SetKwInput{KwIn}{Eingabe}
\SetKw{KwTo}{bis einschließlich}
\SetKw{KwStep}{in Schritten von}
\SetKw{KwIs}{ist}
\SetKw{KwAnd}{und}
\SetKw{KwNot}{nicht}
\begin{frame}[c]{Lösung}
\setcounter{algocf}{0}
\pause\begin{algorithm}[H]
\PreCode
    \KwIn{Eingabe als Zeichenkette $S$ mit Zeichen $S=s_1, \ldots, s_n$}\medskip
\StartCode
    \onslide<3->{enthältA $\gets$ falsch\;}
    \onslide<4->{enthältB $\gets$ falsch\medskip\;}
    \onslide<5->{\For{i $\gets$ 1 \KwTo n \KwStep 1}{
        \onslide<6->{\lIf{\(s_i\) ist Buchstabe \T{a}}{enthältA $\gets$ wahr}}
        \onslide<7->{\lIf{\(s_i\) ist Buchstabe \T{b}}{enthältB $\gets$ wahr}}
    }}\medskip
    \onslide<8->{\lIf{enthältA aber nicht enthältB ist wahr}{Gebe aus: \say{Ja}}}
    \onslide<9->{\lElse{Gebe aus: \say{Nein}}}\medskip
    \caption{Ein \say{Zeichenkettenfilter}.}
\end{algorithm}
\end{frame}
}

\MakeThePinguExplainIt[text width=6.65cm,yshift=-2cm]{cap=!hide,hat,hat coronal=paletteA,hat ribbon=paletteA,glasses=!hide,eyes wink,cup=!hide,heart=shadeA,right item angle=-45}{Noch werden wir uns solchen Annahmen zärtlich nähern. Mit der Zeit wird es aber immer mehr auch darum gehen, \textit{was} man eigentlich annehmen darf.}
\begin{frame}[c]{Schweigsame Annahmen}
    \onslide<2->{Für das Programm \say{Zeichenkettenfilter} gelten die Annahmen:
    \begin{enumerate}[<+(1)->]
        \item<3-> die Länge von \(S\) sei endlich und (in endlicher Zeit) berechenbar, hier durch \textit{length(\(S\)) = \(n\)},
        \item<4-> mit \(S = (s_1, s_2, \ldots, s_n)\) seien alle Zeichen über \(s_i\) (\(i \in \{1, \ldots, n\} \subset \N\)) enumeriert und
        \item<5-> alle Zeichen \(s_i\) entstammen einer endlichen Grundmenge \(\Sigma\) an Zeichen.
    \end{enumerate}}
\begin{tikzpicture}[overlay,remember picture]
\onslide<6->{\node[above left,xshift=5mm,scale=.8,yshift=\btdmfootheight] at(current page.south east) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}


\iffull
\SetNextSectionText[.35\linewidth]{Avoid syntactic elements from the target programming language\\--- Steve McConnell, \cite[p.~54]{10.5555/151071}}
\section{Bonus: Pseudocode}
\def\tpingu{\raisebox{-1pt}{\scalebox{0.15}{\tikz{\pingu}}}}
\def\tagent{\pingu[sunglasses,wings wave,heart=paletteA,eyes wink]}
{\SetAlgoVlined
\begin{frame}[t]{How-To Pseudocode}
    \begin{itemize}[<+(1)->]
        \itemsep6pt
        \item \textbf{Konsistent bleiben}
        \item Menschenlesbare Notation \info{meist Programmiersprachen-Mathe-Gemisch}
        \item Solange \emph{klar} und \emph{eindeutig}, frei gestaltbar
        \item Beispiel:
% \setcounter{algocf}{2}
\begin{algorithm}[H]
    \PreCode
    \KwIn{Eingabe als Liste von $n$ Pingus: $\tpingu_1, \ldots \tpingu_n$}
    \StartCode
    \pause\Comment{Jeder Pinguin ist klasse!}
    \pause$i \gets 1$\;
    \onslide<8->{\While{$i \leq n$}{
        \onslide<9->{\lIf{$\tpingu_i$ ist klasse!}{
            \onslide<10->{\KwRet{$\tpingu_i$}}
        }}
        \onslide<11->{$i \gets i + 1$\;}
    }}
    \onslide<12->{\KwRet{\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}}\Comment*[l]{Wenn kein klasse Pingu gefunden.}}
    % \caption{Einen \say{klasse} Pinguin finden}
\end{algorithm}
    \end{itemize}
\end{frame}
}

\begin{frame}[c]
\null\vfill\centering\begin{tikzpicture}[scale=2.5,every node/.style={transform shape}]
    \tagent
\end{tikzpicture}\vfill\null
\end{frame}

\begin{frame}[t]{Pseudocode: do's and dont's}
    \begin{itemize}[<+(1)->]
        \itemsep7.5pt
        \item \emph{Do:} Gerne eine an Python oder C angelehnte Syntax verwenden.
        \item \emph{Do:} mathematisch bleiben, also $n \in \mathbb{N}$, $n \in [0,\infty)$ oder \say{$\T{Zeichenkette}~n$}.
        \item \emph{Don't:} Spracheigene \say{syntactic-sugar} Funktionen oder Definitionen verwenden.\pause{} Also: \emph{kein} \bjava{int}, \bjava{String} oder \bjava{double}.
        \item \emph{Don't:} Einfach nur Java- oder C-Code.
        \item \emph{Don't:} Zu allgemein Formulieren:\smallskip\pause
\setcounter{algocf}{3}
\begin{algorithm}[H]
\PreCode
    \KwIn{Eingabe als Liste von $n$ Pingus: $\tpingu_1, \ldots \tpingu_n$}
\StartCode
    \pause sucheKlassePingu($\tpingu_1, \ldots \tpingu_n$, \raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}})\;
    \caption{Einen \say{klasse} Pinguin finden}
\end{algorithm}
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Pseudocode, Beispiele\hfill I}
\begin{plainvoid}[morecomment={[l]//}]
!*\onslide<2->*!In: !*$\tpingu_1, \ldots, \tpingu_n$*!
!*\onslide<3->*!Out: awesome-pengu, if none: mega-pengu
!*\onslide<4->*!iterate for every !*$\tpingu_i$*! in !*$\tpingu_1, \ldots, \tpingu_n$*!:
!*\onslide<5->*!    if !*$\tpingu_i$*! is awesome: !*\onslide<6->*! return !*$\tpingu_i$*! // Pengu found
!*\onslide<7->*!return !*\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}*! // Not found
\end{plainvoid}
\end{frame}

\begin{frame}[fragile,c]{Pseudocode, Beispiele\hfill II}
\begin{plainvoid}[morecomment={[s]\[\]}]
!*\onslide<2->*!Sei A die Liste an n Pingus, indexiert mit !*$\tpingu_i$*!.
!*\onslide<3->*!Mache nun für jeden Pingu !*$\tpingu_i$*! aus A: [Durchsuche Pingus]
!*\onslide<4->*!    Wenn !*$\tpingu_i$*! klasse ist:
!*\onslide<5->*!            Gebe !*$\tpingu_i$*! zurück. [Pingu gefunden]
!*\onslide<6->*!Wenn kein Pingu super war:
!*\onslide<7->*!    Gebe Mega-Pingu (!*\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}*!) zurück. [Standardwert: Nichts gefunden]
\end{plainvoid}
\end{frame}
\fi

\SetNextSectionText{Organisatorisches und Einführung\\Abgabe: \DTMDate{2022-04-25}\medskip\\Einzelabgabe, kein reguläres Übungsblatt.}
\section{Übungsblatt 0}
\subsection{Aufgabe 1}
\begin{frame}[t]{Aufgabe 1: Java Compiler und Laufzeitumgebung}
    \task<2->{Installieren Sie die für Ihr Betriebssystem aktuelle Version des \link{https://www.oracle.com/java/technologies/downloads/}{Java Development Kits}. Diese werden Sie auch noch im Lauf der Veranstaltung für die Bearbeitung der Programmieranteile der  Übungsblätter benötigen. Bestimmen und notieren Sie anschließend die Versionsnummern.}\vfill

    % i do not want number highlight for this
    \soldisablenumhl\def\smallerXLST{\lstfs[1.2]{8}}% bracket parser
    \begin{itemize}
        \item<3-> In der Konsole: \rbash[:\smallerXLST\onslide<4->]{java -version}
        \item<5-> Sowie: \rbash[:\smallerXLST\onslide<6->]{javac -version}
    \end{itemize}
\end{frame}

\subsection{Aufgabe 2}
\rExecute{javac HelloWorld.java}
\begin{frame}[t]{Aufgabe 2: Erste Schritte in Java}
    \task<2->{Speichern Sie den Code in einer Textdatei namens \T{HelloWorld.java} ab.}\vfill
    \begin{itemize}[<+(1)->]
        \item<3-> Tipp, tipp, tipp, \ldots \ijava{HelloWorld.java}
    \end{itemize}
    \task<4->{Übersetzen Sie das Programm mittels \bbash{javac} und führen Sie den erzeugten Java-Bytecode mit \bbash{java} aus.}\vfill
    \begin{itemize}[<+(1)->]
        \item<5-> Wir tun wie geheißen: \cbash{javac HelloWorld.java}%
        \item<6-> Und dann auch für die Ausgabe: \iffull\Rbash[:\onslide<7->]{java HelloWorld}{java HelloWorld}\else\cbash{java HelloWorld}.\fi
    \end{itemize}
\end{frame}

\iffull
\SetNextSectionText{Zahlensysteme und Algorithmenkonstruktion\\Abgabe: \DTMDate{2022-05-02}}
\section{Aussicht: Übungsblatt 1}
\subsection{Hornerschema}
\def\h#1{\textcolor{cprimary}{#1}}
\let\tm\tikzmarknode
\begin{frame}{Hornerschema, \(b\) zu Dezimal}
    \begin{itemize}[]
        \item \pause Am Beispiel von $\h{\tm11\tm20\tm30\tm41}_{(\tm02)}$.
        \pause\[((\h{\tm a1}\cdot \tm x2 + \h{\tm b0})\cdot\tm y2 + \h{\tm c0}) \cdot\tm z2 + \h{\tm d1} \pause = (2\cdot2 + \h{0}) \cdot 2 + \h{1} \pause = (6 \cdot 2) + \h{1} = 9_{(10)}.\]
        \begin{tikzpicture}[remember picture,overlay]
            \only<+(1)|handout:0>{\draw[-Kite,gray] (1.south) -- (a);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (2.south) -- (b);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (3.south) -- (c);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (4.south) -- (d);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (x);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (y);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (z);}
        \end{tikzpicture}
        \item \pause Tabellarisch: \TikzHorner[13]{1,0,0,1}{2}
    \end{itemize}
\end{frame}

\begin{frame}{Hornerschema, \(b\) zu Dezimal (II)}
    \begin{itemize}[]
        \item \pause Andere Basis: $\h{\tm11\tm20\tm30\tm41}_{(\tm05)}$.
        \pause\[((\h{\tm a1}\cdot \tm x5 + \h{\tm b0})\cdot\tm y5 + \h{\tm c0}) \cdot\tm z5 + \h{\tm d1} \pause = (5\cdot5 + \h{0}) \cdot 5 + \h{1} \pause = (25 \cdot 5) + \h{1} = 126_{(10)}.\]
        \begin{tikzpicture}[remember picture,overlay]
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (x);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (y);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (z);}
        \end{tikzpicture}
        \item \pause Tabellarisch: \TikzHorner[9]{1,0,0,1}{5}
    \end{itemize}
\end{frame}

\begin{frame}{Hornerschema, Dezimal zu \(b\)}
    \begin{itemize}[]
        \item \pause \(126_{(10)}\) zurück zur Basis \(5\).
        \item \pause Tabellarisch: \TikzHornerReverse[4]{1,0,0,1}{5}
    \end{itemize}
\end{frame}

\subsection{Algorithmen}
\begin{frame}{Ein \say{Algorithmus}, was ist das?}
    \begin{itemize}[<+(1)->]
        \itemsep13pt
        \item \emph{Eindeutige} Handlungsvorschrift zur Lösung eines Problems.
        \item Endlich viele, \emph{wohldefinierte} \info{also nicht mehrdeutige} Einzelschritte.
        \item Mit der Zeit werden wir mehr Eigenschaften zur Charakterisierung betrachten.% TODO: => Tutorium 1 (Determinismus, Korrektheit,\ldots)
    \end{itemize}
\end{frame}
\begin{frame}{Algorithmus --- Die Spezifikation}
    \pause\begin{center}
    \begin{tikzpicture}
        \IfBtdmDarkmode{% TODO
            \node[block,paletteA,draw,thick] (A) at(0,0) {Algorithmus};
        }{
            \node[block,text=paletteA,thick,draw=gray] (A) at(0,0) {\sbseries\itshape Algorithmus};
        }
        \node (V) at(-5,0) {Vorbedingung};
        \node (N) at(5,0) {Nachbedingung};
        \draw[-Kite] (V) edge (A) (A) edge (N);
    \end{tikzpicture}
    \end{center}
    \begin{itemize}[<+(1)->]
        \itemsep10.5pt
        \item Suche die größte ganze Zahl in einem beliebigen (ganzzahligen, nicht-leeren) Array.
        \item Information: Die Regeln zum Pseudocode gelten hier nach wie vor!
        \item Problemspezifikation:
        \begin{description}[Ganzzahliges Array:]
            \item[Ganzzahliges Array:] Tupel der Größe \(m \geq 1\) mit: \(t = (t_1, t_2, \ldots, t_m) \in \Z^m\) \info{\(t_i \in \Z\) für alle \(t_i\)}
            \item[Beliebig:] Die Elemente müssen nicht sortiert vorliegen. \info{Also z.B. nicht \(t_1 \leq \ldots \leq t_m\).}
            \item[Größte:] Die größte ganze Zahl \(z \in t\) mit \(z = \max(t)\).
        \end{description}
        \onslide<+(1)->{Ordentlich wäre rein mathematische\textor axiomatisch belegte Formalisierungen zu nutzen. \onslide<+(1)->{In dieser Veranstaltung beschreiten wir einen Mittelweg.}}
    \end{itemize}
\end{frame}

\begin{frame}{Algorithmus --- Die Abstraktion}
    \begin{center}
    \begin{tikzpicture}
        \IfBtdmDarkmode{% TODO
            \node[block,paletteA,draw,thick] (A) at(0,0) {Algorithmus};
        }{
            \node[block,text=paletteA,thick,draw=gray] (A) at(0,0) {\sbseries\itshape Algorithmus};
        }
        \node (V) at(-5,0) {Vorbedingung};
        \node (N) at(5,0) {Nachbedingung};
        \draw[-Kite] (V) edge (A) (A) edge (N);
    \end{tikzpicture}
    \end{center}
    \begin{itemize}[<+(1)->]
        \itemsep10.5pt
        \item \textcolor{gray}{Suche die größte ganze Zahl in einem beliebigen (ganzzahligen, nicht-leeren) Array.}
        \item Problemabstraktion:
        \begin{description}[Gegeben:]
            \item[Gegeben:] Endliches unsortiertes Array $t$ an ganzen Zahlen \(n \in \Z\).
            \item[Gesucht:] Maximales ganzzahliges Element \(x = \max(t)\).
        \end{description}
        \onslide<+(1)->{In diesem Fall ist die Abstaktion nahezu offensichtlich. \onslide<+(1)->{Es dient der Veranschaulichung des Vorgehens \Laughey.}}
    \end{itemize}
\end{frame}

% TODO: anmerken, dass die Aufgabe dann mit Mengenoperationen noch schwerer ist,
% das hier ist wirklich nur für das formale.
\begin{frame}[t]{Algorithmus --- Entwurf und Korrektheit}
    \begin{itemize}[<+(1)->]
        \item Algorithmenentwurf: \info{Annahme eines 0-indizierten Arrays mit Zugriff \T{a[$i$]} für das \(i\)-te Element \(t_i\).}\\
        \begin{enumerate}\itemsep0pt
            \item Setze \(max = \text{\T{a[$0$]}}\).
            \item Setze \(i = 1\).
            \item \label{alg:loop}Solange \(i < m\):\\
                \pause{\quad Wenn (\(max < \text{\T{a[$i$]}}\)):}\\
                \pause{\qquad \(max = \text{\T{a[$i$]}}\).}\\
                \pause{\quad Inkrementiere \(i\) um \(1\).}
            \item<+(1)-> Lösung ist \(max\).
        \end{enumerate}
        \item Korrektheitsnachweis: \begin{description}[Partiell korrekt:]
            \item[Terminiert:] Die Schleife aus \ref{alg:loop}. endet sicher, da \(i\) in jeder Iteration um \(1\) inkrementiert wird und damit streng monoton wächst, \onslide<+(1)->{also sicher irgendwann \(i < m\) mit \(m \geq 1\) nicht mehr erfüllt.}
            \item<+(1)->[Partiell korrekt:] Hier lässt sich leicht zeigen, dass für jeden Schritt in \ref{alg:loop}. gilt, dass \(max \geq (t_1, \ldots, t_i)\). \onslide<+(1)->{Für \(m = 1\) ist weiter \(max = \text{\T{a[$0$]}} = \max\bigl(t_0\bigr)\).}
        \end{description}
    \end{itemize}
\end{frame}

\newsavebox\algobox
\savebox\algobox{\parbox\linewidth{\setbeamercolor{enumerate item}{fg=gray}\scriptsize\begin{enumerate}\itemsep0pt
    \item \color{gray}\label{alg:a}Setze \(max = \text{\T{a[$0$]}}\).
    \item \color{gray}\label{alg:b}Setze \(i = 1\).
    \item \color{gray}\label{alg:loop2}Solange \(i < m\): \\
        \quad Wenn (\(max < \text{\T{a[$i$]}}\)):\\
        \qquad \(max = \text{\T{a[$i$]}}\). \\
        \quad Inkrementiere \(i\) um \(1\).
    \item \color{gray}Lösung ist \(max\).
\end{enumerate}}}

\begin{frame}{Algorithmus --- Die Aufwandsanalyse}
\begin{itemize}[]
    \item Algorithmenentwurf: \info{Annahme eines 0-indizierten Arrays mit Zugriff \T{a[$i$]} für das \(i\)-te Element \(t_i\).}\\
    \usebox\algobox
    \item<+(1)-> Aufwandsanalyse:\pause\ Wir machen dies als strukturierten Text: \begin{itemize}
        \item<+(1)-> \ref{alg:a}. und \ref{alg:b}. entsprechen jeweils einer Elementaroperation.
        \item<+(1)-> \ref{alg:loop2}. wird genau \(m - 1\) mal ausgeführt. Sie enthält sicher einen Vergleich und ein Inkrement. Eventuell eine Zuweisung.\pause\ Für unseren Fall also drei Elementaroperationen.
    \end{itemize}
        \pause Damit ist der Gesamtaufwand \(1 + 1 + (m - 1) \cdot \bigl( 3 \bigr) = 2 + 3m - 3 = 3m - 1\).\medskip\\
        \pause Für komplexere Szenarien können sich die Analysen auch komplexer gestalten.
\end{itemize}
\end{frame}
\fi

\SetNextSectionText{He who chooses the beginning of a road chooses the place it leads to. It is the means that determine the end.\\--- Harry Emerson Fosdick, \cite[p.~111]{fosdick1941living}}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep16pt
    \item Für Pseudocode wünschen wir uns \begin{itemize}
        \item eine konsistente und menschenlesbare Notation,
        \item mathematische Definitionen,
        \item aber nichts Sprachspezifisches (\bjava{int}) oder zu allgemeines (\say{löst Problem}).
    \end{itemize}
    \item Bei der Algorithmuskonstruktion beachten: \begin{itemize}
        \item \def\t{~~\faAngleRight~~}Spezifikation\t Abstraktion\t Entwurf\t Verifikation\t Aufwandsanalyse
        \item Als Frage für die Woche: Warum und wann sind all diese Schritte von Bedeutung?
    \end{itemize}
\end{itemize}
\end{frame}
}

\outro{\centering\begin{tikzpicture}[scale=2.5]
    \only<2->{\pingu[right wing grab,cup=purple!90!green,name=saphira, left eye wink]}
\end{tikzpicture}}

\iffull\end{document}\fi
