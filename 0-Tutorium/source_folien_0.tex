\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title[Nulltes Tutorium -- Übungsblatt 0]{Mein Compiler und ich}
\subtitle{Tutorium ZeroHero}
\date{KW 17}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{0}

\pingudefaultsappend{eyes=shiny,wings=grab,glasses opacity=.97}

\iffull\begin{document}\fi

\titleframe

\SetNextSectionText{\say{My dear Watson, try a little analysis yourself,} said he, with a touch of impatience. \say{You know my methods. Apply them, and it will be instructive to compare results.}\\--- Conan Doyle~\cite[chp.~VI]{doyle2010sign}}
\section{Präsenzaufgabe}
{\def\f#1->#2\;{\parbox{7.5em}{\(S = \text{\T{#1}}\)\hfill}\(~~{\color{gray}\longrightarrow}~~\hbox to3.5em{\say{#2}\hfill}\)}
\let\t\textit
\setbeamertemplate{enumerate item}{\alph{enumi})}
\begin{frame}[c]{Präsenzaufgabe}
\begin{aufgabe}{Das habe ich schon gesehen!}
\vspace*{-.9\baselineskip}\null\hfill\smash{\raisebox{-\height+.25\baselineskip}{\minipage{.55\linewidth}
\itemize
    \item<5-> \f ababababa->Nein\; \info{Enthält ein \T{b}}
    \item<6-> \f aaaaaaaaa->Ja\; \info{Hat \T{a} und kein \T{b}}
    \item<7-> \f cdefg->Nein\; \info{Enthält kein \T{a}}
    \item<8-> \f klmohna->Ja\; \info{Hat \T{a} und kein \T{b}}
\enditemize
\endminipage}}\par\only<-3|handout:0>{\parshape 1
0pt \linewidth}\only<4->{\parshape 6
0pt .4125\linewidth
0pt .4125\linewidth
0pt .4125\linewidth
0pt .4125\linewidth
0pt .4125\linewidth
0pt \linewidth}
% \raggedright
\onslide<2->{Entwerfen Sie einen Algorithmus, um herauszufinden, ob in einer Zeichenkette \(S\) das Zeichen \T{a}, aber nicht das Zeichen \T{b} vorkommt. Als Ergebnis soll der Algorithmus ausgeben können, ob diese Bedingung zutrifft (\say{Ja}) oder nicht (\say{Nein}).} \onslide<3->{Wir vermerken ein paar Beispiele\ldots}%
\smallskip\par
    \only<9->{\relax Führen Sie die Schritte der Algorithmenentwicklung durch:\vspace*{-\topsep}
    \begin{multicols}{2}
        \begin{enumerate}
            \item<10-> \t{Problemspezifikation}
            \item<11-> \t{Problemabstraktion}
            \item<12-> \t{Algorithmenentwurf}
            \item<13-> \t{Korrektheitsnachweis bzw. Verifikation}
            \item<14-> \t{Aufwandsanalyse}
            \item[]
        \end{enumerate}
    \end{multicols}}
    \onslide<1->
\end{aufgabe}
\end{frame}
}

{
\def\g{\color{gray}\itshape}
\setbeamertemplate{enumerate item}{\g\alph{enumi})}
\begin{frame}{Problemspezifikation und -abstraktion}
    \onslide<+(1)->\begin{center}
        Es gelte \(i, j \in \{1, \ldots, n\} \subseteq \N\)
    \end{center}\vfill
    % \vskip0pt plus1filll\relax
    \begin{enumerate}[<+(1)->]
        \itemsep=16pt
        \item {\g Spezifikation: Definiere alle relevante Begriffe unmissverständlich}
        \begin{itemize}[<+(1)->]
            \itemsep1.5pt
            \item Eine \say{Zeichenkette} \(S\) ist eine indizierte Liste \((s_1, \ldots, s_n)\) an Zeichen.
            \item Ein \say{Zeichen} ist ein Symbol \(s_i\) aus einem Alphabet \(\Sigma\).
            \item Mit \say{Zeichen \(x\) kommt in \(S\) vor} meinen wir: \(\exists i:~s_i = x\)
            % \item Das \say{nicht-vorkommen} bezeichne hier die aussagenlogische Negation.
        \end{itemize}
        \item {\g Abstraktion: Definiere die Eingabe und die gewünschte Ausgabe}
        \begin{description}[Gegeben:]
            \itemsep1.5pt
            \item<+(1)->[Gegeben:] Eine Zeichenkette \(S = s_1, \ldots, s_n\)
            \item<+(1)->[Gesucht:] Ausgabe \say{Ja} genau dann, wenn \(\exists i: s_i = \text{\T{a}}\) und \(\forall j: s_j \neq \text{\T{b}}\), sonst \say{Nein}
        \end{description}
    \end{enumerate}
\end{frame}

\SetAlgoVlined
\SetKwIF{If}{ElseIf}{Else}{Wenn}{tue:\quad}{}{Sonst:}{}
\SetKwFor{For}{für}{tue:}{ende}
\SetKwInput{KwIn}{Eingabe}
\SetKw{KwTo}{bis einschließlich}
\SetKw{KwStep}{in Schritten von}
\SetKw{KwIs}{ist}
\SetKw{KwAnd}{und}
\SetKw{KwNot}{nicht}
\def\a{\text{\textit{enthältA}}}
\def\b{\text{\textit{enthältB}}}
\begin{frame}[c]{Algorithmenentwurf}
\setcounter{algocf}{0}
\pause\begin{algorithm}[H]
\PreCode
    \KwIn{Eingabe als Zeichenkette $S$ mit Zeichen $S=s_1, \ldots, s_n$}\medskip
\StartCode
    \onslide<3->{$\a \gets Nein$\;}
    \onslide<4->{$\b \gets Nein$\medskip\;}
    \onslide<5->{\For{i $\gets$ 1 \KwTo n \KwStep 1}{
        \onslide<6->{\lIf{\(s_i\) \textup{ist Buchstabe \T{a}}}{$\a\gets Ja$}}
        \onslide<7->{\lIf{\(s_i\) \textup{ist Buchstabe \T{b}}}{$\b\gets Ja$}}
    }}\medskip
    \onslide<8->{\lIf{\a\ \textup{ist} Ja \textup{aber} \b\ \textup{ist} Nein}{Gebe aus: \say{Ja}}}
    \onslide<9->{\lElse{Gebe aus: \say{Nein}}}\medskip
    \only<10->{\caption{Ein \say{Zeichenkettenfilter}}}
\end{algorithm}
\end{frame}

\SetKw{KwTo}{bis}
\SetKw{KwStep}{Schrittgröße}
\SetKwIF{If}{ElseIf}{Else}{Wenn}{\!:~}{}{sonst:}{}
\SetKwFor{For}{für}{\!:~}{ende}
\def\a{\text{\textit{hatA}}}
\def\b{\text{\textit{hatB}}}
\SetNlSty{textbf}{Z}{:}
\newsavebox\presalgobox
\setbox\presalgobox=\hbox{\color{gray}\minipage{6cm}\footnotesize\begin{algorithm}[H]
    $\a \gets Nein,\quad \b \gets Nein$\;
    \For{i $\gets$ 1 \KwTo n \KwStep 1}{
        \lIf{\(s_i = \text{\T{a}}\)}{$\a\gets Ja$}
        \lIf{\(s_i = \text{\T{b}}\)}{$\b\gets Ja$}
    }
    \lIf{\(\a = Ja\), \(\b = Nein\)}{\say{Ja}}
    \lElse{\say{Nein}}
\end{algorithm}\endminipage}

\def\a{\text{\textit{enthältA}}}
\def\b{\text{\textit{enthältB}}}
\begin{frame}{Korrektheitsnachweis, Verifikation}
\begin{enumerate}[<+(3)->]
    \setcounter{enumi}{3}
    \item<3-> {\g Verifikation: Zeige die totale Korrektheit (der Algorithmus\\  terminiert und ist partiell Korrekt):}\smallskip
    \begin{description}[Partiell Korrekt:]
        \itemsep8pt
        \item[Termination:] \(Z1\) und \(Z3\)--\(Z6\) enthalten Elementaroperationen,\\ diese Terminieren per Definition.\medskip\par
        Die Schleife in \(Z2\) terminiert, da \(i\) streng monoton ansteigt und damit in endlicher Zeit \(i \leq n\) verletzt.
        \item[Partiell Korrekt:] Wir merken uns mit \a\ und \b, ob der jeweilige Buchstabe gefunden wurde. Wir geben \say{Ja} nur dann aus, wenn wir ein \T{a}, aber kein \T{b} finden. Sonst geben wir \say{Nein} aus.
    \end{description}
\end{enumerate}
\tikzpicture[overlay,remember picture]
    \onslide<2->{\node[below left,xshift=5mm,yshift=-1.5cm,scale=.85,align=center,gray] at(current page.north east) {\copy\presalgobox\\\itshape\small Eine verkürzte Version};}
\endtikzpicture
\end{frame}
\iffull
\MakeThePinguExplainIt[text width=6.65cm,yshift=-1.75cm]{cap=!hide,halo,glasses=!hide,eyes shiny,heart=shadeA,body type=chubby,right item angle=-45}{Invarianten mögen vielleicht gruselig klingen, sind aber nur Aussagen, die zum Beispiel im Rahmen von Schleifen \say{immer} (also in jedem Durchlauf) gelten.}
\begin{frame}{Verifikation --- Eine kleine Vertiefung}
   \begin{itemize}[<+(1)->]
    \item Der Alternative, \say{weniger schwammige} Beweis der partiellen Korrektheit: \begin{itemize}
        \itemsep5pt
        \item Man überzeuge sich leicht, dass folgende Invariante für alle \(i \in \{1, \ldots, n\}\) gelte: \begin{equation*}
            \onslide<4->{\a = \begin{cases}
                Ja, & \exists j \in \{1, \ldots, i\}: s_j = \text{\T{a}}\\
                Nein,\quad & \text{sonst.}
            \end{cases}} \qquad \onslide<5->{\b = \begin{cases}
                Ja, & \exists j \in \{1, \ldots, i\}: s_j = \text{\T{b}}\\
                Nein,\quad & \text{sonst.}
            \end{cases}}
        \end{equation*}
        \item<6-> Dies kann man beispielsweise mit vollständiger Induktion zeigen.
        \item<7-> Anschließend folgt der Beweis durch Abgleich der Bedingungen mit der aussagenlogischen Formel.
    \end{itemize}
   \end{itemize}
   \begin{tikzpicture}[overlay,remember picture]
    \onslide<8->{\node[above left,xshift=5mm,scale=.8,yshift=\btdmfootheight] at(current page.south east) {\copy\pinguexplainbox};}% copy for animations
    \end{tikzpicture}
\end{frame}
\fi


\begin{frame}{Aufwandsanalyse}
\begin{itemize}
    \itemsep14pt
    \item<3-> Mögliche ist eine tabellarische oder textuelle Erfassung.
    \item<4-> Wir machen es textuell: \begin{itemize}
        \itemsep7pt
        \item<5-> \(Z1\) enthält zwei Zuweisungen, die Bedingung in~\(Z5\) enthält zwei\\Vergleiche und in jedem Fall eine Ausgabe. %\\ (als Elementaroperation).
        \item<6-> Die Schleife in \(Z2\) enthält zwei Vergleiche und im schlechtesten Fall eine Zuweisung (so ist für \(\text{\T{a}} \neq \text{\T{b}}\) höchstens eine beider Bedingungen trifft zu).
        \item<7-> Die Schleife wird immer genau \(n\)-mal durchlaufen.
    \end{itemize}
    \item<8-> So erhalten wir im besten (kein \(a\) und kein \(b\)), sowie im schlechtesten Fall (nur \(a\)'s und \(b\)'s): \begin{align*}
        \onslide<9->{\text{best-case}} &\onslide<9->{= 2 + n \cdot (2 + 0) + 2 + 1 = 2n + 5 \in \O(n)}\\
        \onslide<10->{\text{worst-case}} &\onslide<10->{= 2 + n \cdot (2 + 1) + 2 + 1 = 3n + 5 \in \O(n)}
    \end{align*}
\end{itemize}
\tikzpicture[overlay,remember picture]
    \onslide<2->{\node[below left,xshift=5mm,yshift=-1.5cm,scale=.85,align=center,gray] at(current page.north east) {\copy\presalgobox\\\itshape\small Eine verkürzte Version};}
\endtikzpicture
\end{frame}
}

\MakeThePinguExplainIt[text width=6.65cm,yshift=-1.75cm]{cap=!hide,hat,hat coronal=paletteA,hat ribbon=paletteA,glasses=!hide,eyes wink,cup=!hide,heart=shadeA,right item angle=-45}{Noch werden wir uns solchen Annahmen zärtlich nähern. Mit der Zeit wird es aber immer mehr auch darum gehen, \textit{was} man eigentlich annehmen darf.}
\begin{frame}[t]{Schweigsame Annahmen}
    \onslide<2->{\color{btdm@text}Für das Programm \say{Zeichenkettenfilter} und seine Analyse gelten die Annahmen:
    \begin{enumerate}[<+(1)->]
        \item<3-> die Länge \(n\) von \(S\) sei endlich und (in endlicher Zeit) berechenbar%, hier durch \textit{\(n \gets{}\) length(\(S\))},
        \item<4-> wir können die Zeichen \(s_i\) aus \(\Sigma\) vergleichen.
    \end{enumerate}}
    \vspace*{1cm}
    \onslide<5->{Ob \(Z5\) wirklich immer zwei Vergleiche hat, hängt davon ab, wie das logische \say{und} funktioniert. Wertet es für \say{\(\text{falsch} \land \langle?\rangle\)} den zweiten Operand nicht mehr aus, haben wir Falle eines \(S\) ohne \(a\)'s, einen Aufwand von \(2n + 4\).}
\begin{tikzpicture}[overlay,remember picture]
\onslide<6->{\node[above left,xshift=5mm,scale=.8,yshift=\btdmfootheight] at(current page.south east) {\copy\pinguexplainbox};}% copy for animations
\end{tikzpicture}
\end{frame}

% \iffull
% \begin{frame}{Alternative Ansätze}

% \end{frame}
% \fi

\iffull
\SetNextSectionText[.35\linewidth]{Avoid syntactic elements from the target programming language\\--- Steve McConnell, \cite[p.~54]{10.5555/151071}}
\section{Bonus: Pseudocode}
\def\tpingu{\raisebox{-1pt}{\scalebox{0.15}{\tikz{\pingu}}}}
\def\tagent{\pingu[sunglasses,wings wave,heart=paletteA,eyes wink]}
{\SetAlgoVlined
\begin{frame}[t]{How-To Pseudocode}
    \begin{itemize}[<+(1)->]
        \itemsep6pt
        \item \textbf{Konsistent bleiben}
        \item Menschenlesbare Notation \info{meist Programmiersprachen-Mathe-Gemisch}
        \item Solange \emph{klar} und \emph{eindeutig}, frei gestaltbar
        \item Beispiel:
% \setcounter{algocf}{2}
\begin{algorithm}[H]
    \PreCode
    \KwIn{Eingabe als Liste von $n$ Pingus: $\tpingu_1, \ldots \tpingu_n$}
    \StartCode
    \pause\Comment{Jeder Pinguin ist klasse!}
    \pause$i \gets 1$\;
    \onslide<8->{\While{$i \leq n$}{
        \onslide<9->{\lIf{$\tpingu_i$ ist klasse!}{
            \onslide<10->{\KwRet{$\tpingu_i$}}
        }}
        \onslide<11->{$i \gets i + 1$\;}
    }}
    \onslide<12->{\KwRet{\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}}\Comment*[l]{Wenn kein klasse Pingu gefunden.}}
    % \caption{Einen \say{klasse} Pinguin finden}
\end{algorithm}
    \end{itemize}
\end{frame}
}

\begin{frame}[c]
\null\vfill\centering\begin{tikzpicture}[scale=2.5,every node/.style={transform shape}]
    \tagent
\end{tikzpicture}\vfill\null
\end{frame}

\begin{frame}[t]{Pseudocode: do's and dont's}
    \begin{itemize}[<+(1)->]
        \itemsep7.5pt
        \item \emph{Do:} Gerne eine an Python oder C angelehnte Syntax verwenden.
        \item \emph{Do:} mathematisch bleiben, also $n \in \N$, $n \in [0,\infty)$ oder \say{$\T{Zeichenkette}~n$}.
        \item \emph{Don't:} Spracheigene \say{syntactic-sugar} Funktionen oder Definitionen verwenden.\pause{} Also: \emph{kein} \bjava{int}, \bjava{String} oder \bjava{double}.
        \item \emph{Don't:} Einfach nur Java- oder C-Code.
        \item \emph{Don't:} Zu allgemein Formulieren:\smallskip\pause
\setcounter{algocf}{3}
\begin{algorithm}[H]
\PreCode
    \KwIn{Eingabe als Liste von $n$ Pingus: $\tpingu_1, \ldots \tpingu_n$}
\StartCode
    \pause sucheKlassePingu($\tpingu_1, \ldots \tpingu_n$, \raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}})\;\smallskip
    \caption{Einen \say{klasse} Pinguin finden}
\end{algorithm}
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Pseudocode, Beispiele\hfill I}
\begin{plainvoid}[morecomment={[l]//}]
!*\onslide<2->*!In: !*$\tpingu_1, \ldots, \tpingu_n$*!
!*\onslide<3->*!Out: awesome-pengu, if none: mega-pengu
!*\onslide<4->*!iterate for every !*$\tpingu_i$*! in !*$\tpingu_1, \ldots, \tpingu_n$*!:
!*\onslide<5->*!    if !*$\tpingu_i$*! is awesome: !*\onslide<6->*! return !*$\tpingu_i$*! // Pengu found
!*\onslide<7->*!return !*\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}*! // Not found
\end{plainvoid}
\end{frame}

\begin{frame}[fragile,c]{Pseudocode, Beispiele\hfill II}
\begin{plainvoid}[morecomment={[s]\[\]}]
!*\onslide<2->*!Sei A die Liste an n Pingus, indexiert mit !*$\tpingu_i$*!.
!*\onslide<3->*!Mache nun für jeden Pingu !*$\tpingu_i$*! aus A: [Durchsuche Pingus]
!*\onslide<4->*!    Wenn !*$\tpingu_i$*! klasse ist:
!*\onslide<5->*!            Gebe !*$\tpingu_i$*! zurück. [Pingu gefunden]
!*\onslide<6->*!Wenn kein Pingu super war:
!*\onslide<7->*!    Gebe Mega-Pingu (!*\raisebox{-1pt}{\scalebox{0.15}{\tikz{\tagent}}}*!) zurück. [Standardwert: Nichts gefunden]
\end{plainvoid}
\end{frame}
\fi

\SetNextSectionText{Organisatorisches und Einführung\\Abgabe: \DTMDate{2022-04-25}\medskip\\Einzelabgabe, kein reguläres Übungsblatt.}
\section{Übungsblatt 0}
\subsection{Aufgabe 1}
\begin{frame}[t]{Aufgabe 1: Java Compiler und Laufzeitumgebung}
    \task<2->{Installieren Sie die für Ihr Betriebssystem aktuelle Version des \link{https://www.oracle.com/java/technologies/downloads/}{Java Development Kits}. Diese werden Sie auch noch im Lauf der Veranstaltung für die Bearbeitung der Programmieranteile der  Übungsblätter benötigen. Bestimmen und notieren Sie anschließend die Versionsnummern.}\vfill

    % i do not want number highlight for this
    \soldisablenumhl\def\smallerXLST{\lstfs[1.2]{8}}% bracket parser
    \begin{itemize}
        \item<3-> In der Konsole: \rbash[:\smallerXLST\onslide<4->]{java -version}
        \item<5-> Sowie: \rbash[:\smallerXLST\onslide<6->]{javac -version}
    \end{itemize}
\end{frame}

\subsection{Aufgabe 2}
\iffull\rExecute{javac HelloWorld.java}\fi
\begin{frame}[t]{Aufgabe 2: Erste Schritte in Java}
    \task<2->{Speichern Sie den Code in einer Textdatei namens \T{HelloWorld.java} ab.}\vfill
    \begin{itemize}[<+(1)->]
        \item<3-> Tipp, tipp, tipp, \ldots \ijava{HelloWorld.java}
    \end{itemize}
    \task<4->{Übersetzen Sie das Programm mittels \bbash{javac} und führen Sie den erzeugten Java-Bytecode mit \bbash{java} aus.}\vfill
    \begin{itemize}[<+(1)->]
        \item<5-> Wir tun wie geheißen: \cbash{javac HelloWorld.java}%
        \item<6-> Und dann auch für die Ausgabe: \iffull\Rbash[:\onslide<7->]{java HelloWorld}{java HelloWorld}\else\cbash{java HelloWorld}.\fi
    \end{itemize}
\end{frame}

\iffull
\SetNextSectionText{Zahlensysteme und Algorithmenkonstruktion\\Abgabe: \DTMDate{2022-05-02}}
\section{Aussicht: Übungsblatt 1}
\subsection{Hornerschema}
\def\h#1{\textcolor{cprimary}{#1}}
\let\tm\tikzmarknode
\begin{frame}{Hornerschema, \(b\) zu Dezimal}
    \begin{itemize}[]
        \item \pause Am Beispiel von $\h{\tm11\tm20\tm30\tm41}_{(\tm02)}$.
        \pause\[((\h{\tm a1}\cdot \tm x2 + \h{\tm b0})\cdot\tm y2 + \h{\tm c0}) \cdot\tm z2 + \h{\tm d1} \pause = (2\cdot2 + \h{0}) \cdot 2 + \h{1} \pause = (6 \cdot 2) + \h{1} = 9_{(10)}.\]
        \begin{tikzpicture}[remember picture,overlay]
            \only<+(1)|handout:0>{\draw[-Kite,gray] (1.south) -- (a);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (2.south) -- (b);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (3.south) -- (c);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (4.south) -- (d);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (x);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (y);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (z);}
        \end{tikzpicture}
        \item \pause Tabellarisch: \TikzHorner[13]{1,0,0,1}{2}
    \end{itemize}
\end{frame}

\begin{frame}{Hornerschema, \(b\) zu Dezimal (II)}
    \begin{itemize}[]
        \item \pause Andere Basis: $\h{\tm11\tm20\tm30\tm41}_{(\tm05)}$.
        \pause\[((\h{\tm a1}\cdot \tm x5 + \h{\tm b0})\cdot\tm y5 + \h{\tm c0}) \cdot\tm z5 + \h{\tm d1} \pause = (5\cdot5 + \h{0}) \cdot 5 + \h{1} \pause = (25 \cdot 5) + \h{1} = 126_{(10)}.\]
        \begin{tikzpicture}[remember picture,overlay]
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (x);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (y);}
            \only<+(1)|handout:0>{\draw[-Kite,gray] (0.south) -- (z);}
        \end{tikzpicture}
        \item \pause Tabellarisch: \TikzHorner[9]{1,0,0,1}{5}
    \end{itemize}
\end{frame}

\begin{frame}{Hornerschema, Dezimal zu \(b\)}
    \begin{itemize}[]
        \item \pause \(126_{(10)}\) zurück zur Basis \(5\).
        \item \pause Tabellarisch: \TikzHornerReverse[4]{1,0,0,1}{5}
    \end{itemize}
\end{frame}

\subsection{Algorithmen}
\begin{frame}{Ein \say{Algorithmus}, was ist das?}
    \begin{itemize}[<+(1)->]
        \itemsep13pt
        \item \emph{Eindeutige} Handlungsvorschrift zur Lösung eines Problems.
        \item Endlich viele, \emph{wohldefinierte} \info{also nicht mehrdeutige} Einzelschritte.
        \item Mit der Zeit werden wir mehr Eigenschaften zur Charakterisierung betrachten.% TODO: => Tutorium 1 (Determinismus, Korrektheit,\ldots)
    \end{itemize}
\end{frame}
\begin{frame}{Algorithmus --- Die Spezifikation}
    \pause\begin{center}
    \begin{tikzpicture}
        \IfBtdmDarkmode{% TODO
            \node[block,paletteA,draw,thick] (A) at(0,0) {Algorithmus};
        }{
            \node[block,text=paletteA,thick,draw=gray] (A) at(0,0) {\sbseries\itshape Algorithmus};
        }
        \node (V) at(-5,0) {Vorbedingung};
        \node (N) at(5,0) {Nachbedingung};
        \draw[-Kite] (V) edge (A) (A) edge (N);
    \end{tikzpicture}
    \end{center}
    \begin{itemize}[<+(1)->]
        \itemsep10.5pt
        \item Suche die größte, ganze Zahl in einem beliebigen (ganzzahligen, nicht-leeren) Array.
        \item Information: Die Regeln zum Pseudocode gelten hier nach wie vor!
        \item Problemspezifikation:
        \begin{description}[Ganzzahliges Array:]
            \item[Ganzzahliges Array:] Tupel der Größe \(m \geq 1\) mit: \(t = (t_1, t_2, \ldots, t_m) \in \Z^m\) \info{\(t_i \in \Z\) für alle \(t_i\)}
            \item[Beliebig:] Die Elemente müssen nicht sortiert vorliegen. \info{Also z.B. nicht \(t_1 \leq \ldots \leq t_m\).}
            \item[Größte:] Die größte, ganze Zahl \(z \in t\) mit \(z = \max(t)\).
        \end{description}
        \onslide<+(1)->{Ordentlich wäre rein mathematische\textor axiomatisch belegte Formalisierungen zu nutzen. \onslide<+(1)->{In dieser Veranstaltung beschreiten wir einen Mittelweg.}}
    \end{itemize}
\end{frame}

\begin{frame}{Algorithmus --- Die Abstraktion}
    \begin{center}
    \begin{tikzpicture}
        \IfBtdmDarkmode{% TODO
            \node[block,paletteA,draw,thick] (A) at(0,0) {Algorithmus};
        }{
            \node[block,text=paletteA,thick,draw=gray] (A) at(0,0) {\sbseries\itshape Algorithmus};
        }
        \node (V) at(-5,0) {Vorbedingung};
        \node (N) at(5,0) {Nachbedingung};
        \draw[-Kite] (V) edge (A) (A) edge (N);
    \end{tikzpicture}
    \end{center}
    \begin{itemize}[<+(1)->]
        \itemsep10.5pt
        \item \textcolor{gray}{Suche die größte, ganze Zahl in einem beliebigen (ganzzahligen, nicht-leeren) Array.}
        \item Problemabstraktion:
        \begin{description}[Gegeben:]
            \item[Gegeben:] Endliches unsortiertes Array $t$ an ganzen Zahlen \(n \in \Z\).
            \item[Gesucht:] Maximales ganzzahliges Element \(x = \max(t)\).
        \end{description}
        \onslide<+(1)->{In diesem Fall ist die Abstraktion nahezu offensichtlich. \onslide<+(1)->{Es dient der Veranschaulichung des Vorgehens \Laughey.}}
    \end{itemize}
\end{frame}

% das hier ist wirklich nur für das formale.
\begin{frame}[t]{Algorithmus --- Entwurf und Korrektheit}
    \begin{itemize}[<+(1)->]
        \item Algorithmenentwurf: \info{Annahme eines 0-indizierten Arrays mit Zugriff \T{a[$i$]} für das \(i\)-te Element \(t_i\).}\\
        \begin{enumerate}\itemsep0pt
            \item Setze \(max = \text{\T{a[$0$]}}\).
            \item Setze \(i = 1\).
            \item \label{alg:loop}Solange \(i < m\):\\
                \pause{\quad Wenn (\(max < \text{\T{a[$i$]}}\)):}\\
                \pause{\qquad \(max = \text{\T{a[$i$]}}\).}\\
                \pause{\quad Inkrementiere \(i\) um \(1\).}
            \item<+(1)-> Lösung ist \(max\).
        \end{enumerate}
        \item Korrektheitsnachweis: \begin{description}[Partiell korrekt:]
            \item[Terminiert:] Die Schleife aus \ref{alg:loop}. endet sicher, da \(i\) in jeder Iteration um \(1\) inkrementiert wird und damit streng monoton wächst, \onslide<+(1)->{also sicher irgendwann \(i < m\) mit \(m \geq 1\) nicht mehr erfüllt.}
            \item<+(1)->[Partiell korrekt:] Hier lässt sich leicht zeigen, dass für jeden Schritt in \ref{alg:loop}. gilt, dass \(max \geq (t_1, \ldots, t_i)\). \onslide<+(1)->{Für \(m = 1\) ist weiter \(max = \text{\T{a[$0$]}} = \max\bigl(t_0\bigr)\).}
        \end{description}
    \end{itemize}
\end{frame}

\newsavebox\algobox
\savebox\algobox{\parbox\linewidth{\setbeamercolor{enumerate item}{fg=gray}\scriptsize\begin{enumerate}\itemsep0pt
    \item \color{gray}\label{alg:a}Setze \(max = \text{\T{a[$0$]}}\).
    \item \color{gray}\label{alg:b}Setze \(i = 1\).
    \item \color{gray}\label{alg:loop2}Solange \(i < m\): \\
        \quad Wenn (\(max < \text{\T{a[$i$]}}\)):\\
        \qquad \(max = \text{\T{a[$i$]}}\). \\
        \quad Inkrementiere \(i\) um \(1\).
    \item \color{gray}Lösung ist \(max\).
\end{enumerate}}}

\begin{frame}{Algorithmus --- Die Aufwandsanalyse}
\begin{itemize}[]
    \item Algorithmenentwurf: \info{Annahme eines 0-indizierten Arrays mit Zugriff \T{a[$i$]} für das \(i\)-te Element \(t_i\).}\\
    \usebox\algobox
    \item<+(1)-> Aufwandsanalyse:\pause\ Wir machen dies als strukturierten Text: \begin{itemize}
        \item<+(1)-> \ref{alg:a}. und \ref{alg:b}. entsprechen jeweils einer Elementaroperation.
        \item<+(1)-> \ref{alg:loop2}. wird genau \(m - 1\) mal ausgeführt. Sie enthält sicher einen Vergleich und ein Inkrement. Eventuell eine Zuweisung.\pause\ Für unseren Fall also drei Elementaroperationen.
    \end{itemize}
        \pause Damit ist der Gesamtaufwand \(1 + 1 + (m - 1) \cdot \bigl( 3 \bigr) = 2 + 3m - 3 = 3m - 1\).\medskip\\
        \pause Für komplexere Szenarien können sich die Analysen auch komplexer gestalten.
\end{itemize}
\end{frame}
\fi

\SetNextSectionText{He who chooses the beginning of a road chooses the place it leads to. It is the means that determine the end.\\--- Harry Emerson Fosdick, \cite[p.~111]{fosdick1941living}}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep16pt
    \item Für Pseudocode wünschen wir uns \begin{itemize}
        \item eine konsistente und menschenlesbare Notation,
        \item mathematische Definitionen,
        \item aber nichts Sprachspezifisches (\bjava{int}) oder zu allgemeines (\say{löst Problem}).
    \end{itemize}
    \item Bei der Algorithmuskonstruktion beachten: \begin{itemize}
        \item \def\t{~~\faAngleRight~~}Spezifikation\t Abstraktion\t Entwurf\t Verifikation\t Aufwandsanalyse
        \item Als Frage für die Woche: Warum und wann sind all diese Schritte von Bedeutung?
    \end{itemize}
\end{itemize}
\end{frame}
}

\outro{\vskip6mm\centering\begin{tikzpicture}[scale=2.5]
    \only<2->{\pingu[right wing grab,headband=purple!90!green,cup=purple!90!green,name=saphira, left eye wink,body type=chubby]}
\end{tikzpicture}}

\iffull\end{document}\fi
