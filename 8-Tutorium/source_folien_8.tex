\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{quaerere atque disponere} % \ldots\ sich selbst
\subtitle{Tutorium M\texorpdfstring{\setbox0=\hbox{a}\resizebox*!{\ht0}{\tiny{8}}}{a}cht}
\date{KW 26}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{8}

\iffull\begin{document}
\titleframe

\TopicOverview{9}
\fi

\iffull{\SummaryFrame
\begin{frame}[c]{Kurzwiederholung}
\begin{itemize}[<+(1)->]
   \itemsep8pt
    \item Die Rekursionsfamilie \info{Methoden die sich selbst aufrufen} ist riesig: \begin{itemize}
        \itemsep3pt
        \item Ruft sich eine Methode maximal einmal selbst auf, ist sie linear rekursiv.
        \item Head-Rekursiv, wenn dieser Aufruf das erste Statement ist \info{alles passiert im Aufstieg}
        \item Tail-Rekursiv, wenn dieser Aufruf das letzte Statement ist \info{alles passiert im Abstieg}
        \item Ruft sie sich auch mehrfach pro Rekursionsfall auf, ist sie verzweigt rekursiv.
    \end{itemize}
    \item Die \say{Big-O-Notation} nutzen wir zum \info{z.B.} Vergleich der Laufzeitkomplexität:\pause
    \begin{itemize}
        \itemsep3pt
        \item \(T(n) \in \O(f(n))\pause{}\iff \exists n_0 \in \mathbb{N}\: c \in \mathbb{R}^+\: \forall n \geq n_0: T(n) \leq c \cdot f(n)\)
        \item Ab einem gewissen Punkt (\(n_0\)) ist \(c \cdot f(n)\) stets größer als \(T(n)\)
    \end{itemize}
\begin{center}%
\resizebox{\linewidth}{!}{%
\setlength{\aboverulesep}{0pt}%
\setlength{\belowrulesep}{0pt}%
\setlength{\extrarowheight}{.85ex}%
\begin{tabular}{c*{8}{c}}
    \toprule
    & {\cellcolor{pingu@green!100!pingu@purple!21} \(\O(1)\)} & {\cellcolor{pingu@green!85!pingu@purple!21}\(\O(\log n)\)} & {\cellcolor{pingu@green!69!pingu@purple!21} \(\O(n)\)} & {\cellcolor{pingu@green!53!pingu@purple!21} \(\O(n\log n)\)} & {\cellcolor{pingu@green!36!pingu@purple!21} \(\O(n^2)\)} & {\cellcolor{pingu@green!19!pingu@purple!21} \(\O(n^3)\)} & {\cellcolor{pingu@green!14!pingu@purple!21} \(\O(2^n)\)} & {\cellcolor{pingu@green!0!pingu@purple!21} \(\O(n!)\)} \\[0.45ex]\midrule
    {\footnotesize Bez:} &{\footnotesize konst.} & {\footnotesize logarithm.} & {\footnotesize linear} &{\footnotesize linear log.} & {\footnotesize quadratisch} & {\footnotesize kubisch} & {\footnotesize exponentiell} & {\footnotesize faktoriell} \\
\bottomrule
\end{tabular}}\bigskip
\end{center}
\end{itemize}
\end{frame}
}\fi

% TODO: make sectionlink auto triggerat start of section
\SetNextSectionText[.6\linewidth]{}
\section{Präsenzaufgabe}
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Mit vereinter Kraft!}
\task<2->{Sortieren Sie das folgende Array händisch absteigend mit dem Merge Sort Algorithmus. Geben Sie die Split- und die Mergephase an und begründen Sie, anhand dieser informell die \textit{worst case} Laufzeit von \(\O(n \log n)\) für den Mergesort Algorithmus.}
\onslide<3->{\begin{center}
    \([-1, 0, 9, 4, 1, 2, 3, 5]\)
\end{center}}
\end{aufgabe}
\end{frame}

\begin{frame}[c]{Ein wenig Mergesort}
    % TODO: update array :D
    \resizebox{.975\linewidth}{!}{%
    \begin{tikzpicture}[yscale=0.95,every path/.append style={line cap=round}]
        \onslide<1->{\node (a) at(0,0) {[\(-1, 0, 9, 4, 1, 2, 3, 5\)]};}
        \foreach[count=\i] \l/\x in {{-1,0,9,4}/-4,{1,2,3,5}/4}{
            \onslide<+(1)->{
                \node (b\i) at(\x,-1) {[\(\l\)]};
                \draw[-Kite] (a) -- (b\i);
            }
        }

        \foreach[count=\i] \l/\x/\p in {{-1,0}/-6/1,{9,4}/-2/1,{1,2}/2/2,{3,5}/6/2}{
            \onslide<+(1)->{
                \node (c\i) at(\x,-2) {[\(\l\)]};
                \draw[-Kite] (b\p) -- (c\i);
            }
        }

        \foreach[count=\i] \l/\x/\p in {{-1}/-7/1,{0}/-5/1,{9}/-3/2,{4}/-1/2,%
            {1}/1/3,{2}/3/3,{3}/5/4,{5}/7/4}{
            \onslide<+(1)->{
                \node (d\i) at(\x,-3) {[\(\l\)]};
                \draw[-Kite] (c\p) -- (d\i);
            }
        }

        \onslide<+(1)->{
        \foreach[count=\i] \l/\x/\p in {{-1}/-7/1,{0}/-5/2,{9}/-3/3,{4}/-1/4,%
            {1}/1/5,{2}/3/6,{3}/5/7,{5}/7/8}{
                \node[codeouthl] (e\i) at(\x,-4) {[\(\l\)]};
                \draw[densely dotted,-Kite,codeouthl] (d\p) -- (e\i);
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0}/-6/1/2,{4,9}/-2/3/4,{1,2}/2/5/6,{3,5}/6/7/8}{
            \onslide<+(1)->{
                \node (f\i) at(\x,-5) {[\(\l\)]};
                \ifnum\p=\pt\draw[densely dotted,gray,-Kite] (e\p) -- (f\i);\else \draw[-Kite] (e\p) -- (f\i);\draw[-Kite] (e\pt) -- (f\i); \fi
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0,4,9}/-4/1/2,{1,2,3,4,5}/4/3/4}{
            \onslide<+(1)->{
                \node (g\i) at(\x,-6) {[\(\l\)]};
                \ifnum\p=\pt \draw[densely dotted,gray,-Kite] (f\p) -- (g\i);\else \draw[-Kite] (f\p) -- (g\i);\draw[-Kite] (f\pt) -- (g\i); \fi
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0,1,2,3,4,5,9}/0/1/2}{
            \onslide<+(1)->{
                \node (h\i) at(\x,-7) {[\(\l\)]};
                \draw[-Kite] (g\p) -- (h\i); \draw[-Kite] (g\pt) -- (h\i);
            }
        }
        \onslide<+(1)->{\draw[densely dashed] (-8,-3.5) -- ++(17.25,0) node[above left] {\strut Split} node[below left] {\strut Merge};}
    \end{tikzpicture}
    }
\end{frame}

\begin{frame}{Eigenschaften unter der Lupe}
\begin{itemize}[<+(1)->]
    \itemsep6pt
    \item Mergesort ist \say{easy split, hard join}, bezeichne nun \(n\) die Eingabelänge
    \item Das Aufteilen benötigt immer \(\O(\log n)\) viele Schritte \info{wie bei der binären Suche}\infoblock<0|handout:1>{Genau genommen kommt das auf die Implementation an, nutzen wir Arrays und müssen diese jedes mal kopieren landen wir schon eher bei \(\O(n \log n)\),}
    \item Merge hat auch \(\O(\log n)\) Schritte und muss pro Schritt \(\O(n)\) Elemente vergleichen\pause \infoblock{Bei Mergesort vergleichen wir ja jeweils nur die vordersten Elemente beider Arrays, jeder Vergleich übernimmt ein Element in das Zielarray des Schrittes.}
    \item Alle anderen Operationen (Kopie der Zahl ins Ziel-Array,~\ldots) sind konstant \infoblock<0|handout:1>{Selbst, wenn sie nicht konstant wären, sind Array-Erzeugungen und Kopien alle auch maximal in \(\O(n)\) machbar.}
    \item Wir erhalten: \(\O(\log n) + \O(n) \cdot \O(\log n) \onslide<+(1)->{= \O(\max\{\log n, n \cdot \log n\}) = \O(n \log n)}\)
\end{itemize}
% LAufzeitabschätzung, über DArstelung mit Komma und easy split hard join reden!
% Die Dopplung der mittleren REiheist nicht notwendig, sie dient zur schöneren DArstellung der beiden Phasen (Ein- und Ausgabedaten usw., graue Pfeile)
% TODO: ref in-place mergesort
\end{frame}

\iffull
{\AddonFrame
\immediate\write18{wget https://media.githubusercontent.com/media/EagleoutIce/Episode-Inplace/gh-pages/preview-01.png -O logoInplace-\jobname.png}
\begin{frame}{Mehr Merge! Mehr Sort!}
    \begin{itemize}[<+(1)->]
        \item Es empfiehlt sich irgendwas zwischen die Zahlen zu setzen (wie ein Komma), sonst rutschen diese Erfahrungsgemäß (zu) eng zusammen
        \item Die Verdopplung des Schrittes bei Split und Merge dient der Übersicht, sie ist nicht notwendig.
        \item Merge-Sort gibt es in einigen Flavors. Beispielsweise in-place mergesort:\medskip\pause
\begin{center}
    \scalebox{.75}{\begin{tikzpicture}[align-base]
        \onslide<2->{\draw[thick,darkgray,rounded corners=2.5pt,path picture={\node at(path picture bounding box.center) {\href{https://media.githubusercontent.com/media/EagleoutIce/Episode-Inplace/gh-pages/noanim_inplace-merge.pdf}{\includegraphics[width=8.5cm,height=4.788cm,keepaspectratio]{logoInplace-\jobname.png}}};}] (0,0) rectangle (8.5cm,4.788cm);}
    \end{tikzpicture}}\qquad\fancyqr{https://github.com/EagleoutIce/Episode-Inplace}
\end{center}
    \end{itemize}
\end{frame}}
\fi
\SetNextSectionText{Suchen und Sortieren\\Abgabe: \DTMDate{2022-06-27}}
\section{Übungsblatt 8}
\subsection{Aufgabe 1}
{\taskenum
\begin{frame}{Aufgabe 1: Naive Sortieralgorithmen}
\task<2->{Teil von Übungsblatt~2 war der Entwurf eines naiven Sortieralgorithmus, welcher durch iteratives Vertauschen eine
gegebene Liste aufsteigend sortiert. Hier finden Sie die Algorithmen als Pseudocode nochmals aufgeführt:}
\SetAlgoVlined
\columns[onlytextwidth,c]
\scriptsize
\column{.4\linewidth}
\onslide<3->{\begin{algorithm}[H]
\PreCode
    \KwIn{List \(L = (l_1, \ldots, l_N)\), Indizes \(i\) und~\(j\)}
\StartCode
    make new \(N\) have value \(\mathrm{length}(L)\)\;
    \If{\(N < 2\) \KwOr \(i < 1\) \KwOr \(j < 1\) \KwOr \(i > N\) \KwOr \(j > N\)}{
        print \textit{out} \say{Eingabe ungültig!}\;
        stop program\;
    }
    make new \(t\) have value \(l_i\)\;
    make \(l_i\) have value \(l_j\)\;
    make \(l_j\) have value \(t\)\;
\end{algorithm}}
\column{.6\linewidth}
\onslide<4->{\begin{algorithm}[H]
\PreCode
    \KwIn{List \(L = (l_1, \ldots, l_N)\)}
\StartCode
make new \(N\) have value \(\mathrm{length}(L)\)\;
\lIf{\(N < 2\)}{
    print \textit{out} \say{Eingabe ungültig!} and stop program
}
make new \(i\) have value \(1\)\;
\While{\(i < N\)}{
    make new \(j\) have the value \(i + 1\)\;
    \While{\(j \leq N\)}{
        \lIf{\(l_i > l_j\)}{call \T{vertausche(L, i, j)}}
        Increment \(j\) by \(1\)\;
    }
    Increment \(i\) by \(1\)\;
}
\end{algorithm}}
\endcolumns
\begin{enumerate}
    \item<5-> \task{Implementieren Sie dieses Verfahren nun in Java. Halten Sie sich dabei genau an die Angaben aus den
    gegeben Algorithmen und testen Sie Ihre Implementierung an einem Beispiel.}
    \item<6-> \task{Für die Pseudocodevariante des Sortierverfahrens haben wir bereits eine Laufzeitabschätzung von:\columns[onlytextwidth,c]
    \column{.29\linewidth}\nomathskip
    \begin{equation*}
        T_{max}^{\mathrm{sort}}(n) = 3 + 3n + 12 \cdot \frac{n^2 - n}{3}
    \end{equation*}
    \column{.71\linewidth}
    Elementaroperationen (s. Übungsblatt~2) angegeben. Geben Sie nun hierfür die Laufzeit in der \O-Notation an und begründen Sie ihre Antwort \textit{kurz}.
    \endcolumns}
\end{enumerate}
\end{frame}

\begin{frame}[fragile,c]{Swappsies}
\begin{plainjava}[lineskip=1.5pt]
!*\onslide<3->*!public static void vertausche(!*\Snode{list}*!!*\onslide<5->*!int[] arr!*\Snode{list@}*!,!*\onslide<4->*! int i, int j!*\onslide<3->*!) {
!*\onslide<6->*!    int n = arr.length;
!*\onslide<7->*!    if(n < 2!*\onslide<8->*! || !*\Snode{arr}*!i < 0 || j < 0 || i >= n || j >= n!*\Snode{arr@}*!!*\onslide<7->*!) {
!*\onslide<9->*!        System.err.println("Eingabe ungültig!");
!*\onslide<10->*!        return;!*\Snode{ret@}*!
!*\onslide<7->*!    }
!*\onslide<11->*!    int t = arr[i];
!*\onslide<12->*!    arr[i] = arr[j];
!*\onslide<13->*!    arr[j] = t;
!*\onslide<3->*!}
\end{plainjava}
\onslide<2->{\begin{tikzpicture}[@O]
    \node[above left,yshift=\btdmfootheight,text width=6cm,font=\scriptsize] at(current page.south east) {\color{codeouthl}\SetAlgoVlined\begin{algorithm}[H]
\PreCode
    {\only<3-5>{\color{black}}\KwIn{List \(L = (l_1, \ldots, l_N)\), Indizes \(i\) und~\(j\)}}
\StartCode
    {\only<6>{\color{black}}make new \(N\) have value \(\mathrm{length}(L)\)\;}
    {\only<7-8>{\color{black}}\If{\(N < 2\) \KwOr \(i < 1\) \KwOr \(j < 1\) \KwOr \(i > N\) \KwOr \(j > N\)}{
        \color{codeouthl}
        {\only<9>{\color{black}}print \textit{out} \say{Eingabe ungültig!}\;}
        {\only<10>{\color{black}}stop program\;}
    }}
    {\only<11>{\color{black}}make new \(t\) have value \(l_i\)\;}
    {\only<12>{\color{black}}make \(l_i\) have value \(l_j\)\;}
    {\only<13>{\color{black}}make \(l_j\) have value \(t\)\;}
\end{algorithm}};
\only<0|handout:1>{
    \def\hlcolor{pingu@green}
    \hlbehindcodeunder{list}{@l>}
    \draw[codeouthl,-Kite] ([xshift=-2mm,yshift=.1mm]@l>_up.north) to[out=80,in=180] ++(.5,.65) node[T,below right,yshift=.7\baselineskip,align=left] {Von Zahlen war nicht die Rede. Von Arrays auch nicht!\\Das sind (willkürlich sinnvolle) Annahmen.};
    \def\hlcolor{pingu@purple}
    \hlbehindcodeunder{arr}{@a>}
    \draw[codeouthl,-Kite] ([xshift=-1.25cm,yshift=.1mm]@a>_up.north) to[out=80,in=180] ++(.5,.25) node[T,right] {Mathematisch: \(\{1, \ldots, n\}\), Java: \(\{0, \ldots, n - 1\}\)};
    \node[above right,yshift=\btdmfootheight,T] {Ich habe mir hier die Freiheit genommen, \T{L} und \T{N} umzubenennen.};
    \iffull
    \draw[codeouthl,-Kite] (ret@.east) to[out=-5,in=180] ++(1.2,-.25) node[T,below right,yshift=.6\baselineskip,align=left] {Was machen wir aus \say{stop program}?\\\textbullet~\T{System.exit(1)}?\\\textbullet~Werfen einer Exception?};
    \fi
}
\end{tikzpicture}}
\end{frame}

\begin{frame}[fragile,c]{Sort it!}
\lstfs{8}
\begin{plainjava}
!*\CodeFileMarkerAttach<16->{NaiveSort.java}*!
!*\onslide<3->*!public static void sortiere(int[] arr) {
!*\onslide<4->*!    int n = arr.length;
!*\onslide<5->*!    if (n < 2) {
!*\onslide<6->*!        System.err.println("Eingabe ungültig!");
!*\onslide<7->*!        return;
!*\onslide<5->*!    }
!*\onslide<8->*!    int i = 0;
!*\onslide<9->*!    while(i < arr.length - 1) {
!*\onslide<10->*!        int j = i + 1;
!*\onslide<11->*!        while(j < arr.length) {
!*\onslide<12->*!            if (arr[i] > arr[j]) {
!*\onslide<13->*!                vertausche(arr, i, j);
!*\onslide<12->*!            }
!*\onslide<14->*!            j++;
!*\onslide<11->*!        }
!*\onslide<15->*!        i++;
!*\onslide<9->*!    }
!*\onslide<3->*!}
\end{plainjava}
\onslide<2->{\begin{tikzpicture}[@O]
    \node[above left,yshift=\btdmfootheight,text width=6cm,font=\scriptsize] at(current page.south east) {\color{codeouthl}\SetAlgoVlined\begin{algorithm}[H]
\PreCode
    {\only<3>{\color{black}}\KwIn{List \(L = (l_1, \ldots, l_N)\)}}
\StartCode
{\only<4>{\color{black}}make new \(N\) have value \(\mathrm{length}(L)\)\;}
{\only<5>{\color{black}}\lIf{\(N < 2\)}{
    \color{codeouthl}
    {\only<6-7>{\color{black}}print \textit{out} \say{Eingabe ungültig!}} {\only<7>{\color{black}}and stop program}
}}
{\only<8>{\color{black}}make new \(i\) have value \(1\)\;}
{\only<9>{\color{black}}\While{\(i < N\)}{
    \color{codeouthl}
    {\only<10>{\color{black}}make new \(j\) have the value \(i + 1\)\;}
    {\only<11>{\color{black}}\While{\(j \leq N\)}{
        \color{codeouthl}
        {\only<12>{\color{black}}\lIf{\(l_i > l_j\)}{\color{codeouthl}{\only<13>{\color{black}}call \T{vertausche(L, i, j)}}}}
        {\only<14>{\color{black}}Increment \(j\) by \(1\)\;}
    }}
    {\only<15>{\color{black}}Increment \(i\) by \(1\)\;}
}}
\end{algorithm}};
\end{tikzpicture}}
\end{frame}

\iffull
{
    \AddonFrame
    \begin{frame}{Sort it, for the \sout{children} loops!}
\begin{plainjava}
!*\onslide<2->*!public static void sortiere(int[] arr) {
!*\onslide<3->*!    int n = arr.length;
!*\onslide<3->*!    if (n < 2) {
!*\onslide<3->*!        System.err.println("Eingabe ungültig!");
!*\onslide<3->*!    }
!*\onslide<4->*!    for (int i = 0; i < arr.length; i++) {
!*\onslide<5->*!        for (int j = i + 1; j < arr.length; j++) {
!*\onslide<6->*!            if (arr[i] > arr[j]) {
!*\onslide<6->*!                vertausche(arr, i, j);
!*\onslide<6->*!            }
!*\onslide<5->*!        }
!*\onslide<4->*!    }
!*\onslide<2->*!}
\end{plainjava}
    \end{frame}
}
\fi

\begin{frame}
    TODO: variant with for from file
\end{frame}

\begin{frame}
    EXTRA STUFFSIES
\end{frame}
}

\subsection{Aufgabe 2}
\begin{frame}{Aufgabe 2: Tschudu}
\end{frame}

\subsection{Aufgabe 3}
\begin{frame}{Aufgabe 3: magge disch}
\end{frame}

\iffull
\SetNextSectionText{Suchen und Sortieren~II\\Abgabe: \DTMDate{2022-07-04}}
\section{Aussicht: Übungsblatt 9}
\subsection{Aufgabe 1}
\begin{frame}{Aufgabe 1: Laider daider}
\end{frame}

\fi

\SetNextSectionText[.55\linewidth]{TODO}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep4pt
    \item TODO
\end{itemize}
\end{frame}
}

\outro{\vskip9mm\centering \onslide<2->{\scalebox{1.42}{\begin{tikzpicture}
    % TODO
\end{tikzpicture}}}}

\iffull\end{document}\fi
