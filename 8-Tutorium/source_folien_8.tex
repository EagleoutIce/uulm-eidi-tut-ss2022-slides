\InputIfFileExists{../data/global.src}\relax\relax

\iffull
\title{quaerere atque disponere} % \ldots\ sich selbst
\subtitle{Tutorium M\texorpdfstring{\setbox0=\hbox{a}\resizebox*!{\ht0}{\tiny{8}}}{a}cht}
\date{KW 26}
\addbibresource{references.bib}
\fi
\SetTutoriumNumber{8}

\iffull\begin{document}
\titleframe

\TopicOverview{9}
\fi

\iffull{\SummaryFrame
\begin{frame}[c]{Kurzwiederholung}
\begin{itemize}[<+(1)->]
   \itemsep8pt
    \item Die Rekursionsfamilie \info{Methoden die sich selbst aufrufen} ist riesig: \begin{itemize}
        \itemsep3pt
        \item Ruft sich eine Methode maximal einmal selbst auf, ist sie linear rekursiv.
        \item Head-Rekursiv, wenn dieser Aufruf das erste Statement ist \info{alles passiert im Aufstieg}
        \item Tail-Rekursiv, wenn dieser Aufruf das letzte Statement ist \info{alles passiert im Abstieg}
        \item Ruft sie sich auch mehrfach pro Rekursionsfall auf, ist sie verzweigt rekursiv.
    \end{itemize}
    \item Die \say{Big-O-Notation} nutzen wir zum \info{z.B.} Vergleich der Laufzeitkomplexität:\pause
    \begin{itemize}
        \itemsep3pt
        \item \(T(n) \in \O(f(n))\pause{}\iff \exists n_0 \in \mathbb{N}\: c \in \mathbb{R}^+\: \forall n \geq n_0: T(n) \leq c \cdot f(n)\)
        \item Ab einem gewissen Punkt (\(n_0\)) ist \(c \cdot f(n)\) stets größer als \(T(n)\)
    \end{itemize}
\begin{center}%
\resizebox{\linewidth}{!}{%
\setlength{\aboverulesep}{0pt}%
\setlength{\belowrulesep}{0pt}%
\setlength{\extrarowheight}{.85ex}%
\begin{tabular}{c*{8}{c}}
    \toprule
    & {\cellcolor{pingu@green!100!pingu@purple!21} \(\O(1)\)} & {\cellcolor{pingu@green!85!pingu@purple!21}\(\O(\log n)\)} & {\cellcolor{pingu@green!69!pingu@purple!21} \(\O(n)\)} & {\cellcolor{pingu@green!53!pingu@purple!21} \(\O(n\log n)\)} & {\cellcolor{pingu@green!36!pingu@purple!21} \(\O(n^2)\)} & {\cellcolor{pingu@green!19!pingu@purple!21} \(\O(n^3)\)} & {\cellcolor{pingu@green!14!pingu@purple!21} \(\O(2^n)\)} & {\cellcolor{pingu@green!0!pingu@purple!21} \(\O(n!)\)} \\[0.45ex]\midrule
    {\footnotesize Bez:} &{\footnotesize konst.} & {\footnotesize logarithm.} & {\footnotesize linear} &{\footnotesize linear log.} & {\footnotesize quadratisch} & {\footnotesize kubisch} & {\footnotesize exponentiell} & {\footnotesize faktoriell} \\
\bottomrule
\end{tabular}}\bigskip
\end{center}
\end{itemize}
\end{frame}
}\fi

% TODO: make sectionlink auto triggerat start of section
\SetNextSectionText[.6\linewidth]{}
\section{Präsenzaufgabe}
\begin{frame}[fragile,c]{Präsenzaufgabe}
\begin{aufgabe}{Mit vereinter Kraft!}
\task<2->{Sortieren Sie das folgende Array händisch absteigend mit dem Merge Sort Algorithmus. Geben Sie die Split- und die Mergephase an und begründen Sie, anhand dieser informell die \textit{worst case} Laufzeit von \(\O(n \log n)\) für den Mergesort Algorithmus.}
\onslide<3->{\begin{center}
    \([-1, 0, 9, 4, 1, 2, 3, 5]\)
\end{center}}
\end{aufgabe}
\end{frame}

\begin{frame}[c]{Ein wenig Mergesort}
    % TODO: update array :D
    \resizebox{.975\linewidth}{!}{%
    \begin{tikzpicture}[yscale=0.95,every path/.append style={line cap=round}]
        \onslide<1->{\node (a) at(0,0) {[\(-1, 0, 9, 4, 1, 2, 3, 5\)]};}
        \foreach[count=\i] \l/\x in {{-1,0,9,4}/-4,{1,2,3,5}/4}{
            \onslide<+(1)->{
                \node (b\i) at(\x,-1) {[\(\l\)]};
                \draw[-Kite] (a) -- (b\i);
            }
        }

        \foreach[count=\i] \l/\x/\p in {{-1,0}/-6/1,{9,4}/-2/1,{1,2}/2/2,{3,5}/6/2}{
            \onslide<+(1)->{
                \node (c\i) at(\x,-2) {[\(\l\)]};
                \draw[-Kite] (b\p) -- (c\i);
            }
        }

        \foreach[count=\i] \l/\x/\p in {{-1}/-7/1,{0}/-5/1,{9}/-3/2,{4}/-1/2,%
            {1}/1/3,{2}/3/3,{3}/5/4,{5}/7/4}{
            \onslide<+(1)->{
                \node (d\i) at(\x,-3) {[\(\l\)]};
                \draw[-Kite] (c\p) -- (d\i);
            }
        }

        \onslide<+(1)->{
        \foreach[count=\i] \l/\x/\p in {{-1}/-7/1,{0}/-5/2,{9}/-3/3,{4}/-1/4,%
            {1}/1/5,{2}/3/6,{3}/5/7,{5}/7/8}{
                \node[codeouthl] (e\i) at(\x,-4) {[\(\l\)]};
                \draw[densely dotted,-Kite,codeouthl] (d\p) -- (e\i);
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0}/-6/1/2,{4,9}/-2/3/4,{1,2}/2/5/6,{3,5}/6/7/8}{
            \onslide<+(1)->{
                \node (f\i) at(\x,-5) {[\(\l\)]};
                \ifnum\p=\pt\draw[densely dotted,gray,-Kite] (e\p) -- (f\i);\else \draw[-Kite] (e\p) -- (f\i);\draw[-Kite] (e\pt) -- (f\i); \fi
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0,4,9}/-4/1/2,{1,2,3,4,5}/4/3/4}{
            \onslide<+(1)->{
                \node (g\i) at(\x,-6) {[\(\l\)]};
                \ifnum\p=\pt \draw[densely dotted,gray,-Kite] (f\p) -- (g\i);\else \draw[-Kite] (f\p) -- (g\i);\draw[-Kite] (f\pt) -- (g\i); \fi
            }
        }

        \foreach[count=\i] \l/\x/\p/\pt in {{-1,0,1,2,3,4,5,9}/0/1/2}{
            \onslide<+(1)->{
                \node (h\i) at(\x,-7) {[\(\l\)]};
                \draw[-Kite] (g\p) -- (h\i); \draw[-Kite] (g\pt) -- (h\i);
            }
        }
        \onslide<+(1)->{\draw[densely dashed] (-8,-3.5) -- ++(17.25,0) node[above left] {\strut Split} node[below left] {\strut Merge};}
    \end{tikzpicture}
    }
\end{frame}

\begin{frame}{Eigenschaften unter der Lupe}
\begin{itemize}[<+(1)->]
    \itemsep6pt
    \item Mergesort ist \say{easy split, hard join}, bezeichne nun \(n\) die Eingabelänge
    \item Das Aufteilen benötigt immer \(\O(\log n)\) viele Schritte \info{wie bei der binären Suche}\infoblock<0|handout:1>{Genau genommen kommt das auf die Implementation an, nutzen wir Arrays und müssen diese jedes mal kopieren landen wir schon eher bei \(\O(n \log n)\),}
    \item Merge hat auch \(\O(\log n)\) Schritte und muss pro Schritt \(\O(n)\) Elemente vergleichen\pause \infoblock{Bei Mergesort vergleichen wir ja jeweils nur die vordersten Elemente beider Arrays, jeder Vergleich übernimmt ein Element in das Zielarray des Schrittes.}
    \item Alle anderen Operationen (Kopie der Zahl ins Ziel-Array,~\ldots) sind konstant \infoblock<0|handout:1>{Selbst, wenn sie nicht konstant wären, sind Array-Erzeugungen und Kopien alle auch maximal in \(\O(n)\) machbar.}
    \item Wir erhalten: \(\O(\log n) + \O(n) \cdot \O(\log n) \onslide<+(1)->{= \O(\max\{\log n, n \cdot \log n\}) = \O(n \log n)}\)
\end{itemize}
% LAufzeitabschätzung, über DArstelung mit Komma und easy split hard join reden!
% Die Dopplung der mittleren REiheist nicht notwendig, sie dient zur schöneren DArstellung der beiden Phasen (Ein- und Ausgabedaten usw., graue Pfeile)
% TODO: ref in-place mergesort
\end{frame}

\iffull
{\AddonFrame
\immediate\write18{wget https://media.githubusercontent.com/media/EagleoutIce/Episode-Inplace/gh-pages/preview-01.png -O logoInplace-\jobname.png}
\begin{frame}{Mehr Merge! Mehr Sort!}
    \begin{itemize}[<+(1)->]
        \item Es empfiehlt sich irgendwas zwischen die Zahlen zu setzen (wie ein Komma), sonst rutschen diese Erfahrungsgemäß (zu) eng zusammen
        \item Die Verdopplung des Schrittes bei Split und Merge dient der Übersicht, sie ist nicht notwendig.
        \item Merge-Sort gibt es in einigen Flavors. Beispielsweise in-place mergesort:\medskip\pause
\begin{center}
    \scalebox{.75}{\begin{tikzpicture}[align-base]
        \onslide<2->{\draw[thick,darkgray,rounded corners=2.5pt,path picture={\node at(path picture bounding box.center) {\href{https://media.githubusercontent.com/media/EagleoutIce/Episode-Inplace/gh-pages/noanim_inplace-merge.pdf}{\includegraphics[width=8.5cm,height=4.788cm,keepaspectratio]{logoInplace-\jobname.png}}};}] (0,0) rectangle (8.5cm,4.788cm);}
    \end{tikzpicture}}\qquad\fancyqr{https://github.com/EagleoutIce/Episode-Inplace}
\end{center}
    \end{itemize}
\end{frame}}
\fi

\SetNextSectionText[.55\linewidth]{TODO}
\section{Abschließendes}
{\SummaryFrame
\begin{frame}[t]{Zusammenfassend}
\pause \printBibCommand
\vfill\vfill % double fill for more fraction
\begin{itemize}[<+(1)->]
    \itemsep4pt
    \item TODO
\end{itemize}
\end{frame}
}

\outro{\vskip9mm\centering \onslide<2->{\scalebox{1.42}{\begin{tikzpicture}
    % TODO
\end{tikzpicture}}}}

\iffull\end{document}\fi
